declare namespace java{
    namespace lang{
        class AbstractMethodError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class AssertionError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class AssertionStatusDirectives{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Byte$ByteCache{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharSequence$1CharIterator{
            hasNext(): boolean;
            nextInt(): number;
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: any);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            next(): number;
            forEachRemaining(param0: java.util.function.Consumer);
            remove();
        }
        class CharSequence$1CodePointIterator{
            hasNext(): boolean;
            nextInt(): number;
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: any);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            next(): number;
            forEachRemaining(param0: java.util.function.Consumer);
            remove();
        }
        class Character$Subset{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Character$UnicodeBlock{
            static forName(param0: string): java.lang.Character$UnicodeBlock;
            static of(param0: number): java.lang.Character$UnicodeBlock;
            static of(param0: string): java.lang.Character$UnicodeBlock;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Character$UnicodeScript{
            static forName(param0: string): java.lang.Character$UnicodeScript;
            static values(): any[];
            static valueOf(param0: string): java.lang.Character$UnicodeScript;
            static of(param0: number): java.lang.Character$UnicodeScript;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterData00{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterData01{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterData02{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterData0E{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterDataPrivateUse{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterDataUndefined{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterName$1{
            run(): java.io.InputStream;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterName{
            static get(param0: number): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$2{
            run(): any[];
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$EnclosingMethodInfo{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$MethodArray{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassCircularityError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassFormatError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassLoader$1{
            run(): java.lang.Void;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassValue$Entry{
            get(): any;
            clear();
            isEnqueued(): boolean;
            enqueue(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassValue$Identity{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassValue$Version{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassValue{
            remove(param0: java.lang.Class);
            get(param0: java.lang.Class): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ConditionalSpecialCasing$Entry{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ConditionalSpecialCasing{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Deprecated{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            annotationType(): java.lang.Class;
        }
        class EnumConstantNotPresentException{
            enumType(): java.lang.Class;
            constantName(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class FunctionalInterface{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            annotationType(): java.lang.Class;
        }
        class IllegalThreadStateException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class InheritableThreadLocal{
            remove();
            get(): any;
            set(param0: any);
            static withInitial(param0: java.util.function.Supplier): java.lang.ThreadLocal;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class InstantiationError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Math$RandomNumberGeneratorHolder{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NegativeArraySizeException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NoSuchFieldError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Override{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            annotationType(): java.lang.Class;
        }
        class Package$1{
            run(): java.lang.Package;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Package$1PackageInfoProxy{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$Redirect$1{
            type(): java.lang.ProcessBuilder$Redirect$Type;
            toString(): string;
            equals(param0: any): boolean;
            hashCode(): number;
            static appendTo(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            file(): java.io.File;
            static from(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static to(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$Redirect$2{
            type(): java.lang.ProcessBuilder$Redirect$Type;
            toString(): string;
            equals(param0: any): boolean;
            hashCode(): number;
            static appendTo(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            file(): java.io.File;
            static from(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static to(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$Redirect$3{
            type(): java.lang.ProcessBuilder$Redirect$Type;
            toString(): string;
            file(): java.io.File;
            equals(param0: any): boolean;
            hashCode(): number;
            static appendTo(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static from(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static to(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$Redirect$4{
            type(): java.lang.ProcessBuilder$Redirect$Type;
            toString(): string;
            file(): java.io.File;
            equals(param0: any): boolean;
            hashCode(): number;
            static appendTo(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static from(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static to(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$Redirect$5{
            type(): java.lang.ProcessBuilder$Redirect$Type;
            toString(): string;
            file(): java.io.File;
            equals(param0: any): boolean;
            hashCode(): number;
            static appendTo(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static from(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static to(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$Redirect$Type{
            static values(): any[];
            static valueOf(param0: string): java.lang.ProcessBuilder$Redirect$Type;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$Redirect{
            type(): java.lang.ProcessBuilder$Redirect$Type;
            equals(param0: any): boolean;
            hashCode(): number;
            static appendTo(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            file(): java.io.File;
            static from(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            static to(param0: java.io.File): java.lang.ProcessBuilder$Redirect;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            toString(): string;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessEnvironment$StringEntry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getValue(): string;
            getKey(): string;
            getKey(): any;
            setValue(param0: string): string;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessEnvironment$StringEntrySet$1{
            remove();
            hasNext(): boolean;
            next(): any;
            next(): java.util.Map$Entry;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class ProcessEnvironment$StringEntrySet$2{
            getValue(): java.lang.ProcessEnvironment$Value;
            getValue(): any;
            getKey(): any;
            getKey(): java.lang.ProcessEnvironment$Variable;
            setValue(param0: any): any;
            setValue(param0: java.lang.ProcessEnvironment$Value): java.lang.ProcessEnvironment$Value;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessEnvironment$StringEntrySet{
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class ProcessEnvironment$StringKeySet$1{
            remove();
            hasNext(): boolean;
            next(): any;
            next(): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class ProcessEnvironment$StringKeySet{
            remove(param0: any): boolean;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class ProcessEnvironment$StringValues$1{
            remove();
            hasNext(): boolean;
            next(): any;
            next(): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class ProcessEnvironment$StringValues{
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            add(param0: any): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class SafeVarargs{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            annotationType(): java.lang.Class;
        }
        class SecurityManager$1{
            run(): string;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SecurityManager$2{
            run(): string;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Shutdown$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StrictMath$RandomNumberGeneratorHolder{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class String$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StringCoding$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SuppressWarnings{
            value(): any[];
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            annotationType(): java.lang.Class;
        }
        class System$1{
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Thread$1{
            run(): boolean;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Thread$Caches{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Thread$State{
            static values(): any[];
            static valueOf(param0: string): java.lang.Thread$State;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Thread$WeakClassKey{
            equals(param0: any): boolean;
            hashCode(): number;
            get(): any;
            clear();
            isEnqueued(): boolean;
            enqueue(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            toString(): string;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ThreadLocal$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ThreadLocal$SuppliedThreadLocal{
            remove();
            get(): any;
            set(param0: any);
            static withInitial(param0: java.util.function.Supplier): java.lang.ThreadLocal;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Throwable$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Throwable$SentinelHolder{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TypeNotPresentException{
            typeName(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UNIXProcess$DeferredCloseInputStream{
            read(param0: any[], param1: number, param2: number): number;
            read(): number;
            read(param0: any[]): number;
            close();
            skip(param0: number): number;
            available(): number;
            getFD(): java.io.FileDescriptor;
            getChannel(): java.nio.channels.FileChannel;
            mark(param0: number);
            markSupported(): boolean;
            reset();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UNIXProcess$DeferredCloseProcessPipeInputStream{
            read(): number;
            read(param0: any[]): number;
            read(param0: any[], param1: number, param2: number): number;
            close();
            skip(param0: number): number;
            available(): number;
            mark(param0: number);
            markSupported(): boolean;
            reset();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UNIXProcess$Platform{
            static values(): any[];
            static valueOf(param0: string): java.lang.UNIXProcess$Platform;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UnknownError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UnsupportedClassVersionError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class VerifyError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        namespace annotation{
            class AnnotationFormatError{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class AnnotationTypeMismatchException{
                foundType(): string;
                element(): java.lang.reflect.Method;
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Documented{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class ElementType{
                static values(): any[];
                static valueOf(param0: string): java.lang.annotation.ElementType;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IncompleteAnnotationException{
                annotationType(): java.lang.Class;
                elementName(): string;
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Inherited{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class Native{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class Repeatable{
                value(): java.lang.Class;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class Retention{
                value(): java.lang.annotation.RetentionPolicy;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class RetentionPolicy{
                static values(): any[];
                static valueOf(param0: string): java.lang.annotation.RetentionPolicy;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Target{
                value(): any[];
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class Annotation{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
        }
        namespace instrument{
            class ClassDefinition{
                getDefinitionClass(): java.lang.Class;
                getDefinitionClassFile(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ClassFileTransformer{
                transform(param0: java.lang.ClassLoader, param1: string, param2: java.lang.Class, param3: java.security.ProtectionDomain, param4: any[]): any[];
            }
            class IllegalClassFormatException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Instrumentation{
                addTransformer(param0: java.lang.instrument.ClassFileTransformer, param1: boolean);
                addTransformer(param0: java.lang.instrument.ClassFileTransformer);
                removeTransformer(param0: java.lang.instrument.ClassFileTransformer): boolean;
                isModifiableClass(param0: java.lang.Class): boolean;
                isRetransformClassesSupported(): boolean;
                retransformClasses(param0: any[]);
                isRedefineClassesSupported(): boolean;
                redefineClasses(param0: any[]);
                getAllLoadedClasses(): any[];
                getInitiatedClasses(param0: java.lang.ClassLoader): any[];
                getObjectSize(param0: any): number;
                appendToBootstrapClassLoaderSearch(param0: java.util.jar.JarFile);
                appendToSystemClassLoaderSearch(param0: java.util.jar.JarFile);
                isNativeMethodPrefixSupported(): boolean;
                setNativeMethodPrefix(param0: java.lang.instrument.ClassFileTransformer, param1: string);
            }
            class UnmodifiableClassException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        namespace invoke{
            class AbstractValidatingLambdaMetafactory{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class BoundMethodHandle$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class BoundMethodHandle$Factory$1{
                apply(param0: string): java.lang.Class;
                apply(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                compose(param0: java.util.function.Function): java.util.function.Function;
                andThen(param0: java.util.function.Function): java.util.function.Function;
            }
            class BoundMethodHandle$Factory{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class BoundMethodHandle$SpeciesData$1{
                apply(param0: string): java.lang.invoke.BoundMethodHandle$SpeciesData;
                apply(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                compose(param0: java.util.function.Function): java.util.function.Function;
                andThen(param0: java.util.function.Function): java.util.function.Function;
            }
            class BoundMethodHandle$SpeciesData{
                toString(): string;
                fieldHolder(): java.lang.Class;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class BoundMethodHandle$Species_L{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class BoundMethodHandle{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DelegatingMethodHandle{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle$Accessor{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle$Constructor{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle$EnsureInitialized{
                remove(param0: java.lang.Class);
                get(param0: java.lang.Class): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle$Interface{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle$Lazy{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle$Special{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle$StaticAccessor{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DontInline{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class ForceInline{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class InfoFromMemberName$1{
                run(): java.lang.reflect.Member;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InfoFromMemberName{
                toString(): string;
                getModifiers(): number;
                getName(): string;
                getDeclaringClass(): java.lang.Class;
                getMethodType(): java.lang.invoke.MethodType;
                getReferenceKind(): number;
                reflectAs(param0: java.lang.Class, param1: java.lang.invoke.MethodHandles$Lookup): java.lang.reflect.Member;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                isVarArgs(): boolean;
            }
            class InjectedProfile{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class InnerClassLambdaMetafactory$1{
                run(): any[];
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InnerClassLambdaMetafactory$2{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InnerClassLambdaMetafactory$ForwardingMethodGenerator{
                visitJumpInsn(param0: number, param1: jdk.internal.org.objectweb.asm.Label);
                visitLabel(param0: jdk.internal.org.objectweb.asm.Label);
                visitTryCatchBlock(param0: jdk.internal.org.objectweb.asm.Label, param1: jdk.internal.org.objectweb.asm.Label, param2: jdk.internal.org.objectweb.asm.Label, param3: string);
                visitTypeAnnotation(param0: number, param1: jdk.internal.org.objectweb.asm.TypePath, param2: string, param3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitAttribute(param0: jdk.internal.org.objectweb.asm.Attribute);
                visitParameter(param0: string, param1: number);
                visitAnnotationDefault(): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitParameterAnnotation(param0: number, param1: string, param2: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitFrame(param0: number, param1: number, param2: any[], param3: number, param4: any[]);
                visitInvokeDynamicInsn(param0: string, param1: string, param2: jdk.internal.org.objectweb.asm.Handle, param3: any[]);
                visitIincInsn(param0: number, param1: number);
                visitTableSwitchInsn(param0: number, param1: number, param2: jdk.internal.org.objectweb.asm.Label, param3: any[]);
                visitLookupSwitchInsn(param0: jdk.internal.org.objectweb.asm.Label, param1: any[], param2: any[]);
                visitMultiANewArrayInsn(param0: string, param1: number);
                visitInsnAnnotation(param0: number, param1: jdk.internal.org.objectweb.asm.TypePath, param2: string, param3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitTryCatchAnnotation(param0: number, param1: jdk.internal.org.objectweb.asm.TypePath, param2: string, param3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitLocalVariable(param0: string, param1: string, param2: string, param3: jdk.internal.org.objectweb.asm.Label, param4: jdk.internal.org.objectweb.asm.Label, param5: number);
                visitLocalVariableAnnotation(param0: number, param1: jdk.internal.org.objectweb.asm.TypePath, param2: any[], param3: any[], param4: any[], param5: string, param6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitLineNumber(param0: number, param1: jdk.internal.org.objectweb.asm.Label);
                visitAnnotation(param0: string, param1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitEnd();
                visitCode();
                visitMethodInsn(param0: number, param1: string, param2: string, param3: string);
                visitMethodInsn(param0: number, param1: string, param2: string, param3: string, param4: boolean);
                visitInsn(param0: number);
                visitMaxs(param0: number, param1: number);
                visitIntInsn(param0: number, param1: number);
                visitTypeInsn(param0: number, param1: string);
                visitLdcInsn(param0: any);
                visitVarInsn(param0: number, param1: number);
                visitFieldInsn(param0: number, param1: string, param2: string, param3: string);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InnerClassLambdaMetafactory{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InvokeDynamic{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InvokerBytecodeGenerator$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InvokerBytecodeGenerator$2{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InvokerBytecodeGenerator$CpPatch{
                toString(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InvokerBytecodeGenerator{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Invokers$Lazy{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaConversionException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaForm$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaForm$BasicType{
                static values(): any[];
                static valueOf(param0: string): java.lang.invoke.LambdaForm$BasicType;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaForm$Compiled{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class LambdaForm$Hidden{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class LambdaForm$Name{
                equals(param0: any): boolean;
                equals(param0: java.lang.invoke.LambdaForm$Name): boolean;
                toString(): string;
                hashCode(): number;
                debugString(): string;
                paramString(): string;
                exprString(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaFormBuffer{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaFormEditor$Transform$Kind{
                static values(): any[];
                static valueOf(param0: string): java.lang.invoke.LambdaFormEditor$Transform$Kind;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaFormEditor$Transform{
                equals(param0: any): boolean;
                equals(param0: java.lang.invoke.LambdaFormEditor$Transform): boolean;
                toString(): string;
                hashCode(): number;
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaFormEditor{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaMetafactory{
                static metafactory(param0: java.lang.invoke.MethodHandles$Lookup, param1: string, param2: java.lang.invoke.MethodType, param3: java.lang.invoke.MethodType, param4: java.lang.invoke.MethodHandle, param5: java.lang.invoke.MethodType): java.lang.invoke.CallSite;
                static altMetafactory(param0: java.lang.invoke.MethodHandles$Lookup, param1: string, param2: java.lang.invoke.MethodType, param3: any[]): java.lang.invoke.CallSite;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandle$PolymorphicSignature{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class MethodHandleImpl$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$2{
                apply(param0: java.lang.invoke.MethodHandle): java.lang.invoke.LambdaForm;
                apply(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                compose(param0: java.util.function.Function): java.util.function.Function;
                andThen(param0: java.util.function.Function): java.util.function.Function;
            }
            class MethodHandleImpl$3{
                apply(param0: java.lang.invoke.MethodHandle): java.lang.invoke.LambdaForm;
                apply(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                compose(param0: java.util.function.Function): java.util.function.Function;
                andThen(param0: java.util.function.Function): java.util.function.Function;
            }
            class MethodHandleImpl$4{
                remove(param0: java.lang.Class);
                get(param0: java.lang.Class): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$ArrayAccessor$1{
                remove(param0: java.lang.Class);
                get(param0: java.lang.Class): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$ArrayAccessor{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$AsVarargsCollector{
                asTypeUncached(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$BindCaller$1{
                remove(param0: java.lang.Class);
                get(param0: java.lang.Class): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$BindCaller$2{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$BindCaller$T{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$BindCaller{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$CountingWrapper{
                asTypeUncached(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$Intrinsic{
                static values(): any[];
                static valueOf(param0: string): java.lang.invoke.MethodHandleImpl$Intrinsic;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$IntrinsicMethodHandle{
                asTypeUncached(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$Lazy{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl$WrappedMember{
                asTypeUncached(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleInfo{
                static toString(param0: number, param1: java.lang.Class, param2: string, param3: java.lang.invoke.MethodType): string;
                getModifiers(): number;
                getName(): string;
                getDeclaringClass(): java.lang.Class;
                isVarArgs(): boolean;
                getMethodType(): java.lang.invoke.MethodType;
                getReferenceKind(): number;
                reflectAs(param0: java.lang.Class, param1: java.lang.invoke.MethodHandles$Lookup): java.lang.reflect.Member;
                static referenceKindToString(param0: number): string;
            }
            class MethodHandleNatives$Constants{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleProxies$1{
                invoke(param0: any, param1: java.lang.reflect.Method, param2: any[]): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleProxies$2{
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleProxies{
                static asInterfaceInstance(param0: java.lang.Class, param1: java.lang.invoke.MethodHandle): any;
                static isWrapperInstance(param0: any): boolean;
                static wrapperInstanceTarget(param0: any): java.lang.invoke.MethodHandle;
                static wrapperInstanceType(param0: any): java.lang.Class;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandles$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandles$Lookup{
                toString(): string;
                in(param0: java.lang.Class): java.lang.invoke.MethodHandles$Lookup;
                findVirtual(param0: java.lang.Class, param1: string, param2: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                findStatic(param0: java.lang.Class, param1: string, param2: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                unreflect(param0: java.lang.reflect.Method): java.lang.invoke.MethodHandle;
                lookupClass(): java.lang.Class;
                lookupModes(): number;
                findConstructor(param0: java.lang.Class, param1: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                findSpecial(param0: java.lang.Class, param1: string, param2: java.lang.invoke.MethodType, param3: java.lang.Class): java.lang.invoke.MethodHandle;
                findGetter(param0: java.lang.Class, param1: string, param2: java.lang.Class): java.lang.invoke.MethodHandle;
                findSetter(param0: java.lang.Class, param1: string, param2: java.lang.Class): java.lang.invoke.MethodHandle;
                findStaticGetter(param0: java.lang.Class, param1: string, param2: java.lang.Class): java.lang.invoke.MethodHandle;
                findStaticSetter(param0: java.lang.Class, param1: string, param2: java.lang.Class): java.lang.invoke.MethodHandle;
                bind(param0: any, param1: string, param2: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                unreflectSpecial(param0: java.lang.reflect.Method, param1: java.lang.Class): java.lang.invoke.MethodHandle;
                unreflectConstructor(param0: java.lang.reflect.Constructor): java.lang.invoke.MethodHandle;
                unreflectGetter(param0: java.lang.reflect.Field): java.lang.invoke.MethodHandle;
                unreflectSetter(param0: java.lang.reflect.Field): java.lang.invoke.MethodHandle;
                revealDirect(param0: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandleInfo;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandles{
                static throwException(param0: java.lang.Class, param1: java.lang.Class): java.lang.invoke.MethodHandle;
                static identity(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                static spreadInvoker(param0: java.lang.invoke.MethodType, param1: number): java.lang.invoke.MethodHandle;
                static permuteArguments(param0: java.lang.invoke.MethodHandle, param1: java.lang.invoke.MethodType, param2: any[]): java.lang.invoke.MethodHandle;
                static exactInvoker(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                static foldArguments(param0: java.lang.invoke.MethodHandle, param1: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle;
                static lookup(): java.lang.invoke.MethodHandles$Lookup;
                static invoker(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                static publicLookup(): java.lang.invoke.MethodHandles$Lookup;
                static insertArguments(param0: java.lang.invoke.MethodHandle, param1: number, param2: any[]): java.lang.invoke.MethodHandle;
                static reflectAs(param0: java.lang.Class, param1: java.lang.invoke.MethodHandle): java.lang.reflect.Member;
                static arrayElementSetter(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                static explicitCastArguments(param0: java.lang.invoke.MethodHandle, param1: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                static filterArguments(param0: java.lang.invoke.MethodHandle, param1: number, param2: any[]): java.lang.invoke.MethodHandle;
                static filterReturnValue(param0: java.lang.invoke.MethodHandle, param1: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle;
                static guardWithTest(param0: java.lang.invoke.MethodHandle, param1: java.lang.invoke.MethodHandle, param2: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle;
                static catchException(param0: java.lang.invoke.MethodHandle, param1: java.lang.Class, param2: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle;
                static arrayElementGetter(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                static dropArguments(param0: java.lang.invoke.MethodHandle, param1: number, param2: any[]): java.lang.invoke.MethodHandle;
                static dropArguments(param0: java.lang.invoke.MethodHandle, param1: number, param2: java.util.List): java.lang.invoke.MethodHandle;
                static collectArguments(param0: java.lang.invoke.MethodHandle, param1: number, param2: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle;
                static constant(param0: java.lang.Class, param1: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ProxyClassesDumper$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ProxyClassesDumper{
                static getInstance(param0: string): java.lang.invoke.ProxyClassesDumper;
                dumpClass(param0: string, param1: any[]);
                static encodeForFilename(param0: string): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SerializedLambda$1{
                run(): java.lang.reflect.Method;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SerializedLambda{
                toString(): string;
                getImplMethodName(): string;
                getImplMethodKind(): number;
                getFunctionalInterfaceClass(): string;
                getFunctionalInterfaceMethodName(): string;
                getFunctionalInterfaceMethodSignature(): string;
                getImplClass(): string;
                getImplMethodSignature(): string;
                getCapturedArg(param0: number): any;
                getCapturingClass(): string;
                getInstantiatedMethodType(): string;
                getCapturedArgCount(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SimpleMethodHandle{
                speciesData(): java.lang.invoke.BoundMethodHandle$SpeciesData;
                fieldCount(): number;
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Stable{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                annotationType(): java.lang.Class;
            }
            class SwitchPoint{
                guardWithTest(param0: java.lang.invoke.MethodHandle, param1: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle;
                hasBeenInvalidated(): boolean;
                static invalidateAll(param0: any[]);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TypeConvertingMethodAdapter{
                visitJumpInsn(param0: number, param1: jdk.internal.org.objectweb.asm.Label);
                visitLabel(param0: jdk.internal.org.objectweb.asm.Label);
                visitTryCatchBlock(param0: jdk.internal.org.objectweb.asm.Label, param1: jdk.internal.org.objectweb.asm.Label, param2: jdk.internal.org.objectweb.asm.Label, param3: string);
                visitTypeAnnotation(param0: number, param1: jdk.internal.org.objectweb.asm.TypePath, param2: string, param3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitAttribute(param0: jdk.internal.org.objectweb.asm.Attribute);
                visitParameter(param0: string, param1: number);
                visitAnnotationDefault(): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitParameterAnnotation(param0: number, param1: string, param2: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitFrame(param0: number, param1: number, param2: any[], param3: number, param4: any[]);
                visitInvokeDynamicInsn(param0: string, param1: string, param2: jdk.internal.org.objectweb.asm.Handle, param3: any[]);
                visitIincInsn(param0: number, param1: number);
                visitTableSwitchInsn(param0: number, param1: number, param2: jdk.internal.org.objectweb.asm.Label, param3: any[]);
                visitLookupSwitchInsn(param0: jdk.internal.org.objectweb.asm.Label, param1: any[], param2: any[]);
                visitMultiANewArrayInsn(param0: string, param1: number);
                visitInsnAnnotation(param0: number, param1: jdk.internal.org.objectweb.asm.TypePath, param2: string, param3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitTryCatchAnnotation(param0: number, param1: jdk.internal.org.objectweb.asm.TypePath, param2: string, param3: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitLocalVariable(param0: string, param1: string, param2: string, param3: jdk.internal.org.objectweb.asm.Label, param4: jdk.internal.org.objectweb.asm.Label, param5: number);
                visitLocalVariableAnnotation(param0: number, param1: jdk.internal.org.objectweb.asm.TypePath, param2: any[], param3: any[], param4: any[], param5: string, param6: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitLineNumber(param0: number, param1: jdk.internal.org.objectweb.asm.Label);
                visitAnnotation(param0: string, param1: boolean): jdk.internal.org.objectweb.asm.AnnotationVisitor;
                visitEnd();
                visitCode();
                visitMethodInsn(param0: number, param1: string, param2: string, param3: string);
                visitMethodInsn(param0: number, param1: string, param2: string, param3: string, param4: boolean);
                visitInsn(param0: number);
                visitMaxs(param0: number, param1: number);
                visitIntInsn(param0: number, param1: number);
                visitTypeInsn(param0: number, param1: string);
                visitLdcInsn(param0: any);
                visitVarInsn(param0: number, param1: number);
                visitFieldInsn(param0: number, param1: string, param2: string, param3: string);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class WrongMethodTypeException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class VolatileCallSite{
                dynamicInvoker(): java.lang.invoke.MethodHandle;
                getTarget(): java.lang.invoke.MethodHandle;
                setTarget(param0: java.lang.invoke.MethodHandle);
                type(): java.lang.invoke.MethodType;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MutableCallSite{
                dynamicInvoker(): java.lang.invoke.MethodHandle;
                getTarget(): java.lang.invoke.MethodHandle;
                setTarget(param0: java.lang.invoke.MethodHandle);
                static syncAll(param0: any[]);
                type(): java.lang.invoke.MethodType;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodTypeForm{
                toString(): string;
                basicType(): java.lang.invoke.MethodType;
                cachedLambdaForm(param0: number): java.lang.invoke.LambdaForm;
                setCachedLambdaForm(param0: number, param1: java.lang.invoke.LambdaForm): java.lang.invoke.LambdaForm;
                parameterCount(): number;
                hasPrimitives(): boolean;
                parameterSlotCount(): number;
                returnSlotCount(): number;
                erasedType(): java.lang.invoke.MethodType;
                static canonicalize(param0: java.lang.invoke.MethodType, param1: number, param2: number): java.lang.invoke.MethodType;
                primitiveParameterCount(): number;
                parameterToArgSlot(param0: number): number;
                cachedMethodHandle(param0: number): java.lang.invoke.MethodHandle;
                setCachedMethodHandle(param0: number, param1: java.lang.invoke.MethodHandle): java.lang.invoke.MethodHandle;
                returnCount(): number;
                longPrimitiveParameterCount(): number;
                primitiveReturnCount(): number;
                longPrimitiveReturnCount(): number;
                hasNonVoidPrimitives(): boolean;
                hasLongPrimitives(): boolean;
                argSlotToParameter(param0: number): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodType$ConcurrentWeakInternSet$WeakEntry{
                equals(param0: any): boolean;
                hashCode(): number;
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodType$ConcurrentWeakInternSet{
                add(param0: any): any;
                get(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodType{
                returnType(): java.lang.Class;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                wrap(): java.lang.invoke.MethodType;
                insertParameterTypes(param0: number, param1: java.util.List): java.lang.invoke.MethodType;
                insertParameterTypes(param0: number, param1: any[]): java.lang.invoke.MethodType;
                changeReturnType(param0: java.lang.Class): java.lang.invoke.MethodType;
                static methodType(param0: java.lang.Class, param1: any[]): java.lang.invoke.MethodType;
                static methodType(param0: java.lang.Class, param1: java.lang.Class, param2: any[]): java.lang.invoke.MethodType;
                static methodType(param0: java.lang.Class): java.lang.invoke.MethodType;
                static methodType(param0: java.lang.Class, param1: java.lang.invoke.MethodType): java.lang.invoke.MethodType;
                static methodType(param0: java.lang.Class, param1: java.lang.Class): java.lang.invoke.MethodType;
                static methodType(param0: java.lang.Class, param1: java.util.List): java.lang.invoke.MethodType;
                dropParameterTypes(param0: number, param1: number): java.lang.invoke.MethodType;
                appendParameterTypes(param0: java.util.List): java.lang.invoke.MethodType;
                appendParameterTypes(param0: any[]): java.lang.invoke.MethodType;
                parameterCount(): number;
                static genericMethodType(param0: number): java.lang.invoke.MethodType;
                static genericMethodType(param0: number, param1: boolean): java.lang.invoke.MethodType;
                parameterType(param0: number): java.lang.Class;
                static fromMethodDescriptorString(param0: string, param1: java.lang.ClassLoader): java.lang.invoke.MethodType;
                parameterArray(): any[];
                erase(): java.lang.invoke.MethodType;
                parameterList(): java.util.List;
                changeParameterType(param0: number, param1: java.lang.Class): java.lang.invoke.MethodType;
                hasPrimitives(): boolean;
                hasWrappers(): boolean;
                generic(): java.lang.invoke.MethodType;
                unwrap(): java.lang.invoke.MethodType;
                toMethodDescriptorString(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleStatics$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleStatics{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleNatives{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandleImpl{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MethodHandle{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MemberName$Factory{
                getFields(param0: java.lang.Class, param1: boolean, param2: java.lang.Class): java.util.List;
                getFields(param0: java.lang.Class, param1: boolean, param2: string, param3: java.lang.Class, param4: java.lang.Class): java.util.List;
                getMethods(param0: java.lang.Class, param1: boolean, param2: java.lang.Class): java.util.List;
                getMethods(param0: java.lang.Class, param1: boolean, param2: string, param3: java.lang.invoke.MethodType, param4: java.lang.Class): java.util.List;
                getConstructors(param0: java.lang.Class, param1: java.lang.Class): java.util.List;
                resolveOrNull(param0: number, param1: java.lang.invoke.MemberName, param2: java.lang.Class): java.lang.invoke.MemberName;
                resolveOrFail(param0: number, param1: java.lang.invoke.MemberName, param2: java.lang.Class, param3: java.lang.Class): java.lang.invoke.MemberName;
                getNestedTypes(param0: java.lang.Class, param1: boolean, param2: java.lang.Class): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MemberName{
                equals(param0: java.lang.invoke.MemberName): boolean;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getModifiers(): number;
                getName(): string;
                isSynthetic(): boolean;
                getClassLoader(): java.lang.ClassLoader;
                getDeclaringClass(): java.lang.Class;
                isMethod(): boolean;
                getReturnType(): java.lang.Class;
                getParameterTypes(): any[];
                isConstructor(): boolean;
                isAbstract(): boolean;
                isStatic(): boolean;
                isProtected(): boolean;
                getType(): any;
                isBridge(): boolean;
                getSignature(): string;
                isFinal(): boolean;
                isResolved(): boolean;
                getMethodType(): java.lang.invoke.MethodType;
                getReferenceKind(): number;
                isPublic(): boolean;
                getMethodOrFieldType(): java.lang.invoke.MethodType;
                isField(): boolean;
                asSpecial(): java.lang.invoke.MemberName;
                asConstructor(): java.lang.invoke.MemberName;
                isInvocable(): boolean;
                getInvocationType(): java.lang.invoke.MethodType;
                isMethodHandleInvoke(): boolean;
                getFieldType(): java.lang.Class;
                isVolatile(): boolean;
                isVarargs(): boolean;
                makeAccessException(param0: string, param1: any): java.lang.IllegalAccessException;
                makeAccessException(): java.lang.ReflectiveOperationException;
                static isMethodHandleInvokeName(param0: string): boolean;
                isPrivate(): boolean;
                canBeStaticallyBound(): boolean;
                isNative(): boolean;
                isFieldOrMethod(): boolean;
                isType(): boolean;
                isPackage(): boolean;
                isCallerSensitive(): boolean;
                isAccessibleFrom(param0: java.lang.Class): boolean;
                asNormalOriginal(): java.lang.invoke.MemberName;
                isGetter(): boolean;
                isSetter(): boolean;
                asSetter(): java.lang.invoke.MemberName;
                getDefinition(): java.lang.invoke.MemberName;
                hasReceiverTypeDispatch(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaForm$NamedFunction{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                intrinsicName(): java.lang.invoke.MethodHandleImpl$Intrinsic;
                isConstantZero(): boolean;
                isIdentity(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LambdaForm{
                equals(param0: any): boolean;
                equals(param0: java.lang.invoke.LambdaForm): boolean;
                toString(): string;
                hashCode(): number;
                static basicTypeSignature(param0: java.lang.invoke.MethodType): string;
                static shortenSignature(param0: string): string;
                prepare();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Invokers{
                toString(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DirectMethodHandle{
                invoke(param0: any[]): any;
                type(): java.lang.invoke.MethodType;
                toString(): string;
                invokeExact(param0: any[]): any;
                invokeWithArguments(param0: any[]): any;
                invokeWithArguments(param0: java.util.List): any;
                asType(param0: java.lang.invoke.MethodType): java.lang.invoke.MethodHandle;
                asSpreader(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asCollector(param0: java.lang.Class, param1: number): java.lang.invoke.MethodHandle;
                asVarargsCollector(param0: java.lang.Class): java.lang.invoke.MethodHandle;
                isVarargsCollector(): boolean;
                asFixedArity(): java.lang.invoke.MethodHandle;
                bindTo(param0: any): java.lang.invoke.MethodHandle;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConstantCallSite{
                dynamicInvoker(): java.lang.invoke.MethodHandle;
                getTarget(): java.lang.invoke.MethodHandle;
                setTarget(param0: java.lang.invoke.MethodHandle);
                type(): java.lang.invoke.MethodType;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CallSite{
                type(): java.lang.invoke.MethodType;
                dynamicInvoker(): java.lang.invoke.MethodHandle;
                getTarget(): java.lang.invoke.MethodHandle;
                setTarget(param0: java.lang.invoke.MethodHandle);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        namespace management{
            class BufferPoolMXBean{
                getName(): string;
                getCount(): number;
                getTotalCapacity(): number;
                getMemoryUsed(): number;
                getObjectName(): javax.management.ObjectName;
            }
            class ClassLoadingMXBean{
                getTotalLoadedClassCount(): number;
                getLoadedClassCount(): number;
                getUnloadedClassCount(): number;
                isVerbose(): boolean;
                setVerbose(param0: boolean);
                getObjectName(): javax.management.ObjectName;
            }
            class CompilationMXBean{
                getName(): string;
                isCompilationTimeMonitoringSupported(): boolean;
                getTotalCompilationTime(): number;
                getObjectName(): javax.management.ObjectName;
            }
            class GarbageCollectorMXBean{
                getCollectionCount(): number;
                getCollectionTime(): number;
                getName(): string;
                isValid(): boolean;
                getMemoryPoolNames(): any[];
                getObjectName(): javax.management.ObjectName;
            }
            class LockInfo{
                toString(): string;
                getClassName(): string;
                getIdentityHashCode(): number;
                static from(param0: javax.management.openmbean.CompositeData): java.lang.management.LockInfo;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ManagementFactory$1{
                run(): java.lang.ClassLoader;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ManagementFactory$2{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ManagementFactory$3{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ManagementFactory{
                static newPlatformMXBeanProxy(param0: javax.management.MBeanServerConnection, param1: string, param2: java.lang.Class): any;
                static getClassLoadingMXBean(): java.lang.management.ClassLoadingMXBean;
                static getMemoryMXBean(): java.lang.management.MemoryMXBean;
                static getThreadMXBean(): java.lang.management.ThreadMXBean;
                static getRuntimeMXBean(): java.lang.management.RuntimeMXBean;
                static getCompilationMXBean(): java.lang.management.CompilationMXBean;
                static getOperatingSystemMXBean(): java.lang.management.OperatingSystemMXBean;
                static getMemoryPoolMXBeans(): java.util.List;
                static getMemoryManagerMXBeans(): java.util.List;
                static getGarbageCollectorMXBeans(): java.util.List;
                static getPlatformMBeanServer(): javax.management.MBeanServer;
                static getPlatformMXBean(param0: java.lang.Class): java.lang.management.PlatformManagedObject;
                static getPlatformMXBean(param0: javax.management.MBeanServerConnection, param1: java.lang.Class): java.lang.management.PlatformManagedObject;
                static getPlatformMXBeans(param0: java.lang.Class): java.util.List;
                static getPlatformMXBeans(param0: javax.management.MBeanServerConnection, param1: java.lang.Class): java.util.List;
                static getPlatformManagementInterfaces(): java.util.Set;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ManagementPermission{
                equals(param0: any): boolean;
                hashCode(): number;
                implies(param0: java.security.Permission): boolean;
                getActions(): string;
                newPermissionCollection(): java.security.PermissionCollection;
                toString(): string;
                getName(): string;
                checkGuard(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MemoryMXBean{
                gc();
                isVerbose(): boolean;
                setVerbose(param0: boolean);
                getObjectPendingFinalizationCount(): number;
                getHeapMemoryUsage(): java.lang.management.MemoryUsage;
                getNonHeapMemoryUsage(): java.lang.management.MemoryUsage;
                getObjectName(): javax.management.ObjectName;
            }
            class MemoryManagerMXBean{
                getName(): string;
                isValid(): boolean;
                getMemoryPoolNames(): any[];
                getObjectName(): javax.management.ObjectName;
            }
            class MemoryNotificationInfo{
                getCount(): number;
                static from(param0: javax.management.openmbean.CompositeData): java.lang.management.MemoryNotificationInfo;
                getPoolName(): string;
                getUsage(): java.lang.management.MemoryUsage;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MemoryPoolMXBean{
                getName(): string;
                getType(): java.lang.management.MemoryType;
                isValid(): boolean;
                getUsage(): java.lang.management.MemoryUsage;
                getPeakUsage(): java.lang.management.MemoryUsage;
                resetPeakUsage();
                getMemoryManagerNames(): any[];
                getUsageThreshold(): number;
                setUsageThreshold(param0: number);
                isUsageThresholdExceeded(): boolean;
                getUsageThresholdCount(): number;
                isUsageThresholdSupported(): boolean;
                getCollectionUsageThreshold(): number;
                setCollectionUsageThreshold(param0: number);
                isCollectionUsageThresholdExceeded(): boolean;
                getCollectionUsageThresholdCount(): number;
                getCollectionUsage(): java.lang.management.MemoryUsage;
                isCollectionUsageThresholdSupported(): boolean;
                getObjectName(): javax.management.ObjectName;
            }
            class MemoryType{
                toString(): string;
                static values(): any[];
                static valueOf(param0: string): java.lang.management.MemoryType;
                name(): string;
                equals(param0: any): boolean;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MemoryUsage{
                toString(): string;
                static from(param0: javax.management.openmbean.CompositeData): java.lang.management.MemoryUsage;
                getInit(): number;
                getUsed(): number;
                getCommitted(): number;
                getMax(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MonitorInfo{
                static from(param0: javax.management.openmbean.CompositeData): java.lang.management.MonitorInfo;
                getLockedStackDepth(): number;
                getLockedStackFrame(): java.lang.StackTraceElement;
                toString(): string;
                getClassName(): string;
                getIdentityHashCode(): number;
                static from(param0: javax.management.openmbean.CompositeData): java.lang.management.LockInfo;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class OperatingSystemMXBean{
                getName(): string;
                getArch(): string;
                getVersion(): string;
                getAvailableProcessors(): number;
                getSystemLoadAverage(): number;
                getObjectName(): javax.management.ObjectName;
            }
            class PlatformComponent$1{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$10{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$11{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$12{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$13{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$14{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$15{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$2{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$3{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$4{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$5{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$6{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$7{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$8{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$9{
                getMXBeans(): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformComponent$MXBeanFetcher{
                getMXBeans(): java.util.List;
            }
            class PlatformComponent{
                static values(): any[];
                static valueOf(param0: string): java.lang.management.PlatformComponent;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PlatformLoggingMXBean{
                getLoggerNames(): java.util.List;
                getLoggerLevel(param0: string): string;
                setLoggerLevel(param0: string, param1: string);
                getParentLoggerName(param0: string): string;
                getObjectName(): javax.management.ObjectName;
            }
            class PlatformManagedObject{
                getObjectName(): javax.management.ObjectName;
            }
            class RuntimeMXBean{
                getName(): string;
                getClassPath(): string;
                getVmName(): string;
                getVmVendor(): string;
                getVmVersion(): string;
                getSpecName(): string;
                getSpecVendor(): string;
                getSpecVersion(): string;
                getManagementSpecVersion(): string;
                getLibraryPath(): string;
                isBootClassPathSupported(): boolean;
                getBootClassPath(): string;
                getInputArguments(): java.util.List;
                getUptime(): number;
                getStartTime(): number;
                getSystemProperties(): java.util.Map;
                getObjectName(): javax.management.ObjectName;
            }
            class ThreadInfo$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadInfo{
                toString(): string;
                getStackTrace(): any[];
                getLockInfo(): java.lang.management.LockInfo;
                getThreadId(): number;
                static from(param0: javax.management.openmbean.CompositeData): java.lang.management.ThreadInfo;
                getThreadName(): string;
                getThreadState(): java.lang.Thread$State;
                getBlockedTime(): number;
                getBlockedCount(): number;
                getWaitedTime(): number;
                getWaitedCount(): number;
                getLockName(): string;
                getLockOwnerId(): number;
                getLockOwnerName(): string;
                isSuspended(): boolean;
                isInNative(): boolean;
                getLockedMonitors(): any[];
                getLockedSynchronizers(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadMXBean{
                getThreadCount(): number;
                getPeakThreadCount(): number;
                getTotalStartedThreadCount(): number;
                getDaemonThreadCount(): number;
                getAllThreadIds(): any[];
                getThreadInfo(param0: any[], param1: boolean, param2: boolean): any[];
                getThreadInfo(param0: any[], param1: number): any[];
                getThreadInfo(param0: number, param1: number): java.lang.management.ThreadInfo;
                getThreadInfo(param0: number): java.lang.management.ThreadInfo;
                getThreadInfo(param0: any[]): any[];
                isThreadContentionMonitoringSupported(): boolean;
                isThreadContentionMonitoringEnabled(): boolean;
                setThreadContentionMonitoringEnabled(param0: boolean);
                getCurrentThreadCpuTime(): number;
                getCurrentThreadUserTime(): number;
                getThreadCpuTime(param0: number): number;
                getThreadUserTime(param0: number): number;
                isThreadCpuTimeSupported(): boolean;
                isCurrentThreadCpuTimeSupported(): boolean;
                isThreadCpuTimeEnabled(): boolean;
                setThreadCpuTimeEnabled(param0: boolean);
                findMonitorDeadlockedThreads(): any[];
                resetPeakThreadCount();
                findDeadlockedThreads(): any[];
                isObjectMonitorUsageSupported(): boolean;
                isSynchronizerUsageSupported(): boolean;
                dumpAllThreads(param0: boolean, param1: boolean): any[];
                getObjectName(): javax.management.ObjectName;
            }
        }
        namespace ref{
            class Finalizer$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Finalizer$2{
                run();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Finalizer$3{
                run();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FinalizerHistogram$Entry{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FinalizerHistogram{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Reference$1{
                tryHandlePendingReference(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferenceQueue$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class WeakReference{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SoftReference{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferenceQueue$Null{
                remove(param0: number): java.lang.ref.Reference;
                remove(): java.lang.ref.Reference;
                poll(): java.lang.ref.Reference;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferenceQueue$Lock{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferenceQueue{
                remove(param0: number): java.lang.ref.Reference;
                remove(): java.lang.ref.Reference;
                poll(): java.lang.ref.Reference;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Reference$ReferenceHandler{
                run();
                toString(): string;
                isInterrupted(): boolean;
                static currentThread(): java.lang.Thread;
                getName(): string;
                join(param0: number);
                join(param0: number, param1: number);
                join();
                getThreadGroup(): java.lang.ThreadGroup;
                getStackTrace(): any[];
                static holdsLock(param0: any): boolean;
                checkAccess();
                static dumpStack();
                static yield();
                setPriority(param0: number);
                setDaemon(param0: boolean);
                start();
                static sleep(param0: number, param1: number);
                static sleep(param0: number);
                stop();
                stop(param0: java.lang.Throwable);
                interrupt();
                static interrupted(): boolean;
                destroy();
                isAlive(): boolean;
                suspend();
                resume();
                getPriority(): number;
                setName(param0: string);
                static activeCount(): number;
                static enumerate(param0: any[]): number;
                countStackFrames(): number;
                isDaemon(): boolean;
                getContextClassLoader(): java.lang.ClassLoader;
                setContextClassLoader(param0: java.lang.ClassLoader);
                static getAllStackTraces(): java.util.Map;
                getId(): number;
                getState(): java.lang.Thread$State;
                static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Reference$Lock{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Reference{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PhantomReference{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Finalizer$FinalizerThread{
                run();
                toString(): string;
                isInterrupted(): boolean;
                static currentThread(): java.lang.Thread;
                getName(): string;
                join(param0: number);
                join(param0: number, param1: number);
                join();
                getThreadGroup(): java.lang.ThreadGroup;
                getStackTrace(): any[];
                static holdsLock(param0: any): boolean;
                checkAccess();
                static dumpStack();
                static yield();
                setPriority(param0: number);
                setDaemon(param0: boolean);
                start();
                static sleep(param0: number, param1: number);
                static sleep(param0: number);
                stop();
                stop(param0: java.lang.Throwable);
                interrupt();
                static interrupted(): boolean;
                destroy();
                isAlive(): boolean;
                suspend();
                resume();
                getPriority(): number;
                setName(param0: string);
                static activeCount(): number;
                static enumerate(param0: any[]): number;
                countStackFrames(): number;
                isDaemon(): boolean;
                getContextClassLoader(): java.lang.ClassLoader;
                setContextClassLoader(param0: java.lang.ClassLoader);
                static getAllStackTraces(): java.util.Map;
                getId(): number;
                getState(): java.lang.Thread$State;
                static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Finalizer{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FinalReference{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        namespace reflect{
            class AnnotatedArrayType{
                getAnnotatedGenericComponentType(): java.lang.reflect.AnnotatedType;
                getType(): java.lang.reflect.Type;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
            }
            class AnnotatedParameterizedType{
                getAnnotatedActualTypeArguments(): any[];
                getType(): java.lang.reflect.Type;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
            }
            class AnnotatedType{
                getType(): java.lang.reflect.Type;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
            }
            class AnnotatedTypeVariable{
                getAnnotatedBounds(): any[];
                getType(): java.lang.reflect.Type;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
            }
            class AnnotatedWildcardType{
                getAnnotatedLowerBounds(): any[];
                getAnnotatedUpperBounds(): any[];
                getType(): java.lang.reflect.Type;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
            }
            class GenericArrayType{
                getGenericComponentType(): java.lang.reflect.Type;
                getTypeName(): string;
            }
            class GenericSignatureFormatError{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MalformedParameterizedTypeException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MalformedParametersException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ParameterizedType{
                getRawType(): java.lang.reflect.Type;
                getActualTypeArguments(): any[];
                getOwnerType(): java.lang.reflect.Type;
                getTypeName(): string;
            }
            class Proxy$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Proxy$Key1{
                equals(param0: any): boolean;
                hashCode(): number;
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Proxy$Key2{
                equals(param0: any): boolean;
                hashCode(): number;
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Proxy$KeyX{
                equals(param0: any): boolean;
                hashCode(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TypeVariable{
                getName(): string;
                getAnnotatedBounds(): any[];
                getBounds(): any[];
                getGenericDeclaration(): java.lang.reflect.GenericDeclaration;
                getTypeName(): string;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
            }
            class UndeclaredThrowableException{
                getCause(): java.lang.Throwable;
                getUndeclaredThrowable(): java.lang.Throwable;
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class WeakCache$CacheKey{
                equals(param0: any): boolean;
                hashCode(): number;
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class WeakCache$CacheValue{
                equals(param0: any): boolean;
                hashCode(): number;
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class WeakCache$Factory{
                get(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class WeakCache$LookupValue{
                get(): any;
                equals(param0: any): boolean;
                hashCode(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class WeakCache$Value{
                get(): any;
            }
            class WildcardType{
                getUpperBounds(): any[];
                getLowerBounds(): any[];
                getTypeName(): string;
            }
            class WeakCache{
                get(param0: any, param1: any): any;
                size(): number;
                containsValue(param0: any): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Type{
                getTypeName(): string;
            }
            class ReflectPermission{
                equals(param0: any): boolean;
                hashCode(): number;
                implies(param0: java.security.Permission): boolean;
                getActions(): string;
                newPermissionCollection(): java.security.PermissionCollection;
                toString(): string;
                getName(): string;
                checkGuard(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReflectAccess{
                newConstructor(param0: java.lang.Class, param1: any[], param2: any[], param3: number, param4: number, param5: string, param6: any[], param7: any[]): java.lang.reflect.Constructor;
                newField(param0: java.lang.Class, param1: string, param2: java.lang.Class, param3: number, param4: number, param5: string, param6: any[]): java.lang.reflect.Field;
                newMethod(param0: java.lang.Class, param1: string, param2: any[], param3: java.lang.Class, param4: any[], param5: number, param6: number, param7: string, param8: any[], param9: any[], param10: any[]): java.lang.reflect.Method;
                getExecutableTypeAnnotationBytes(param0: java.lang.reflect.Executable): any[];
                copyField(param0: java.lang.reflect.Field): java.lang.reflect.Field;
                copyMethod(param0: java.lang.reflect.Method): java.lang.reflect.Method;
                copyConstructor(param0: java.lang.reflect.Constructor): java.lang.reflect.Constructor;
                getMethodAccessor(param0: java.lang.reflect.Method): sun.reflect.MethodAccessor;
                setMethodAccessor(param0: java.lang.reflect.Method, param1: sun.reflect.MethodAccessor);
                getConstructorAccessor(param0: java.lang.reflect.Constructor): sun.reflect.ConstructorAccessor;
                setConstructorAccessor(param0: java.lang.reflect.Constructor, param1: sun.reflect.ConstructorAccessor);
                getConstructorSlot(param0: java.lang.reflect.Constructor): number;
                getConstructorSignature(param0: java.lang.reflect.Constructor): string;
                getConstructorAnnotations(param0: java.lang.reflect.Constructor): any[];
                getConstructorParameterAnnotations(param0: java.lang.reflect.Constructor): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Proxy$ProxyClassFactory{
                apply(param0: java.lang.ClassLoader, param1: any[]): java.lang.Class;
                apply(param0: any, param1: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.Function): java.util.function.BiFunction;
            }
            class Proxy$KeyFactory{
                apply(param0: java.lang.ClassLoader, param1: any[]): any;
                apply(param0: any, param1: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.Function): java.util.function.BiFunction;
            }
            class Proxy{
                static isProxyClass(param0: java.lang.Class): boolean;
                static newProxyInstance(param0: java.lang.ClassLoader, param1: any[], param2: java.lang.reflect.InvocationHandler): any;
                static getProxyClass(param0: java.lang.ClassLoader, param1: any[]): java.lang.Class;
                static getInvocationHandler(param0: any): java.lang.reflect.InvocationHandler;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Parameter{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getModifiers(): number;
                getName(): string;
                isSynthetic(): boolean;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
                getType(): java.lang.Class;
                getAnnotatedType(): java.lang.reflect.AnnotatedType;
                isNamePresent(): boolean;
                getDeclaringExecutable(): java.lang.reflect.Executable;
                getParameterizedType(): java.lang.reflect.Type;
                isImplicit(): boolean;
                isVarArgs(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                isAnnotationPresent(param0: java.lang.Class): boolean;
            }
            class Modifier{
                static toString(param0: number): string;
                static isInterface(param0: number): boolean;
                static classModifiers(): number;
                static isAbstract(param0: number): boolean;
                static isStatic(param0: number): boolean;
                static isProtected(param0: number): boolean;
                static methodModifiers(): number;
                static constructorModifiers(): number;
                static isFinal(param0: number): boolean;
                static isPublic(param0: number): boolean;
                static isVolatile(param0: number): boolean;
                static isPrivate(param0: number): boolean;
                static isNative(param0: number): boolean;
                static isSynchronized(param0: number): boolean;
                static isTransient(param0: number): boolean;
                static isStrict(param0: number): boolean;
                static interfaceModifiers(): number;
                static fieldModifiers(): number;
                static parameterModifiers(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Method{
                invoke(param0: any, param1: any[]): any;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getModifiers(): number;
                getName(): string;
                toGenericString(): string;
                isSynthetic(): boolean;
                getTypeParameters(): any[];
                getDeclaringClass(): java.lang.Class;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotations(): any[];
                getReturnType(): java.lang.Class;
                getParameterTypes(): any[];
                isDefault(): boolean;
                isVarArgs(): boolean;
                getParameterCount(): number;
                getParameterAnnotations(): any[];
                getGenericReturnType(): java.lang.reflect.Type;
                getGenericParameterTypes(): any[];
                getExceptionTypes(): any[];
                getGenericExceptionTypes(): any[];
                isBridge(): boolean;
                getDefaultValue(): any;
                getAnnotatedReturnType(): java.lang.reflect.AnnotatedType;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotatedParameterTypes(): any[];
                getParameters(): any[];
                getAnnotatedReceiverType(): java.lang.reflect.AnnotatedType;
                getAnnotatedExceptionTypes(): any[];
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                static setAccessible(param0: any[], param1: boolean);
                setAccessible(param0: boolean);
                isAccessible(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Member{
                getModifiers(): number;
                getName(): string;
                isSynthetic(): boolean;
                getDeclaringClass(): java.lang.Class;
            }
            class InvocationTargetException{
                getCause(): java.lang.Throwable;
                getTargetException(): java.lang.Throwable;
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InvocationHandler{
                invoke(param0: any, param1: java.lang.reflect.Method, param2: any[]): any;
            }
            class GenericDeclaration{
                getTypeParameters(): any[];
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
            }
            class Field{
                get(param0: any): any;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getModifiers(): number;
                getBoolean(param0: any): boolean;
                getByte(param0: any): number;
                getShort(param0: any): number;
                getChar(param0: any): string;
                getInt(param0: any): number;
                getLong(param0: any): number;
                getFloat(param0: any): number;
                getDouble(param0: any): number;
                getName(): string;
                toGenericString(): string;
                isSynthetic(): boolean;
                getDeclaringClass(): java.lang.Class;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
                isEnumConstant(): boolean;
                getType(): java.lang.Class;
                getGenericType(): java.lang.reflect.Type;
                set(param0: any, param1: any);
                setBoolean(param0: any, param1: boolean);
                setByte(param0: any, param1: number);
                setChar(param0: any, param1: string);
                setShort(param0: any, param1: number);
                setInt(param0: any, param1: number);
                setLong(param0: any, param1: number);
                setFloat(param0: any, param1: number);
                setDouble(param0: any, param1: number);
                getAnnotatedType(): java.lang.reflect.AnnotatedType;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                static setAccessible(param0: any[], param1: boolean);
                setAccessible(param0: boolean);
                isAccessible(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executable{
                getModifiers(): number;
                getName(): string;
                toGenericString(): string;
                isSynthetic(): boolean;
                getTypeParameters(): any[];
                getDeclaringClass(): java.lang.Class;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
                getParameterTypes(): any[];
                isVarArgs(): boolean;
                getAnnotatedParameterTypes(): any[];
                getParameterCount(): number;
                getParameterAnnotations(): any[];
                getGenericParameterTypes(): any[];
                getExceptionTypes(): any[];
                getGenericExceptionTypes(): any[];
                getAnnotatedReturnType(): java.lang.reflect.AnnotatedType;
                getParameters(): any[];
                getAnnotatedReceiverType(): java.lang.reflect.AnnotatedType;
                getAnnotatedExceptionTypes(): any[];
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                static setAccessible(param0: any[], param1: boolean);
                setAccessible(param0: boolean);
                isAccessible(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Constructor{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getModifiers(): number;
                getName(): string;
                toGenericString(): string;
                newInstance(param0: any[]): any;
                isSynthetic(): boolean;
                getTypeParameters(): any[];
                getDeclaringClass(): java.lang.Class;
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotations(): any[];
                getParameterTypes(): any[];
                isVarArgs(): boolean;
                getParameterCount(): number;
                getParameterAnnotations(): any[];
                getGenericParameterTypes(): any[];
                getExceptionTypes(): any[];
                getGenericExceptionTypes(): any[];
                getAnnotatedReturnType(): java.lang.reflect.AnnotatedType;
                getAnnotatedReceiverType(): java.lang.reflect.AnnotatedType;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotatedParameterTypes(): any[];
                getParameters(): any[];
                getAnnotatedExceptionTypes(): any[];
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                static setAccessible(param0: any[], param1: boolean);
                setAccessible(param0: boolean);
                isAccessible(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Array{
                static get(param0: any, param1: number): any;
                static getLength(param0: any): number;
                static getBoolean(param0: any, param1: number): boolean;
                static getByte(param0: any, param1: number): number;
                static getShort(param0: any, param1: number): number;
                static getChar(param0: any, param1: number): string;
                static getInt(param0: any, param1: number): number;
                static getLong(param0: any, param1: number): number;
                static getFloat(param0: any, param1: number): number;
                static getDouble(param0: any, param1: number): number;
                static newInstance(param0: java.lang.Class, param1: number): any;
                static newInstance(param0: java.lang.Class, param1: any[]): any;
                static set(param0: any, param1: number, param2: any);
                static setBoolean(param0: any, param1: number, param2: boolean);
                static setByte(param0: any, param1: number, param2: number);
                static setChar(param0: any, param1: number, param2: string);
                static setShort(param0: any, param1: number, param2: number);
                static setInt(param0: any, param1: number, param2: number);
                static setLong(param0: any, param1: number, param2: number);
                static setFloat(param0: any, param1: number, param2: number);
                static setDouble(param0: any, param1: number, param2: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class AnnotatedElement{
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
            }
            class AccessibleObject{
                getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                isAnnotationPresent(param0: java.lang.Class): boolean;
                getAnnotationsByType(param0: java.lang.Class): any[];
                getAnnotations(): any[];
                getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
                getDeclaredAnnotations(): any[];
                static setAccessible(param0: any[], param1: boolean);
                setAccessible(param0: boolean);
                isAccessible(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        class Void{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class VirtualMachineError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UnsupportedOperationException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UnsatisfiedLinkError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UNIXProcess$ProcessPipeOutputStream{
            write(param0: number);
            write(param0: any[], param1: number, param2: number);
            flush();
            write(param0: any[]);
            close();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UNIXProcess$ProcessPipeInputStream{
            close();
            read(param0: any[], param1: number, param2: number): number;
            read(): number;
            mark(param0: number);
            skip(param0: number): number;
            available(): number;
            markSupported(): boolean;
            reset();
            read(param0: any[]): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UNIXProcess$LaunchMechanism{
            static values(): any[];
            static valueOf(param0: string): java.lang.UNIXProcess$LaunchMechanism;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UNIXProcess$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UNIXProcess{
            destroy();
            isAlive(): boolean;
            getInputStream(): java.io.InputStream;
            getOutputStream(): java.io.OutputStream;
            getErrorStream(): java.io.InputStream;
            waitFor(): number;
            waitFor(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
            exitValue(): number;
            destroyForcibly(): java.lang.Process;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Throwable$WrappedPrintWriter{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Throwable$WrappedPrintStream{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Throwable$PrintStreamOrWriter{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Throwable{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ThreadLocal$ThreadLocalMap$Entry{
            get(): any;
            clear();
            isEnqueued(): boolean;
            enqueue(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ThreadLocal$ThreadLocalMap{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ThreadLocal{
            remove();
            get(): any;
            set(param0: any);
            static withInitial(param0: java.util.function.Supplier): java.lang.ThreadLocal;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ThreadGroup{
            uncaughtException(param0: java.lang.Thread, param1: java.lang.Throwable);
            toString(): string;
            getName(): string;
            getParent(): java.lang.ThreadGroup;
            checkAccess();
            setDaemon(param0: boolean);
            stop();
            interrupt();
            destroy();
            suspend();
            resume();
            activeCount(): number;
            enumerate(param0: any[], param1: boolean): number;
            enumerate(param0: any[], param1: boolean): number;
            enumerate(param0: any[]): number;
            enumerate(param0: any[]): number;
            isDaemon(): boolean;
            getMaxPriority(): number;
            isDestroyed(): boolean;
            setMaxPriority(param0: number);
            parentOf(param0: java.lang.ThreadGroup): boolean;
            activeGroupCount(): number;
            list();
            allowThreadSuspension(param0: boolean): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ThreadDeath{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Thread$UncaughtExceptionHandler{
            uncaughtException(param0: java.lang.Thread, param1: java.lang.Throwable);
        }
        class Thread{
            run();
            toString(): string;
            isInterrupted(): boolean;
            static currentThread(): java.lang.Thread;
            getName(): string;
            join(param0: number);
            join(param0: number, param1: number);
            join();
            getThreadGroup(): java.lang.ThreadGroup;
            getStackTrace(): any[];
            static holdsLock(param0: any): boolean;
            checkAccess();
            static dumpStack();
            static yield();
            setPriority(param0: number);
            setDaemon(param0: boolean);
            start();
            static sleep(param0: number, param1: number);
            static sleep(param0: number);
            stop();
            stop(param0: java.lang.Throwable);
            interrupt();
            static interrupted(): boolean;
            destroy();
            isAlive(): boolean;
            suspend();
            resume();
            getPriority(): number;
            setName(param0: string);
            static activeCount(): number;
            static enumerate(param0: any[]): number;
            countStackFrames(): number;
            isDaemon(): boolean;
            getContextClassLoader(): java.lang.ClassLoader;
            setContextClassLoader(param0: java.lang.ClassLoader);
            static getAllStackTraces(): java.util.Map;
            getId(): number;
            getState(): java.lang.Thread$State;
            static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
            static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
            getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
            setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Terminator$1{
            handle(param0: sun.misc.Signal);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Terminator{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SystemClassLoaderAction{
            run(): java.lang.ClassLoader;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class System$2{
            getConstantPool(param0: java.lang.Class): sun.reflect.ConstantPool;
            getEnumConstantsShared(param0: java.lang.Class): any[];
            casAnnotationType(param0: java.lang.Class, param1: sun.reflect.annotation.AnnotationType, param2: sun.reflect.annotation.AnnotationType): boolean;
            getAnnotationType(param0: java.lang.Class): sun.reflect.annotation.AnnotationType;
            getDeclaredAnnotationMap(param0: java.lang.Class): java.util.Map;
            getStackTraceDepth(param0: java.lang.Throwable): number;
            getStackTraceElement(param0: java.lang.Throwable, param1: number): java.lang.StackTraceElement;
            invokeFinalize(param0: any);
            blockedOn(param0: java.lang.Thread, param1: sun.nio.ch.Interruptible);
            getRawClassAnnotations(param0: java.lang.Class): any[];
            getRawClassTypeAnnotations(param0: java.lang.Class): any[];
            getRawExecutableTypeAnnotations(param0: java.lang.reflect.Executable): any[];
            registerShutdownHook(param0: number, param1: boolean, param2: java.lang.Runnable);
            newStringUnsafe(param0: any[]): string;
            newThreadWithAcc(param0: java.lang.Runnable, param1: java.security.AccessControlContext): java.lang.Thread;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class System{
            static exit(param0: number);
            static runFinalization();
            static runFinalizersOnExit(param0: boolean);
            static setProperty(param0: string, param1: string): string;
            static getProperty(param0: string): string;
            static getProperty(param0: string, param1: string): string;
            static identityHashCode(param0: any): number;
            static currentTimeMillis(): number;
            static nanoTime(): number;
            static arraycopy(param0: any, param1: number, param2: any, param3: number, param4: number);
            static getSecurityManager(): java.lang.SecurityManager;
            static loadLibrary(param0: string);
            static mapLibraryName(param0: string): string;
            static load(param0: string);
            static lineSeparator(): string;
            static setIn(param0: java.io.InputStream);
            static setOut(param0: java.io.PrintStream);
            static setErr(param0: java.io.PrintStream);
            static console(): java.io.Console;
            static inheritedChannel(): java.nio.channels.Channel;
            static setSecurityManager(param0: java.lang.SecurityManager);
            static getProperties(): java.util.Properties;
            static setProperties(param0: java.util.Properties);
            static clearProperty(param0: string): string;
            static getenv(param0: string): string;
            static getenv(): java.util.Map;
            static gc();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StringIndexOutOfBoundsException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StringCoding$StringEncoder{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StringCoding$StringDecoder{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StringCoding{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StringBuilder{
            toString(): string;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: string): java.lang.AbstractStringBuilder;
            append(param0: boolean): java.lang.AbstractStringBuilder;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.AbstractStringBuilder;
            append(param0: java.lang.CharSequence): java.lang.Appendable;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: java.lang.StringBuffer): java.lang.AbstractStringBuilder;
            append(param0: string): java.lang.AbstractStringBuilder;
            append(param0: any): java.lang.AbstractStringBuilder;
            append(param0: string): java.lang.Appendable;
            append(param0: any[], param1: number, param2: number): java.lang.AbstractStringBuilder;
            append(param0: any[]): java.lang.AbstractStringBuilder;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.Appendable;
            append(param0: java.lang.CharSequence): java.lang.AbstractStringBuilder;
            append(param0: boolean): java.lang.StringBuilder;
            append(param0: java.lang.CharSequence): java.lang.StringBuilder;
            append(param0: string): java.lang.StringBuilder;
            append(param0: number): java.lang.StringBuilder;
            append(param0: java.lang.StringBuffer): java.lang.StringBuilder;
            append(param0: any[]): java.lang.StringBuilder;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.StringBuilder;
            append(param0: number): java.lang.StringBuilder;
            append(param0: any[], param1: number, param2: number): java.lang.StringBuilder;
            append(param0: string): java.lang.StringBuilder;
            append(param0: any): java.lang.StringBuilder;
            append(param0: number): java.lang.StringBuilder;
            append(param0: number): java.lang.StringBuilder;
            indexOf(param0: string, param1: number): number;
            indexOf(param0: string): number;
            length(): number;
            charAt(param0: number): string;
            codePointAt(param0: number): number;
            codePointBefore(param0: number): number;
            codePointCount(param0: number, param1: number): number;
            offsetByCodePoints(param0: number, param1: number): number;
            getChars(param0: number, param1: number, param2: any[], param3: number);
            lastIndexOf(param0: string, param1: number): number;
            lastIndexOf(param0: string): number;
            substring(param0: number): string;
            substring(param0: number, param1: number): string;
            subSequence(param0: number, param1: number): java.lang.CharSequence;
            replace(param0: number, param1: number, param2: string): java.lang.AbstractStringBuilder;
            replace(param0: number, param1: number, param2: string): java.lang.StringBuilder;
            delete(param0: number, param1: number): java.lang.AbstractStringBuilder;
            delete(param0: number, param1: number): java.lang.StringBuilder;
            insert(param0: number, param1: any[], param2: number, param3: number): java.lang.StringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.StringBuilder;
            insert(param0: number, param1: number): java.lang.StringBuilder;
            insert(param0: number, param1: number): java.lang.StringBuilder;
            insert(param0: number, param1: number): java.lang.StringBuilder;
            insert(param0: number, param1: any): java.lang.StringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: string): java.lang.StringBuilder;
            insert(param0: number, param1: any[]): java.lang.StringBuilder;
            insert(param0: number, param1: java.lang.CharSequence): java.lang.StringBuilder;
            insert(param0: number, param1: java.lang.CharSequence, param2: number, param3: number): java.lang.StringBuilder;
            insert(param0: number, param1: boolean): java.lang.StringBuilder;
            insert(param0: number, param1: string): java.lang.StringBuilder;
            insert(param0: number, param1: boolean): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: java.lang.CharSequence, param2: number, param3: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: java.lang.CharSequence): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: any[]): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: any): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: string): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: any[], param2: number, param3: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: string): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            capacity(): number;
            ensureCapacity(param0: number);
            trimToSize();
            setLength(param0: number);
            setCharAt(param0: number, param1: string);
            appendCodePoint(param0: number): java.lang.AbstractStringBuilder;
            appendCodePoint(param0: number): java.lang.StringBuilder;
            deleteCharAt(param0: number): java.lang.AbstractStringBuilder;
            deleteCharAt(param0: number): java.lang.StringBuilder;
            reverse(): java.lang.AbstractStringBuilder;
            reverse(): java.lang.StringBuilder;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            chars(): java.util.stream.IntStream;
            codePoints(): java.util.stream.IntStream;
        }
        class StringBuffer{
            toString(): string;
            append(param0: number): java.lang.StringBuffer;
            append(param0: number): java.lang.StringBuffer;
            append(param0: java.lang.CharSequence): java.lang.AbstractStringBuilder;
            append(param0: boolean): java.lang.StringBuffer;
            append(param0: string): java.lang.StringBuffer;
            append(param0: number): java.lang.StringBuffer;
            append(param0: java.lang.StringBuffer): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.StringBuffer;
            append(param0: string): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.AbstractStringBuilder;
            append(param0: any[]): java.lang.AbstractStringBuilder;
            append(param0: any[], param1: number, param2: number): java.lang.AbstractStringBuilder;
            append(param0: boolean): java.lang.AbstractStringBuilder;
            append(param0: java.lang.CharSequence): java.lang.Appendable;
            append(param0: string): java.lang.AbstractStringBuilder;
            append(param0: any): java.lang.StringBuffer;
            append(param0: string): java.lang.StringBuffer;
            append(param0: any): java.lang.AbstractStringBuilder;
            append(param0: string): java.lang.Appendable;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.Appendable;
            append(param0: java.lang.CharSequence): java.lang.StringBuffer;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.StringBuffer;
            append(param0: any[]): java.lang.StringBuffer;
            append(param0: java.lang.StringBuffer): java.lang.StringBuffer;
            append(param0: any[], param1: number, param2: number): java.lang.StringBuffer;
            indexOf(param0: string): number;
            indexOf(param0: string, param1: number): number;
            length(): number;
            charAt(param0: number): string;
            codePointAt(param0: number): number;
            codePointBefore(param0: number): number;
            codePointCount(param0: number, param1: number): number;
            offsetByCodePoints(param0: number, param1: number): number;
            getChars(param0: number, param1: number, param2: any[], param3: number);
            lastIndexOf(param0: string, param1: number): number;
            lastIndexOf(param0: string): number;
            substring(param0: number): string;
            substring(param0: number, param1: number): string;
            subSequence(param0: number, param1: number): java.lang.CharSequence;
            replace(param0: number, param1: number, param2: string): java.lang.AbstractStringBuilder;
            replace(param0: number, param1: number, param2: string): java.lang.StringBuffer;
            delete(param0: number, param1: number): java.lang.AbstractStringBuilder;
            delete(param0: number, param1: number): java.lang.StringBuffer;
            insert(param0: number, param1: any[]): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: java.lang.CharSequence): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: java.lang.CharSequence, param2: number, param3: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: boolean): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: string): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: any): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: any[], param2: number, param3: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: java.lang.CharSequence): java.lang.StringBuffer;
            insert(param0: number, param1: java.lang.CharSequence, param2: number, param3: number): java.lang.StringBuffer;
            insert(param0: number, param1: boolean): java.lang.StringBuffer;
            insert(param0: number, param1: string): java.lang.StringBuffer;
            insert(param0: number, param1: number): java.lang.StringBuffer;
            insert(param0: number, param1: number): java.lang.StringBuffer;
            insert(param0: number, param1: number): java.lang.StringBuffer;
            insert(param0: number, param1: any[], param2: number, param3: number): java.lang.StringBuffer;
            insert(param0: number, param1: any): java.lang.StringBuffer;
            insert(param0: number, param1: string): java.lang.StringBuffer;
            insert(param0: number, param1: any[]): java.lang.StringBuffer;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: string): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.StringBuffer;
            capacity(): number;
            ensureCapacity(param0: number);
            trimToSize();
            setLength(param0: number);
            setCharAt(param0: number, param1: string);
            appendCodePoint(param0: number): java.lang.StringBuffer;
            appendCodePoint(param0: number): java.lang.AbstractStringBuilder;
            deleteCharAt(param0: number): java.lang.AbstractStringBuilder;
            deleteCharAt(param0: number): java.lang.StringBuffer;
            reverse(): java.lang.StringBuffer;
            reverse(): java.lang.AbstractStringBuilder;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            chars(): java.util.stream.IntStream;
            codePoints(): java.util.stream.IntStream;
        }
        class String$CaseInsensitiveComparator{
            compare(param0: any, param1: any): number;
            compare(param0: string, param1: string): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            reversed(): java.util.Comparator;
            thenComparing(param0: java.util.function.Function): java.util.Comparator;
            thenComparing(param0: java.util.function.Function, param1: java.util.Comparator): java.util.Comparator;
            thenComparing(param0: java.util.Comparator): java.util.Comparator;
            thenComparingInt(param0: java.util.function.ToIntFunction): java.util.Comparator;
            thenComparingLong(param0: java.util.function.ToLongFunction): java.util.Comparator;
            thenComparingDouble(param0: java.util.function.ToDoubleFunction): java.util.Comparator;
        }
        class String{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: string): number;
            indexOf(param0: string, param1: number): number;
            indexOf(param0: number): number;
            indexOf(param0: string): number;
            indexOf(param0: number, param1: number): number;
            static valueOf(param0: string): string;
            static valueOf(param0: any): string;
            static valueOf(param0: boolean): string;
            static valueOf(param0: any[], param1: number, param2: number): string;
            static valueOf(param0: any[]): string;
            static valueOf(param0: number): string;
            static valueOf(param0: number): string;
            static valueOf(param0: number): string;
            static valueOf(param0: number): string;
            length(): number;
            isEmpty(): boolean;
            charAt(param0: number): string;
            codePointAt(param0: number): number;
            codePointBefore(param0: number): number;
            codePointCount(param0: number, param1: number): number;
            offsetByCodePoints(param0: number, param1: number): number;
            getChars(param0: number, param1: number, param2: any[], param3: number);
            getBytes(): any[];
            getBytes(param0: string): any[];
            getBytes(param0: number, param1: number, param2: any[], param3: number);
            getBytes(param0: java.nio.charset.Charset): any[];
            contentEquals(param0: java.lang.StringBuffer): boolean;
            contentEquals(param0: java.lang.CharSequence): boolean;
            equalsIgnoreCase(param0: string): boolean;
            compareToIgnoreCase(param0: string): number;
            regionMatches(param0: number, param1: string, param2: number, param3: number): boolean;
            regionMatches(param0: boolean, param1: number, param2: string, param3: number, param4: number): boolean;
            startsWith(param0: string): boolean;
            startsWith(param0: string, param1: number): boolean;
            endsWith(param0: string): boolean;
            lastIndexOf(param0: number, param1: number): number;
            lastIndexOf(param0: string, param1: number): number;
            lastIndexOf(param0: number): number;
            lastIndexOf(param0: string): number;
            substring(param0: number): string;
            substring(param0: number, param1: number): string;
            subSequence(param0: number, param1: number): java.lang.CharSequence;
            concat(param0: string): string;
            replace(param0: string, param1: string): string;
            replace(param0: java.lang.CharSequence, param1: java.lang.CharSequence): string;
            matches(param0: string): boolean;
            contains(param0: java.lang.CharSequence): boolean;
            replaceFirst(param0: string, param1: string): string;
            replaceAll(param0: string, param1: string): string;
            split(param0: string, param1: number): any[];
            split(param0: string): any[];
            static join(param0: java.lang.CharSequence, param1: any[]): string;
            static join(param0: java.lang.CharSequence, param1: java.lang.Iterable): string;
            toLowerCase(param0: java.util.Locale): string;
            toLowerCase(): string;
            toUpperCase(): string;
            toUpperCase(param0: java.util.Locale): string;
            trim(): string;
            toCharArray(): any[];
            static format(param0: java.util.Locale, param1: string, param2: any[]): string;
            static format(param0: string, param1: any[]): string;
            static copyValueOf(param0: any[], param1: number, param2: number): string;
            static copyValueOf(param0: any[]): string;
            intern(): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            chars(): java.util.stream.IntStream;
            codePoints(): java.util.stream.IntStream;
        }
        class StrictMath{
            static abs(param0: number): number;
            static abs(param0: number): number;
            static abs(param0: number): number;
            static abs(param0: number): number;
            static sin(param0: number): number;
            static cos(param0: number): number;
            static tan(param0: number): number;
            static atan2(param0: number, param1: number): number;
            static sqrt(param0: number): number;
            static log(param0: number): number;
            static log10(param0: number): number;
            static pow(param0: number, param1: number): number;
            static exp(param0: number): number;
            static min(param0: number, param1: number): number;
            static min(param0: number, param1: number): number;
            static min(param0: number, param1: number): number;
            static min(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static addExact(param0: number, param1: number): number;
            static addExact(param0: number, param1: number): number;
            static multiplyExact(param0: number, param1: number): number;
            static multiplyExact(param0: number, param1: number): number;
            static subtractExact(param0: number, param1: number): number;
            static subtractExact(param0: number, param1: number): number;
            static scalb(param0: number, param1: number): number;
            static scalb(param0: number, param1: number): number;
            static copySign(param0: number, param1: number): number;
            static copySign(param0: number, param1: number): number;
            static getExponent(param0: number): number;
            static getExponent(param0: number): number;
            static signum(param0: number): number;
            static signum(param0: number): number;
            static asin(param0: number): number;
            static acos(param0: number): number;
            static atan(param0: number): number;
            static toRadians(param0: number): number;
            static toDegrees(param0: number): number;
            static cbrt(param0: number): number;
            static IEEEremainder(param0: number, param1: number): number;
            static ceil(param0: number): number;
            static floor(param0: number): number;
            static rint(param0: number): number;
            static round(param0: number): number;
            static round(param0: number): number;
            static random(): number;
            static toIntExact(param0: number): number;
            static floorDiv(param0: number, param1: number): number;
            static floorDiv(param0: number, param1: number): number;
            static floorMod(param0: number, param1: number): number;
            static floorMod(param0: number, param1: number): number;
            static ulp(param0: number): number;
            static ulp(param0: number): number;
            static sinh(param0: number): number;
            static cosh(param0: number): number;
            static tanh(param0: number): number;
            static hypot(param0: number, param1: number): number;
            static expm1(param0: number): number;
            static log1p(param0: number): number;
            static nextAfter(param0: number, param1: number): number;
            static nextAfter(param0: number, param1: number): number;
            static nextUp(param0: number): number;
            static nextUp(param0: number): number;
            static nextDown(param0: number): number;
            static nextDown(param0: number): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StackTraceElement{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getFileName(): string;
            getLineNumber(): number;
            getClassName(): string;
            getMethodName(): string;
            isNativeMethod(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StackOverflowError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Shutdown$Lock{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Shutdown{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Short$ShortCache{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Short{
            equals(param0: any): boolean;
            toString(): string;
            static toString(param0: number): string;
            hashCode(): number;
            static hashCode(param0: number): number;
            static reverseBytes(param0: number): number;
            compareTo(param0: number): number;
            compareTo(param0: any): number;
            byteValue(): number;
            shortValue(): number;
            intValue(): number;
            longValue(): number;
            floatValue(): number;
            doubleValue(): number;
            static valueOf(param0: string, param1: number): number;
            static valueOf(param0: number): number;
            static valueOf(param0: string): number;
            static decode(param0: string): number;
            static compare(param0: number, param1: number): number;
            static toUnsignedInt(param0: number): number;
            static toUnsignedLong(param0: number): number;
            static parseShort(param0: string, param1: number): number;
            static parseShort(param0: string): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SecurityManager{
            checkPackageAccess(param0: string);
            checkMemberAccess(param0: java.lang.Class, param1: number);
            checkPermission(param0: java.security.Permission);
            checkPermission(param0: java.security.Permission, param1: any);
            checkCreateClassLoader();
            checkPropertiesAccess();
            checkPropertyAccess(param0: string);
            getThreadGroup(): java.lang.ThreadGroup;
            getInCheck(): boolean;
            getSecurityContext(): any;
            checkAccess(param0: java.lang.Thread);
            checkAccess(param0: java.lang.ThreadGroup);
            checkExit(param0: number);
            checkExec(param0: string);
            checkLink(param0: string);
            checkRead(param0: string, param1: any);
            checkRead(param0: java.io.FileDescriptor);
            checkRead(param0: string);
            checkWrite(param0: string);
            checkWrite(param0: java.io.FileDescriptor);
            checkDelete(param0: string);
            checkConnect(param0: string, param1: number, param2: any);
            checkConnect(param0: string, param1: number);
            checkListen(param0: number);
            checkAccept(param0: string, param1: number);
            checkMulticast(param0: java.net.InetAddress, param1: number);
            checkMulticast(param0: java.net.InetAddress);
            checkTopLevelWindow(param0: any): boolean;
            checkPrintJobAccess();
            checkSystemClipboardAccess();
            checkAwtEventQueueAccess();
            checkPackageDefinition(param0: string);
            checkSetFactory();
            checkSecurityAccess(param0: string);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SecurityException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class RuntimePermission{
            equals(param0: any): boolean;
            hashCode(): number;
            implies(param0: java.security.Permission): boolean;
            getActions(): string;
            newPermissionCollection(): java.security.PermissionCollection;
            toString(): string;
            getName(): string;
            checkGuard(param0: any);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class RuntimeException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Runtime{
            exit(param0: number);
            runFinalization();
            static runFinalizersOnExit(param0: boolean);
            loadLibrary(param0: string);
            load(param0: string);
            gc();
            static getRuntime(): java.lang.Runtime;
            freeMemory(): number;
            maxMemory(): number;
            addShutdownHook(param0: java.lang.Thread);
            removeShutdownHook(param0: java.lang.Thread): boolean;
            halt(param0: number);
            exec(param0: any[]): java.lang.Process;
            exec(param0: string): java.lang.Process;
            exec(param0: any[], param1: any[], param2: java.io.File): java.lang.Process;
            exec(param0: any[], param1: any[]): java.lang.Process;
            exec(param0: string, param1: any[], param2: java.io.File): java.lang.Process;
            exec(param0: string, param1: any[]): java.lang.Process;
            availableProcessors(): number;
            totalMemory(): number;
            traceInstructions(param0: boolean);
            traceMethodCalls(param0: boolean);
            getLocalizedInputStream(param0: java.io.InputStream): java.io.InputStream;
            getLocalizedOutputStream(param0: java.io.OutputStream): java.io.OutputStream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Runnable{
            run();
        }
        class ReflectiveOperationException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Readable{
            read(param0: java.nio.CharBuffer): number;
        }
        class ProcessImpl{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessEnvironment$Variable{
            equals(param0: any): boolean;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.ProcessEnvironment$Variable): number;
            static valueOf(param0: any[]): java.lang.ProcessEnvironment$Variable;
            static valueOf(param0: string): java.lang.ProcessEnvironment$Variable;
            static valueOfQueryOnly(param0: string): java.lang.ProcessEnvironment$Variable;
            static valueOfQueryOnly(param0: any): java.lang.ProcessEnvironment$Variable;
            toString(): string;
            hashCode(): number;
            getBytes(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessEnvironment$Value{
            equals(param0: any): boolean;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.ProcessEnvironment$Value): number;
            static valueOf(param0: any[]): java.lang.ProcessEnvironment$Value;
            static valueOf(param0: string): java.lang.ProcessEnvironment$Value;
            static valueOfQueryOnly(param0: string): java.lang.ProcessEnvironment$Value;
            static valueOfQueryOnly(param0: any): java.lang.ProcessEnvironment$Value;
            toString(): string;
            hashCode(): number;
            getBytes(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessEnvironment$StringEnvironment{
            remove(param0: any): string;
            remove(param0: any): any;
            get(param0: any): string;
            get(param0: any): any;
            put(param0: string, param1: string): string;
            put(param0: any, param1: any): any;
            values(): java.util.Collection;
            clear();
            isEmpty(): boolean;
            size(): number;
            entrySet(): java.util.Set;
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            toEnvironmentBlock(param0: any[]): any[];
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            putAll(param0: java.util.Map);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class ProcessEnvironment$ExternalData{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getBytes(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessEnvironment{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$NullOutputStream{
            write(param0: number);
            write(param0: any[], param1: number, param2: number);
            write(param0: any[]);
            flush();
            close();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder$NullInputStream{
            read(): number;
            available(): number;
            read(param0: any[], param1: number, param2: number): number;
            read(param0: any[]): number;
            close();
            mark(param0: number);
            skip(param0: number): number;
            markSupported(): boolean;
            reset();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ProcessBuilder{
            start(): java.lang.Process;
            environment(): java.util.Map;
            directory(): java.io.File;
            directory(param0: java.io.File): java.lang.ProcessBuilder;
            command(param0: java.util.List): java.lang.ProcessBuilder;
            command(): java.util.List;
            command(param0: any[]): java.lang.ProcessBuilder;
            redirectErrorStream(): boolean;
            redirectErrorStream(param0: boolean): java.lang.ProcessBuilder;
            redirectInput(): java.lang.ProcessBuilder$Redirect;
            redirectInput(param0: java.io.File): java.lang.ProcessBuilder;
            redirectInput(param0: java.lang.ProcessBuilder$Redirect): java.lang.ProcessBuilder;
            redirectOutput(): java.lang.ProcessBuilder$Redirect;
            redirectOutput(param0: java.lang.ProcessBuilder$Redirect): java.lang.ProcessBuilder;
            redirectOutput(param0: java.io.File): java.lang.ProcessBuilder;
            redirectError(param0: java.io.File): java.lang.ProcessBuilder;
            redirectError(): java.lang.ProcessBuilder$Redirect;
            redirectError(param0: java.lang.ProcessBuilder$Redirect): java.lang.ProcessBuilder;
            inheritIO(): java.lang.ProcessBuilder;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Process{
            destroy();
            isAlive(): boolean;
            getInputStream(): java.io.InputStream;
            getOutputStream(): java.io.OutputStream;
            getErrorStream(): java.io.InputStream;
            waitFor(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
            waitFor(): number;
            exitValue(): number;
            destroyForcibly(): java.lang.Process;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Package{
            toString(): string;
            hashCode(): number;
            getName(): string;
            static getPackage(param0: string): java.lang.Package;
            getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
            isAnnotationPresent(param0: java.lang.Class): boolean;
            getAnnotationsByType(param0: java.lang.Class): any[];
            getAnnotations(): any[];
            getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
            getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
            getDeclaredAnnotations(): any[];
            static getPackages(): any[];
            isSealed(): boolean;
            isSealed(param0: java.net.URL): boolean;
            isCompatibleWith(param0: string): boolean;
            getSpecificationTitle(): string;
            getSpecificationVersion(): string;
            getSpecificationVendor(): string;
            getImplementationTitle(): string;
            getImplementationVersion(): string;
            getImplementationVendor(): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class OutOfMemoryError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Object{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NumberFormatException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Number{
            byteValue(): number;
            shortValue(): number;
            intValue(): number;
            longValue(): number;
            floatValue(): number;
            doubleValue(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NullPointerException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NoSuchMethodException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NoSuchMethodError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NoSuchFieldException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NoClassDefFoundError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Math{
            static abs(param0: number): number;
            static abs(param0: number): number;
            static abs(param0: number): number;
            static abs(param0: number): number;
            static sin(param0: number): number;
            static cos(param0: number): number;
            static tan(param0: number): number;
            static atan2(param0: number, param1: number): number;
            static sqrt(param0: number): number;
            static log(param0: number): number;
            static log10(param0: number): number;
            static pow(param0: number, param1: number): number;
            static exp(param0: number): number;
            static min(param0: number, param1: number): number;
            static min(param0: number, param1: number): number;
            static min(param0: number, param1: number): number;
            static min(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static addExact(param0: number, param1: number): number;
            static addExact(param0: number, param1: number): number;
            static decrementExact(param0: number): number;
            static decrementExact(param0: number): number;
            static incrementExact(param0: number): number;
            static incrementExact(param0: number): number;
            static multiplyExact(param0: number, param1: number): number;
            static multiplyExact(param0: number, param1: number): number;
            static negateExact(param0: number): number;
            static negateExact(param0: number): number;
            static subtractExact(param0: number, param1: number): number;
            static subtractExact(param0: number, param1: number): number;
            static scalb(param0: number, param1: number): number;
            static scalb(param0: number, param1: number): number;
            static copySign(param0: number, param1: number): number;
            static copySign(param0: number, param1: number): number;
            static getExponent(param0: number): number;
            static getExponent(param0: number): number;
            static signum(param0: number): number;
            static signum(param0: number): number;
            static asin(param0: number): number;
            static acos(param0: number): number;
            static atan(param0: number): number;
            static toRadians(param0: number): number;
            static toDegrees(param0: number): number;
            static cbrt(param0: number): number;
            static IEEEremainder(param0: number, param1: number): number;
            static ceil(param0: number): number;
            static floor(param0: number): number;
            static rint(param0: number): number;
            static round(param0: number): number;
            static round(param0: number): number;
            static random(): number;
            static toIntExact(param0: number): number;
            static floorDiv(param0: number, param1: number): number;
            static floorDiv(param0: number, param1: number): number;
            static floorMod(param0: number, param1: number): number;
            static floorMod(param0: number, param1: number): number;
            static ulp(param0: number): number;
            static ulp(param0: number): number;
            static sinh(param0: number): number;
            static cosh(param0: number): number;
            static tanh(param0: number): number;
            static hypot(param0: number, param1: number): number;
            static expm1(param0: number): number;
            static log1p(param0: number): number;
            static nextAfter(param0: number, param1: number): number;
            static nextAfter(param0: number, param1: number): number;
            static nextUp(param0: number): number;
            static nextUp(param0: number): number;
            static nextDown(param0: number): number;
            static nextDown(param0: number): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Long$LongCache{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Long{
            static numberOfLeadingZeros(param0: number): number;
            static numberOfTrailingZeros(param0: number): number;
            static bitCount(param0: number): number;
            equals(param0: any): boolean;
            toString(): string;
            static toString(param0: number, param1: number): string;
            static toString(param0: number): string;
            hashCode(): number;
            static hashCode(param0: number): number;
            static min(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static reverseBytes(param0: number): number;
            compareTo(param0: any): number;
            compareTo(param0: number): number;
            static getLong(param0: string, param1: number): number;
            static getLong(param0: string, param1: number): number;
            static getLong(param0: string): number;
            byteValue(): number;
            shortValue(): number;
            intValue(): number;
            longValue(): number;
            floatValue(): number;
            doubleValue(): number;
            static valueOf(param0: string, param1: number): number;
            static valueOf(param0: number): number;
            static valueOf(param0: string): number;
            static toHexString(param0: number): string;
            static decode(param0: string): number;
            static compare(param0: number, param1: number): number;
            static reverse(param0: number): number;
            static sum(param0: number, param1: number): number;
            static toUnsignedString(param0: number, param1: number): string;
            static toUnsignedString(param0: number): string;
            static toOctalString(param0: number): string;
            static toBinaryString(param0: number): string;
            static compareUnsigned(param0: number, param1: number): number;
            static divideUnsigned(param0: number, param1: number): number;
            static remainderUnsigned(param0: number, param1: number): number;
            static highestOneBit(param0: number): number;
            static lowestOneBit(param0: number): number;
            static rotateLeft(param0: number, param1: number): number;
            static rotateRight(param0: number, param1: number): number;
            static signum(param0: number): number;
            static parseLong(param0: string, param1: number): number;
            static parseLong(param0: string): number;
            static parseUnsignedLong(param0: string, param1: number): number;
            static parseUnsignedLong(param0: string): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class LinkageError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Iterable{
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
        }
        class InterruptedException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class InternalError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Integer$IntegerCache{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Integer{
            static numberOfLeadingZeros(param0: number): number;
            static numberOfTrailingZeros(param0: number): number;
            static bitCount(param0: number): number;
            equals(param0: any): boolean;
            static toString(param0: number, param1: number): string;
            toString(): string;
            static toString(param0: number): string;
            static hashCode(param0: number): number;
            hashCode(): number;
            static min(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static reverseBytes(param0: number): number;
            compareTo(param0: number): number;
            compareTo(param0: any): number;
            byteValue(): number;
            shortValue(): number;
            intValue(): number;
            longValue(): number;
            floatValue(): number;
            doubleValue(): number;
            static valueOf(param0: number): number;
            static valueOf(param0: string): number;
            static valueOf(param0: string, param1: number): number;
            static toHexString(param0: number): string;
            static decode(param0: string): number;
            static compare(param0: number, param1: number): number;
            static reverse(param0: number): number;
            static sum(param0: number, param1: number): number;
            static toUnsignedLong(param0: number): number;
            static parseInt(param0: string): number;
            static parseInt(param0: string, param1: number): number;
            static toUnsignedString(param0: number): string;
            static toUnsignedString(param0: number, param1: number): string;
            static toOctalString(param0: number): string;
            static toBinaryString(param0: number): string;
            static parseUnsignedInt(param0: string): number;
            static parseUnsignedInt(param0: string, param1: number): number;
            static getInteger(param0: string, param1: number): number;
            static getInteger(param0: string): number;
            static getInteger(param0: string, param1: number): number;
            static compareUnsigned(param0: number, param1: number): number;
            static divideUnsigned(param0: number, param1: number): number;
            static remainderUnsigned(param0: number, param1: number): number;
            static highestOneBit(param0: number): number;
            static lowestOneBit(param0: number): number;
            static rotateLeft(param0: number, param1: number): number;
            static rotateRight(param0: number, param1: number): number;
            static signum(param0: number): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class InstantiationException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IndexOutOfBoundsException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IncompatibleClassChangeError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalStateException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalMonitorStateException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalArgumentException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalAccessException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalAccessError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Float{
            equals(param0: any): boolean;
            static toString(param0: number): string;
            toString(): string;
            hashCode(): number;
            static hashCode(param0: number): number;
            static min(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static floatToRawIntBits(param0: number): number;
            static floatToIntBits(param0: number): number;
            static intBitsToFloat(param0: number): number;
            compareTo(param0: number): number;
            compareTo(param0: any): number;
            byteValue(): number;
            shortValue(): number;
            intValue(): number;
            longValue(): number;
            floatValue(): number;
            doubleValue(): number;
            static valueOf(param0: number): number;
            static valueOf(param0: string): number;
            static toHexString(param0: number): string;
            static compare(param0: number, param1: number): number;
            static isNaN(param0: number): boolean;
            isNaN(): boolean;
            static parseFloat(param0: string): number;
            static isInfinite(param0: number): boolean;
            isInfinite(): boolean;
            static isFinite(param0: number): boolean;
            static sum(param0: number, param1: number): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ExceptionInInitializerError{
            getCause(): java.lang.Throwable;
            getException(): java.lang.Throwable;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Exception{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Error{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Enum{
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Double{
            equals(param0: any): boolean;
            static toString(param0: number): string;
            toString(): string;
            hashCode(): number;
            static hashCode(param0: number): number;
            static min(param0: number, param1: number): number;
            static max(param0: number, param1: number): number;
            static doubleToRawLongBits(param0: number): number;
            static doubleToLongBits(param0: number): number;
            static longBitsToDouble(param0: number): number;
            compareTo(param0: any): number;
            compareTo(param0: number): number;
            byteValue(): number;
            shortValue(): number;
            intValue(): number;
            longValue(): number;
            floatValue(): number;
            doubleValue(): number;
            static valueOf(param0: string): number;
            static valueOf(param0: number): number;
            static toHexString(param0: number): string;
            static compare(param0: number, param1: number): number;
            static isNaN(param0: number): boolean;
            isNaN(): boolean;
            static isInfinite(param0: number): boolean;
            isInfinite(): boolean;
            static isFinite(param0: number): boolean;
            static sum(param0: number, param1: number): number;
            static parseDouble(param0: string): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Compiler$1{
            run(): java.lang.Void;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Compiler{
            static compileClass(param0: java.lang.Class): boolean;
            static compileClasses(param0: string): boolean;
            static command(param0: any): any;
            static enable();
            static disable();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
             VM , : ''127.0.0.1:53265': '''
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Comparable{
            compareTo(param0: any): number;
        }
        class Cloneable{
        }
        class CloneNotSupportedException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassValue$ClassValueMap{
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            values(): java.util.Collection;
            clear();
            isEmpty(): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            putIfAbsent(param0: any, param1: any): any;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class ClassNotFoundException{
            getCause(): java.lang.Throwable;
            getException(): java.lang.Throwable;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassLoaderHelper{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassLoader$ParallelLoaders{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassLoader$NativeLibrary{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassLoader$3{
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassLoader$2{
            hasMoreElements(): boolean;
            nextElement(): java.net.URL;
            nextElement(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassLoader{
            loadClass(param0: string): java.lang.Class;
            static getSystemClassLoader(): java.lang.ClassLoader;
            getResourceAsStream(param0: string): java.io.InputStream;
            getResource(param0: string): java.net.URL;
            static getSystemResourceAsStream(param0: string): java.io.InputStream;
            static getSystemResource(param0: string): java.net.URL;
            getResources(param0: string): java.util.Enumeration;
            static getSystemResources(param0: string): java.util.Enumeration;
            getParent(): java.lang.ClassLoader;
            setDefaultAssertionStatus(param0: boolean);
            setPackageAssertionStatus(param0: string, param1: boolean);
            setClassAssertionStatus(param0: string, param1: boolean);
            clearAssertionStatus();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ClassCastException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$ReflectionData{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$Atomic{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$AnnotationData{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$4{
            run(): java.lang.Void;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$3{
            run(): java.lang.Void;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class$1{
            run(): java.lang.Void;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Class{
            static forName(param0: string): java.lang.Class;
            static forName(param0: string, param1: boolean, param2: java.lang.ClassLoader): java.lang.Class;
            toString(): string;
            getProtectionDomain(): java.security.ProtectionDomain;
            isAssignableFrom(param0: java.lang.Class): boolean;
            isInstance(param0: any): boolean;
            getModifiers(): number;
            isInterface(): boolean;
            isArray(): boolean;
            isPrimitive(): boolean;
            getSuperclass(): java.lang.Class;
            getComponentType(): java.lang.Class;
            getName(): string;
            toGenericString(): string;
            newInstance(): any;
            isAnnotation(): boolean;
            isSynthetic(): boolean;
            getClassLoader(): java.lang.ClassLoader;
            getTypeParameters(): any[];
            getGenericSuperclass(): java.lang.reflect.Type;
            getPackage(): java.lang.Package;
            getInterfaces(): any[];
            getGenericInterfaces(): any[];
            getSigners(): any[];
            getEnclosingMethod(): java.lang.reflect.Method;
            getEnclosingConstructor(): java.lang.reflect.Constructor;
            getDeclaringClass(): java.lang.Class;
            getEnclosingClass(): java.lang.Class;
            getSimpleName(): string;
            getTypeName(): string;
            getCanonicalName(): string;
            isAnonymousClass(): boolean;
            isLocalClass(): boolean;
            isMemberClass(): boolean;
            getClasses(): any[];
            getFields(): any[];
            getMethods(): any[];
            getConstructors(): any[];
            getField(param0: string): java.lang.reflect.Field;
            getMethod(param0: string, param1: any[]): java.lang.reflect.Method;
            getConstructor(param0: any[]): java.lang.reflect.Constructor;
            getDeclaredClasses(): any[];
            getDeclaredFields(): any[];
            getDeclaredMethods(): any[];
            getDeclaredConstructors(): any[];
            getDeclaredField(param0: string): java.lang.reflect.Field;
            getDeclaredMethod(param0: string, param1: any[]): java.lang.reflect.Method;
            getDeclaredConstructor(param0: any[]): java.lang.reflect.Constructor;
            getResourceAsStream(param0: string): java.io.InputStream;
            getResource(param0: string): java.net.URL;
            desiredAssertionStatus(): boolean;
            isEnum(): boolean;
            getEnumConstants(): any[];
            cast(param0: any): any;
            asSubclass(param0: java.lang.Class): java.lang.Class;
            getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
            isAnnotationPresent(param0: java.lang.Class): boolean;
            getAnnotationsByType(param0: java.lang.Class): any[];
            getAnnotations(): any[];
            getDeclaredAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
            getDeclaredAnnotationsByType(param0: java.lang.Class): any[];
            getDeclaredAnnotations(): any[];
            getAnnotatedSuperclass(): java.lang.reflect.AnnotatedType;
            getAnnotatedInterfaces(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterDataLatin1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharacterData{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Character$CharacterCache{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Character{
            static isJavaIdentifierStart(param0: string): boolean;
            static isJavaIdentifierStart(param0: number): boolean;
            static isJavaIdentifierPart(param0: number): boolean;
            static isJavaIdentifierPart(param0: string): boolean;
            equals(param0: any): boolean;
            static toString(param0: string): string;
            toString(): string;
            hashCode(): number;
            static hashCode(param0: string): number;
            static reverseBytes(param0: string): string;
            compareTo(param0: string): number;
            compareTo(param0: any): number;
            charValue(): string;
            static valueOf(param0: string): string;
            static getName(param0: number): string;
            static codePointAt(param0: any[], param1: number): number;
            static codePointAt(param0: any[], param1: number, param2: number): number;
            static codePointAt(param0: java.lang.CharSequence, param1: number): number;
            static codePointBefore(param0: any[], param1: number): number;
            static codePointBefore(param0: java.lang.CharSequence, param1: number): number;
            static codePointBefore(param0: any[], param1: number, param2: number): number;
            static codePointCount(param0: any[], param1: number, param2: number): number;
            static codePointCount(param0: java.lang.CharSequence, param1: number, param2: number): number;
            static offsetByCodePoints(param0: any[], param1: number, param2: number, param3: number, param4: number): number;
            static offsetByCodePoints(param0: java.lang.CharSequence, param1: number, param2: number): number;
            static toLowerCase(param0: number): number;
            static toLowerCase(param0: string): string;
            static toUpperCase(param0: string): string;
            static toUpperCase(param0: number): number;
            static isBmpCodePoint(param0: number): boolean;
            static isValidCodePoint(param0: number): boolean;
            static compare(param0: string, param1: string): number;
            static highSurrogate(param0: number): string;
            static lowSurrogate(param0: number): string;
            static charCount(param0: number): number;
            static toChars(param0: number, param1: any[], param2: number): number;
            static toChars(param0: number): any[];
            static getType(param0: string): number;
            static getType(param0: number): number;
            static isDigit(param0: number): boolean;
            static isDigit(param0: string): boolean;
            static isSurrogate(param0: string): boolean;
            static isLowSurrogate(param0: string): boolean;
            static isHighSurrogate(param0: string): boolean;
            static isLetter(param0: string): boolean;
            static isLetter(param0: number): boolean;
            static isLetterOrDigit(param0: string): boolean;
            static isLetterOrDigit(param0: number): boolean;
            static isSupplementaryCodePoint(param0: number): boolean;
            static isSurrogatePair(param0: string, param1: string): boolean;
            static toCodePoint(param0: string, param1: string): number;
            static isLowerCase(param0: string): boolean;
            static isLowerCase(param0: number): boolean;
            static isUpperCase(param0: number): boolean;
            static isUpperCase(param0: string): boolean;
            static isTitleCase(param0: string): boolean;
            static isTitleCase(param0: number): boolean;
            static isDefined(param0: string): boolean;
            static isDefined(param0: number): boolean;
            static isJavaLetter(param0: string): boolean;
            static isJavaLetterOrDigit(param0: string): boolean;
            static isAlphabetic(param0: number): boolean;
            static isIdeographic(param0: number): boolean;
            static isUnicodeIdentifierStart(param0: number): boolean;
            static isUnicodeIdentifierStart(param0: string): boolean;
            static isUnicodeIdentifierPart(param0: number): boolean;
            static isUnicodeIdentifierPart(param0: string): boolean;
            static isIdentifierIgnorable(param0: string): boolean;
            static isIdentifierIgnorable(param0: number): boolean;
            static toTitleCase(param0: number): number;
            static toTitleCase(param0: string): string;
            static digit(param0: string, param1: number): number;
            static digit(param0: number, param1: number): number;
            static getNumericValue(param0: number): number;
            static getNumericValue(param0: string): number;
            static isSpace(param0: string): boolean;
            static isSpaceChar(param0: string): boolean;
            static isSpaceChar(param0: number): boolean;
            static isWhitespace(param0: string): boolean;
            static isWhitespace(param0: number): boolean;
            static isISOControl(param0: string): boolean;
            static isISOControl(param0: number): boolean;
            static forDigit(param0: number, param1: number): string;
            static getDirectionality(param0: string): number;
            static getDirectionality(param0: number): number;
            static isMirrored(param0: number): boolean;
            static isMirrored(param0: string): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class CharSequence{
            toString(): string;
            length(): number;
            charAt(param0: number): string;
            subSequence(param0: number, param1: number): java.lang.CharSequence;
            chars(): java.util.stream.IntStream;
            codePoints(): java.util.stream.IntStream;
        }
        class Byte{
            equals(param0: any): boolean;
            toString(): string;
            static toString(param0: number): string;
            static hashCode(param0: number): number;
            hashCode(): number;
            compareTo(param0: number): number;
            compareTo(param0: any): number;
            byteValue(): number;
            shortValue(): number;
            intValue(): number;
            longValue(): number;
            floatValue(): number;
            doubleValue(): number;
            static valueOf(param0: number): number;
            static valueOf(param0: string): number;
            static valueOf(param0: string, param1: number): number;
            static decode(param0: string): number;
            static compare(param0: number, param1: number): number;
            static parseByte(param0: string, param1: number): number;
            static parseByte(param0: string): number;
            static toUnsignedInt(param0: number): number;
            static toUnsignedLong(param0: number): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class BootstrapMethodError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Boolean{
            equals(param0: any): boolean;
            toString(): string;
            static toString(param0: boolean): string;
            static hashCode(param0: boolean): number;
            hashCode(): number;
            compareTo(param0: boolean): number;
            compareTo(param0: any): number;
            static getBoolean(param0: string): boolean;
            booleanValue(): boolean;
            static valueOf(param0: string): boolean;
            static valueOf(param0: boolean): boolean;
            static compare(param0: boolean, param1: boolean): number;
            static parseBoolean(param0: string): boolean;
            static logicalAnd(param0: boolean, param1: boolean): boolean;
            static logicalOr(param0: boolean, param1: boolean): boolean;
            static logicalXor(param0: boolean, param1: boolean): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class AutoCloseable{
            close();
        }
        class ArrayStoreException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayIndexOutOfBoundsException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArithmeticException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ApplicationShutdownHooks$1{
            run();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ApplicationShutdownHooks{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Appendable{
            append(param0: java.lang.CharSequence): java.lang.Appendable;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.Appendable;
            append(param0: string): java.lang.Appendable;
        }
        class AbstractStringBuilder{
            toString(): string;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.AbstractStringBuilder;
            append(param0: any[]): java.lang.AbstractStringBuilder;
            append(param0: any[], param1: number, param2: number): java.lang.AbstractStringBuilder;
            append(param0: boolean): java.lang.AbstractStringBuilder;
            append(param0: java.lang.StringBuffer): java.lang.AbstractStringBuilder;
            append(param0: string): java.lang.AbstractStringBuilder;
            append(param0: java.lang.CharSequence): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: string): java.lang.Appendable;
            append(param0: java.lang.CharSequence, param1: number, param2: number): java.lang.Appendable;
            append(param0: java.lang.CharSequence): java.lang.Appendable;
            append(param0: string): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: number): java.lang.AbstractStringBuilder;
            append(param0: any): java.lang.AbstractStringBuilder;
            indexOf(param0: string): number;
            indexOf(param0: string, param1: number): number;
            length(): number;
            charAt(param0: number): string;
            codePointAt(param0: number): number;
            codePointBefore(param0: number): number;
            codePointCount(param0: number, param1: number): number;
            offsetByCodePoints(param0: number, param1: number): number;
            getChars(param0: number, param1: number, param2: any[], param3: number);
            lastIndexOf(param0: string): number;
            lastIndexOf(param0: string, param1: number): number;
            substring(param0: number, param1: number): string;
            substring(param0: number): string;
            subSequence(param0: number, param1: number): java.lang.CharSequence;
            replace(param0: number, param1: number, param2: string): java.lang.AbstractStringBuilder;
            delete(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: string): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: java.lang.CharSequence, param2: number, param3: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: boolean): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: any): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: any[], param2: number, param3: number): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: string): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: java.lang.CharSequence): java.lang.AbstractStringBuilder;
            insert(param0: number, param1: any[]): java.lang.AbstractStringBuilder;
            capacity(): number;
            ensureCapacity(param0: number);
            trimToSize();
            setLength(param0: number);
            setCharAt(param0: number, param1: string);
            appendCodePoint(param0: number): java.lang.AbstractStringBuilder;
            deleteCharAt(param0: number): java.lang.AbstractStringBuilder;
            reverse(): java.lang.AbstractStringBuilder;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            chars(): java.util.stream.IntStream;
            codePoints(): java.util.stream.IntStream;
        }
    }
    namespace util{
        class AbstractList$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class AbstractList$ListItr{
            add(param0: any);
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class AbstractMap$1$1{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class AbstractMap$1{
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class AbstractMap$2$1{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class AbstractMap$2{
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class AbstractMap$SimpleEntry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class AbstractMap$SimpleImmutableEntry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayDeque$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayDeque$DeqIterator{
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayDeque$DeqSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.ArrayDeque$DeqSpliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class ArrayDeque$DescendingIterator{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class ArrayList$ArrayListSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.ArrayList$ArrayListSpliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class ArrayPrefixHelpers$CumulateTask{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayPrefixHelpers$DoubleCumulateTask{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayPrefixHelpers$IntCumulateTask{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayPrefixHelpers$LongCumulateTask{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayPrefixHelpers{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Arrays$NaturalOrder{
            compare(param0: any, param1: any): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            reversed(): java.util.Comparator;
            thenComparing(param0: java.util.function.Function): java.util.Comparator;
            thenComparing(param0: java.util.function.Function, param1: java.util.Comparator): java.util.Comparator;
            thenComparing(param0: java.util.Comparator): java.util.Comparator;
            thenComparingInt(param0: java.util.function.ToIntFunction): java.util.Comparator;
            thenComparingLong(param0: java.util.function.ToLongFunction): java.util.Comparator;
            thenComparingDouble(param0: java.util.function.ToDoubleFunction): java.util.Comparator;
        }
        class ArraysParallelSortHelpers$EmptyCompleter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJByte$Merger{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJByte$Sorter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJByte{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJChar$Merger{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJChar$Sorter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJChar{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJDouble$Merger{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJDouble$Sorter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJDouble{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJFloat$Merger{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJFloat$Sorter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJFloat{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJInt$Merger{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJInt$Sorter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJInt{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJLong$Merger{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJLong$Sorter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJLong{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJObject$Merger{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJObject$Sorter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJObject{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJShort$Merger{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJShort$Sorter{
            compute();
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$FJShort{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers$Relay{
            compute();
            onCompletion(param0: java.util.concurrent.CountedCompleter);
            getRoot(): java.util.concurrent.CountedCompleter;
            getPendingCount(): number;
            compareAndSetPendingCount(param0: number, param1: number): boolean;
            getCompleter(): java.util.concurrent.CountedCompleter;
            onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
            setPendingCount(param0: number);
            addToPendingCount(param0: number);
            decrementPendingCountUnlessZero(): number;
            tryComplete();
            propagateCompletion();
            complete(param0: any);
            firstComplete(): java.util.concurrent.CountedCompleter;
            nextComplete(): java.util.concurrent.CountedCompleter;
            quietlyCompleteRoot();
            helpComplete(param0: number);
            getRawResult(): any;
            invoke(): any;
            get(): any;
            get(param0: number, param1: java.util.concurrent.TimeUnit): any;
            join(): any;
            getException(): java.lang.Throwable;
            reinitialize();
            static getPool(): java.util.concurrent.ForkJoinPool;
            fork(): java.util.concurrent.ForkJoinTask;
            static invokeAll(param0: any[]);
            static invokeAll(param0: java.util.Collection): java.util.Collection;
            static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
            cancel(param0: boolean): boolean;
            isDone(): boolean;
            isCancelled(): boolean;
            isCompletedAbnormally(): boolean;
            isCompletedNormally(): boolean;
            completeExceptionally(param0: java.lang.Throwable);
            quietlyJoin();
            quietlyInvoke();
            static helpQuiesce();
            static inForkJoinPool(): boolean;
            tryUnfork(): boolean;
            static getQueuedTaskCount(): number;
            static getSurplusQueuedTaskCount(): number;
            getForkJoinTaskTag(): number;
            setForkJoinTaskTag(param0: number): number;
            compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
            static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
            static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
            quietlyComplete();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArraysParallelSortHelpers{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Base64$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Base64$DecInputStream{
            read(param0: any[], param1: number, param2: number): number;
            read(): number;
            close();
            available(): number;
            read(param0: any[]): number;
            mark(param0: number);
            skip(param0: number): number;
            markSupported(): boolean;
            reset();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Base64$Decoder{
            decode(param0: any[]): any[];
            decode(param0: java.nio.ByteBuffer): java.nio.ByteBuffer;
            decode(param0: any[], param1: any[]): number;
            decode(param0: string): any[];
            wrap(param0: java.io.InputStream): java.io.InputStream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Base64$EncOutputStream{
            write(param0: number);
            write(param0: any[], param1: number, param2: number);
            close();
            write(param0: any[]);
            flush();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Base64$Encoder{
            encode(param0: any[]): any[];
            encode(param0: java.nio.ByteBuffer): java.nio.ByteBuffer;
            encode(param0: any[], param1: any[]): number;
            wrap(param0: java.io.OutputStream): java.io.OutputStream;
            encodeToString(param0: any[]): string;
            withoutPadding(): java.util.Base64$Encoder;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Base64{
            static getEncoder(): java.util.Base64$Encoder;
            static getUrlEncoder(): java.util.Base64$Encoder;
            static getMimeEncoder(param0: number, param1: any[]): java.util.Base64$Encoder;
            static getMimeEncoder(): java.util.Base64$Encoder;
            static getDecoder(): java.util.Base64$Decoder;
            static getUrlDecoder(): java.util.Base64$Decoder;
            static getMimeDecoder(): java.util.Base64$Decoder;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class BitSet$1BitSetIterator{
            hasNext(): boolean;
            nextInt(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            next(): number;
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.Consumer);
            remove();
        }
        class Calendar$1{
            run(): sun.util.calendar.ZoneInfo;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Calendar$AvailableCalendarTypes{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Calendar$Builder{
            set(param0: number, param1: number): java.util.Calendar$Builder;
            build(): java.util.Calendar;
            setTimeZone(param0: java.util.TimeZone): java.util.Calendar$Builder;
            setDate(param0: number, param1: number, param2: number): java.util.Calendar$Builder;
            setInstant(param0: number): java.util.Calendar$Builder;
            setInstant(param0: java.util.Date): java.util.Calendar$Builder;
            setFields(param0: any[]): java.util.Calendar$Builder;
            setTimeOfDay(param0: number, param1: number, param2: number): java.util.Calendar$Builder;
            setTimeOfDay(param0: number, param1: number, param2: number, param3: number): java.util.Calendar$Builder;
            setWeekDate(param0: number, param1: number, param2: number): java.util.Calendar$Builder;
            setLenient(param0: boolean): java.util.Calendar$Builder;
            setCalendarType(param0: string): java.util.Calendar$Builder;
            setLocale(param0: java.util.Locale): java.util.Calendar$Builder;
            setWeekDefinition(param0: number, param1: number): java.util.Calendar$Builder;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Calendar$CalendarAccessControlContext{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Calendar{
            add(param0: number, param1: number);
            get(param0: number): number;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clone(): any;
            compareTo(param0: java.util.Calendar): number;
            compareTo(param0: any): number;
            clear();
            clear(param0: number);
            static getInstance(): java.util.Calendar;
            static getInstance(param0: java.util.Locale): java.util.Calendar;
            static getInstance(param0: java.util.TimeZone): java.util.Calendar;
            static getInstance(param0: java.util.TimeZone, param1: java.util.Locale): java.util.Calendar;
            isSet(param0: number): boolean;
            set(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number);
            set(param0: number, param1: number);
            set(param0: number, param1: number, param2: number);
            set(param0: number, param1: number, param2: number, param3: number, param4: number);
            before(param0: any): boolean;
            after(param0: any): boolean;
            static getAvailableLocales(): any[];
            getDisplayName(param0: number, param1: number, param2: java.util.Locale): string;
            setTime(param0: java.util.Date);
            getTime(): java.util.Date;
            getTimeZone(): java.util.TimeZone;
            setTimeZone(param0: java.util.TimeZone);
            getDisplayNames(param0: number, param1: number, param2: java.util.Locale): java.util.Map;
            setWeekDate(param0: number, param1: number, param2: number);
            setLenient(param0: boolean);
            static getAvailableCalendarTypes(): java.util.Set;
            setFirstDayOfWeek(param0: number);
            setMinimalDaysInFirstWeek(param0: number);
            setTimeInMillis(param0: number);
            isWeekDateSupported(): boolean;
            getFirstDayOfWeek(): number;
            getTimeInMillis(): number;
            getCalendarType(): string;
            roll(param0: number, param1: boolean);
            roll(param0: number, param1: number);
            isLenient(): boolean;
            getMinimalDaysInFirstWeek(): number;
            getWeekYear(): number;
            getWeeksInWeekYear(): number;
            getMinimum(param0: number): number;
            getMaximum(param0: number): number;
            getGreatestMinimum(param0: number): number;
            getLeastMaximum(param0: number): number;
            getActualMinimum(param0: number): number;
            getActualMaximum(param0: number): number;
            toInstant(): java.time.Instant;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$1{
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$2{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Collections$3{
            hasMoreElements(): boolean;
            nextElement(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$AsLIFOQueue{
            add(param0: any): boolean;
            remove(): any;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            poll(): any;
            forEach(param0: java.util.function.Consumer);
            peek(): any;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            offer(param0: any): boolean;
            element(): any;
            addAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedCollection$1{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class Collections$CheckedCollection{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedList$1{
            add(param0: any);
            remove();
            hasNext(): boolean;
            next(): any;
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedList{
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            lastIndexOf(param0: any): number;
            replaceAll(param0: java.util.function.UnaryOperator);
            subList(param0: number, param1: number): java.util.List;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(): java.util.ListIterator;
            listIterator(param0: number): java.util.ListIterator;
            sort(param0: java.util.Comparator);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedMap$CheckedEntrySet$1{
            remove();
            hasNext(): boolean;
            next(): java.util.Map$Entry;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class Collections$CheckedMap$CheckedEntrySet$CheckedEntry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedMap$CheckedEntrySet{
            add(param0: any): boolean;
            add(param0: java.util.Map$Entry): boolean;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class Collections$CheckedMap{
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getOrDefault(param0: any, param1: any): any;
        }
        class Collections$CheckedNavigableMap{
            keySet(): java.util.NavigableSet;
            keySet(): java.util.Set;
            firstKey(): any;
            lastKey(): any;
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            descendingMap(): java.util.NavigableMap;
            navigableKeySet(): java.util.NavigableSet;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: any): java.util.SortedMap;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            subMap(param0: any, param1: any): java.util.NavigableMap;
            headMap(param0: any): java.util.SortedMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            headMap(param0: any): java.util.NavigableMap;
            tailMap(param0: any): java.util.SortedMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any): java.util.NavigableMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getOrDefault(param0: any, param1: any): any;
        }
        class Collections$CheckedNavigableSet{
            floor(param0: any): any;
            pollFirst(): any;
            pollLast(): any;
            descendingIterator(): java.util.Iterator;
            lower(param0: any): any;
            ceiling(param0: any): any;
            higher(param0: any): any;
            descendingSet(): java.util.NavigableSet;
            subSet(param0: any, param1: any): java.util.SortedSet;
            subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
            subSet(param0: any, param1: any): java.util.NavigableSet;
            headSet(param0: any): java.util.SortedSet;
            headSet(param0: any, param1: boolean): java.util.NavigableSet;
            headSet(param0: any): java.util.NavigableSet;
            tailSet(param0: any): java.util.NavigableSet;
            tailSet(param0: any): java.util.SortedSet;
            tailSet(param0: any, param1: boolean): java.util.NavigableSet;
            first(): any;
            last(): any;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedQueue{
            remove(): any;
            equals(param0: any): boolean;
            hashCode(): number;
            poll(): any;
            peek(): any;
            offer(param0: any): boolean;
            element(): any;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedRandomAccessList{
            subList(param0: number, param1: number): java.util.List;
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            lastIndexOf(param0: any): number;
            replaceAll(param0: java.util.function.UnaryOperator);
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(): java.util.ListIterator;
            listIterator(param0: number): java.util.ListIterator;
            sort(param0: java.util.Comparator);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedSet{
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CheckedSortedMap{
            firstKey(): any;
            lastKey(): any;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getOrDefault(param0: any, param1: any): any;
        }
        class Collections$CheckedSortedSet{
            first(): any;
            last(): any;
            subSet(param0: any, param1: any): java.util.SortedSet;
            headSet(param0: any): java.util.SortedSet;
            tailSet(param0: any): java.util.SortedSet;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$CopiesList{
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            lastIndexOf(param0: any): number;
            contains(param0: any): boolean;
            size(): number;
            subList(param0: number, param1: number): java.util.List;
            toArray(): any[];
            toArray(param0: any[]): any[];
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            parallelStream(): java.util.stream.Stream;
            add(param0: number, param1: any);
            add(param0: any): boolean;
            remove(param0: number): any;
            clear();
            iterator(): java.util.Iterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            removeIf(param0: java.util.function.Predicate): boolean;
            forEach(param0: java.util.function.Consumer);
            replaceAll(param0: java.util.function.UnaryOperator);
            sort(param0: java.util.Comparator);
        }
        class Collections$EmptyIterator{
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$EmptyListIterator{
            add(param0: any);
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$ReverseComparator{
            compare(param0: any, param1: any): number;
            compare(param0: java.lang.Comparable, param1: java.lang.Comparable): number;
            reversed(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            thenComparing(param0: java.util.function.Function): java.util.Comparator;
            thenComparing(param0: java.util.function.Function, param1: java.util.Comparator): java.util.Comparator;
            thenComparing(param0: java.util.Comparator): java.util.Comparator;
            thenComparingInt(param0: java.util.function.ToIntFunction): java.util.Comparator;
            thenComparingLong(param0: java.util.function.ToLongFunction): java.util.Comparator;
            thenComparingDouble(param0: java.util.function.ToDoubleFunction): java.util.Comparator;
        }
        class Collections$ReverseComparator2{
            equals(param0: any): boolean;
            hashCode(): number;
            compare(param0: any, param1: any): number;
            reversed(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            toString(): string;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            thenComparing(param0: java.util.function.Function): java.util.Comparator;
            thenComparing(param0: java.util.function.Function, param1: java.util.Comparator): java.util.Comparator;
            thenComparing(param0: java.util.Comparator): java.util.Comparator;
            thenComparingInt(param0: java.util.function.ToIntFunction): java.util.Comparator;
            thenComparingLong(param0: java.util.function.ToLongFunction): java.util.Comparator;
            thenComparingDouble(param0: java.util.function.ToDoubleFunction): java.util.Comparator;
        }
        class Collections$SingletonList{
            get(param0: number): any;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            removeIf(param0: java.util.function.Predicate): boolean;
            sort(param0: java.util.Comparator);
            add(param0: number, param1: any);
            add(param0: any): boolean;
            remove(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            clear();
            lastIndexOf(param0: any): number;
            subList(param0: number, param1: number): java.util.List;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            parallelStream(): java.util.stream.Stream;
        }
        class Collections$SingletonMap{
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            values(): java.util.Collection;
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            remove(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clear();
            putAll(param0: java.util.Map);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SingletonSet{
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            removeIf(param0: java.util.function.Predicate): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            parallelStream(): java.util.stream.Stream;
        }
        class Collections$SynchronizedList{
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            lastIndexOf(param0: any): number;
            replaceAll(param0: java.util.function.UnaryOperator);
            subList(param0: number, param1: number): java.util.List;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            sort(param0: java.util.Comparator);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SynchronizedNavigableMap{
            keySet(): java.util.Set;
            keySet(): java.util.NavigableSet;
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            descendingMap(): java.util.NavigableMap;
            navigableKeySet(): java.util.NavigableSet;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any): java.util.SortedMap;
            firstKey(): any;
            lastKey(): any;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SynchronizedNavigableSet{
            floor(param0: any): any;
            pollFirst(): any;
            pollLast(): any;
            descendingIterator(): java.util.Iterator;
            lower(param0: any): any;
            ceiling(param0: any): any;
            higher(param0: any): any;
            descendingSet(): java.util.NavigableSet;
            subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
            subSet(param0: any, param1: any): java.util.SortedSet;
            subSet(param0: any, param1: any): java.util.NavigableSet;
            headSet(param0: any): java.util.SortedSet;
            headSet(param0: any, param1: boolean): java.util.NavigableSet;
            headSet(param0: any): java.util.NavigableSet;
            tailSet(param0: any): java.util.NavigableSet;
            tailSet(param0: any): java.util.SortedSet;
            tailSet(param0: any, param1: boolean): java.util.NavigableSet;
            first(): any;
            last(): any;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SynchronizedRandomAccessList{
            subList(param0: number, param1: number): java.util.List;
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            lastIndexOf(param0: any): number;
            replaceAll(param0: java.util.function.UnaryOperator);
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            sort(param0: java.util.Comparator);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SynchronizedSortedMap{
            firstKey(): any;
            lastKey(): any;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SynchronizedSortedSet{
            first(): any;
            last(): any;
            subSet(param0: any, param1: any): java.util.SortedSet;
            headSet(param0: any): java.util.SortedSet;
            tailSet(param0: any): java.util.SortedSet;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableList$1{
            add(param0: any);
            remove();
            hasNext(): boolean;
            next(): any;
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableMap$UnmodifiableEntrySet$1{
            remove();
            hasNext(): boolean;
            next(): any;
            next(): java.util.Map$Entry;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntrySetSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            getExactSizeIfKnown(): number;
            characteristics(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableMap$UnmodifiableEntrySet{
            equals(param0: any): boolean;
            contains(param0: any): boolean;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            parallelStream(): java.util.stream.Stream;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            size(): number;
            addAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableNavigableMap$EmptyNavigableMap{
            navigableKeySet(): java.util.NavigableSet;
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            descendingMap(): java.util.NavigableMap;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            firstKey(): any;
            lastKey(): any;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableNavigableMap{
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            descendingMap(): java.util.NavigableMap;
            navigableKeySet(): java.util.NavigableSet;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            firstKey(): any;
            lastKey(): any;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableNavigableSet$EmptyNavigableSet{
            floor(param0: any): any;
            pollFirst(): any;
            pollLast(): any;
            descendingIterator(): java.util.Iterator;
            lower(param0: any): any;
            ceiling(param0: any): any;
            higher(param0: any): any;
            descendingSet(): java.util.NavigableSet;
            subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
            headSet(param0: any, param1: boolean): java.util.NavigableSet;
            tailSet(param0: any, param1: boolean): java.util.NavigableSet;
            first(): any;
            last(): any;
            subSet(param0: any, param1: any): java.util.SortedSet;
            headSet(param0: any): java.util.SortedSet;
            tailSet(param0: any): java.util.SortedSet;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableNavigableSet{
            floor(param0: any): any;
            pollFirst(): any;
            pollLast(): any;
            descendingIterator(): java.util.Iterator;
            lower(param0: any): any;
            ceiling(param0: any): any;
            higher(param0: any): any;
            descendingSet(): java.util.NavigableSet;
            subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
            headSet(param0: any, param1: boolean): java.util.NavigableSet;
            tailSet(param0: any, param1: boolean): java.util.NavigableSet;
            first(): any;
            last(): any;
            subSet(param0: any, param1: any): java.util.SortedSet;
            headSet(param0: any): java.util.SortedSet;
            tailSet(param0: any): java.util.SortedSet;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableSortedMap{
            firstKey(): any;
            lastKey(): any;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Comparators$NaturalOrderComparator{
            static values(): any[];
            static valueOf(param0: string): java.util.Comparators$NaturalOrderComparator;
            compare(param0: java.lang.Comparable, param1: java.lang.Comparable): number;
            compare(param0: any, param1: any): number;
            reversed(): java.util.Comparator;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            thenComparing(param0: java.util.function.Function): java.util.Comparator;
            thenComparing(param0: java.util.function.Function, param1: java.util.Comparator): java.util.Comparator;
            thenComparing(param0: java.util.Comparator): java.util.Comparator;
            thenComparingInt(param0: java.util.function.ToIntFunction): java.util.Comparator;
            thenComparingLong(param0: java.util.function.ToLongFunction): java.util.Comparator;
            thenComparingDouble(param0: java.util.function.ToDoubleFunction): java.util.Comparator;
        }
        class Comparators$NullComparator{
            compare(param0: any, param1: any): number;
            reversed(): java.util.Comparator;
            thenComparing(param0: java.util.Comparator): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            thenComparing(param0: java.util.function.Function): java.util.Comparator;
            thenComparing(param0: java.util.function.Function, param1: java.util.Comparator): java.util.Comparator;
            thenComparingInt(param0: java.util.function.ToIntFunction): java.util.Comparator;
            thenComparingLong(param0: java.util.function.ToLongFunction): java.util.Comparator;
            thenComparingDouble(param0: java.util.function.ToDoubleFunction): java.util.Comparator;
        }
        class Comparators{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ConcurrentModificationException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Currency$1{
            run(): java.lang.Void;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Currency$CurrencyNameGetter{
            getObject(param0: java.util.spi.CurrencyNameProvider, param1: java.util.Locale, param2: string, param3: any[]): string;
            getObject(param0: java.util.spi.LocaleServiceProvider, param1: java.util.Locale, param2: string, param3: any[]): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Currency{
            toString(): string;
            static getInstance(param0: java.util.Locale): java.util.Currency;
            static getInstance(param0: string): java.util.Currency;
            getDisplayName(param0: java.util.Locale): string;
            getDisplayName(): string;
            getSymbol(): string;
            getSymbol(param0: java.util.Locale): string;
            static getAvailableCurrencies(): java.util.Set;
            getCurrencyCode(): string;
            getDefaultFractionDigits(): number;
            getNumericCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class DoubleSummaryStatistics{
            toString(): string;
            accept(param0: number);
            combine(param0: java.util.DoubleSummaryStatistics);
            getCount(): number;
            getSum(): number;
            getMin(): number;
            getMax(): number;
            getAverage(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
        }
        class DualPivotQuicksort{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class DuplicateFormatFlagsException{
            getMessage(): string;
            getFlags(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class EmptyStackException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class EnumMap$1{
            toString(): string;
            hashCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class EnumMap$EntryIterator$Entry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): java.lang.Enum;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class EnumMap$EntryIterator{
            remove();
            next(): java.util.Map$Entry;
            next(): any;
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class EnumMap$EntrySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class EnumMap$EnumMapIterator{
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class EnumMap$KeyIterator{
            next(): java.lang.Enum;
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class EnumMap$KeySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class EnumMap$ValueIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class EnumMap$Values{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class EnumMap{
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: java.lang.Enum, param1: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            values(): java.util.Collection;
            hashCode(): number;
            clone(): java.util.EnumMap;
            clone(): any;
            clear();
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class EnumSet$SerializationProxy{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class EnumSet{
            clone(): any;
            clone(): java.util.EnumSet;
            static copyOf(param0: java.util.EnumSet): java.util.EnumSet;
            static copyOf(param0: java.util.Collection): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum, param3: java.lang.Enum, param4: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: any[]): java.util.EnumSet;
            static of(param0: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum, param3: java.lang.Enum): java.util.EnumSet;
            static range(param0: java.lang.Enum, param1: java.lang.Enum): java.util.EnumSet;
            static noneOf(param0: java.lang.Class): java.util.EnumSet;
            static allOf(param0: java.lang.Class): java.util.EnumSet;
            static complementOf(param0: java.util.EnumSet): java.util.EnumSet;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
        }
        class FormatFlagsConversionMismatchException{
            getMessage(): string;
            getFlags(): string;
            getConversion(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formattable{
            formatTo(param0: java.util.Formatter, param1: number, param2: number, param3: number);
        }
        class FormattableFlags{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formatter$BigDecimalLayoutForm{
            static values(): any[];
            static valueOf(param0: string): java.util.Formatter$BigDecimalLayoutForm;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formatter$Conversion{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formatter$DateTime{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formatter$FixedString{
            index(): number;
            toString(): string;
            print(param0: any, param1: java.util.Locale);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formatter$Flags{
            remove(param0: java.util.Formatter$Flags): java.util.Formatter$Flags;
            toString(): string;
            static toString(param0: java.util.Formatter$Flags): string;
            valueOf(): number;
            contains(param0: java.util.Formatter$Flags): boolean;
            static parse(param0: string): java.util.Formatter$Flags;
            dup(): java.util.Formatter$Flags;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formatter$FormatSpecifier$BigDecimalLayout{
            scale(): number;
            hasDot(): boolean;
            layoutChars(): any[];
            mantissa(): any[];
            exponent(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formatter$FormatSpecifier{
            index(): number;
            toString(): string;
            print(param0: any, param1: java.util.Locale);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Formatter$FormatString{
            index(): number;
            toString(): string;
            print(param0: any, param1: java.util.Locale);
        }
        class Formatter{
            toString(): string;
            format(param0: java.util.Locale, param1: string, param2: any[]): java.util.Formatter;
            format(param0: string, param1: any[]): java.util.Formatter;
            out(): java.lang.Appendable;
            flush();
            close();
            locale(): java.util.Locale;
            ioException(): java.io.IOException;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class FormatterClosedException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class GregorianCalendar{
            add(param0: number, param1: number);
            equals(param0: any): boolean;
            hashCode(): number;
            clone(): any;
            static from(param0: java.time.ZonedDateTime): java.util.GregorianCalendar;
            getTimeZone(): java.util.TimeZone;
            setTimeZone(param0: java.util.TimeZone);
            getGregorianChange(): java.util.Date;
            isLeapYear(param0: number): boolean;
            setWeekDate(param0: number, param1: number, param2: number);
            setGregorianChange(param0: java.util.Date);
            isWeekDateSupported(): boolean;
            getCalendarType(): string;
            roll(param0: number, param1: number);
            roll(param0: number, param1: boolean);
            getWeekYear(): number;
            getWeeksInWeekYear(): number;
            getMinimum(param0: number): number;
            getMaximum(param0: number): number;
            getGreatestMinimum(param0: number): number;
            getLeastMaximum(param0: number): number;
            getActualMinimum(param0: number): number;
            getActualMaximum(param0: number): number;
            toZonedDateTime(): java.time.ZonedDateTime;
            get(param0: number): number;
            toString(): string;
            compareTo(param0: java.util.Calendar): number;
            compareTo(param0: any): number;
            clear();
            clear(param0: number);
            static getInstance(): java.util.Calendar;
            static getInstance(param0: java.util.Locale): java.util.Calendar;
            static getInstance(param0: java.util.TimeZone): java.util.Calendar;
            static getInstance(param0: java.util.TimeZone, param1: java.util.Locale): java.util.Calendar;
            isSet(param0: number): boolean;
            set(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number);
            set(param0: number, param1: number);
            set(param0: number, param1: number, param2: number);
            set(param0: number, param1: number, param2: number, param3: number, param4: number);
            before(param0: any): boolean;
            after(param0: any): boolean;
            static getAvailableLocales(): any[];
            getDisplayName(param0: number, param1: number, param2: java.util.Locale): string;
            setTime(param0: java.util.Date);
            getTime(): java.util.Date;
            getDisplayNames(param0: number, param1: number, param2: java.util.Locale): java.util.Map;
            setLenient(param0: boolean);
            static getAvailableCalendarTypes(): java.util.Set;
            setFirstDayOfWeek(param0: number);
            setMinimalDaysInFirstWeek(param0: number);
            setTimeInMillis(param0: number);
            getFirstDayOfWeek(): number;
            getTimeInMillis(): number;
            isLenient(): boolean;
            getMinimalDaysInFirstWeek(): number;
            toInstant(): java.time.Instant;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class HashMap$EntrySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.HashMap$EntrySpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class HashMap$HashMapSpliterator{
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class HashMap$KeySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.HashMap$KeySpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class HashMap$UnsafeHolder{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class HashMap$ValueSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.HashMap$ValueSpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Hashtable$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Hashtable$KeySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class Hashtable$UnsafeHolder{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IdentityHashMap$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IdentityHashMap$EntryIterator$Entry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IdentityHashMap$EntryIterator{
            remove();
            next(): java.util.Map$Entry;
            next(): any;
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class IdentityHashMap$EntrySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            removeAll(param0: java.util.Collection): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class IdentityHashMap$EntrySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.IdentityHashMap$EntrySpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class IdentityHashMap$IdentityHashMapSpliterator{
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IdentityHashMap$KeySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.IdentityHashMap$KeySpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class IdentityHashMap$ValueIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class IdentityHashMap$ValueSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.IdentityHashMap$ValueSpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class IdentityHashMap$Values{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class IllegalFormatCodePointException{
            getMessage(): string;
            getCodePoint(): number;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalFormatConversionException{
            getMessage(): string;
            getConversion(): string;
            getArgumentClass(): java.lang.Class;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalFormatException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalFormatFlagsException{
            getMessage(): string;
            getFlags(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalFormatPrecisionException{
            getMessage(): string;
            getPrecision(): number;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllegalFormatWidthException{
            getMessage(): string;
            getWidth(): number;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IllformedLocaleException{
            getErrorIndex(): number;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class InputMismatchException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class IntSummaryStatistics{
            toString(): string;
            accept(param0: number);
            combine(param0: java.util.IntSummaryStatistics);
            getCount(): number;
            getSum(): number;
            getMin(): number;
            getMax(): number;
            getAverage(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
        }
        class InvalidPropertiesFormatException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class JapaneseImperialCalendar{
            add(param0: number, param1: number);
            equals(param0: any): boolean;
            hashCode(): number;
            clone(): any;
            getDisplayName(param0: number, param1: number, param2: java.util.Locale): string;
            getTimeZone(): java.util.TimeZone;
            setTimeZone(param0: java.util.TimeZone);
            getDisplayNames(param0: number, param1: number, param2: java.util.Locale): java.util.Map;
            getCalendarType(): string;
            roll(param0: number, param1: boolean);
            roll(param0: number, param1: number);
            getMinimum(param0: number): number;
            getMaximum(param0: number): number;
            getGreatestMinimum(param0: number): number;
            getLeastMaximum(param0: number): number;
            getActualMinimum(param0: number): number;
            getActualMaximum(param0: number): number;
            get(param0: number): number;
            toString(): string;
            compareTo(param0: java.util.Calendar): number;
            compareTo(param0: any): number;
            clear();
            clear(param0: number);
            static getInstance(): java.util.Calendar;
            static getInstance(param0: java.util.Locale): java.util.Calendar;
            static getInstance(param0: java.util.TimeZone): java.util.Calendar;
            static getInstance(param0: java.util.TimeZone, param1: java.util.Locale): java.util.Calendar;
            isSet(param0: number): boolean;
            set(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number);
            set(param0: number, param1: number);
            set(param0: number, param1: number, param2: number);
            set(param0: number, param1: number, param2: number, param3: number, param4: number);
            before(param0: any): boolean;
            after(param0: any): boolean;
            static getAvailableLocales(): any[];
            setTime(param0: java.util.Date);
            getTime(): java.util.Date;
            setWeekDate(param0: number, param1: number, param2: number);
            setLenient(param0: boolean);
            static getAvailableCalendarTypes(): java.util.Set;
            setFirstDayOfWeek(param0: number);
            setMinimalDaysInFirstWeek(param0: number);
            setTimeInMillis(param0: number);
            isWeekDateSupported(): boolean;
            getFirstDayOfWeek(): number;
            getTimeInMillis(): number;
            isLenient(): boolean;
            getMinimalDaysInFirstWeek(): number;
            getWeekYear(): number;
            getWeeksInWeekYear(): number;
            toInstant(): java.time.Instant;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class JumboEnumSet$EnumSetIterator{
            remove();
            hasNext(): boolean;
            next(): any;
            next(): java.lang.Enum;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class JumboEnumSet{
            add(param0: java.lang.Enum): boolean;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            clone(): java.util.EnumSet;
            clone(): any;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            static copyOf(param0: java.util.EnumSet): java.util.EnumSet;
            static copyOf(param0: java.util.Collection): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum, param3: java.lang.Enum, param4: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: any[]): java.util.EnumSet;
            static of(param0: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum, param3: java.lang.Enum): java.util.EnumSet;
            static range(param0: java.lang.Enum, param1: java.lang.Enum): java.util.EnumSet;
            static noneOf(param0: java.lang.Class): java.util.EnumSet;
            static allOf(param0: java.lang.Class): java.util.EnumSet;
            static complementOf(param0: java.util.EnumSet): java.util.EnumSet;
            hashCode(): number;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class LinkedHashMap$LinkedValueIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class LinkedHashMap$LinkedValues{
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
        }
        class LinkedList$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class LinkedList$DescendingIterator{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class LinkedList$LLSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Locale$Builder{
            clear(): java.util.Locale$Builder;
            setLanguageTag(param0: string): java.util.Locale$Builder;
            build(): java.util.Locale;
            setLocale(param0: java.util.Locale): java.util.Locale$Builder;
            setLanguage(param0: string): java.util.Locale$Builder;
            setScript(param0: string): java.util.Locale$Builder;
            setRegion(param0: string): java.util.Locale$Builder;
            setVariant(param0: string): java.util.Locale$Builder;
            setExtension(param0: string, param1: string): java.util.Locale$Builder;
            setUnicodeLocaleKeyword(param0: string, param1: string): java.util.Locale$Builder;
            addUnicodeLocaleAttribute(param0: string): java.util.Locale$Builder;
            removeUnicodeLocaleAttribute(param0: string): java.util.Locale$Builder;
            clearExtensions(): java.util.Locale$Builder;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Locale$FilteringMode{
            static values(): any[];
            static valueOf(param0: string): java.util.Locale$FilteringMode;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Locale$LanguageRange{
            equals(param0: any): boolean;
            hashCode(): number;
            static parse(param0: string): java.util.List;
            static parse(param0: string, param1: java.util.Map): java.util.List;
            getRange(): string;
            getWeight(): number;
            static mapEquivalents(param0: java.util.List, param1: java.util.Map): java.util.List;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            toString(): string;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Locale$LocaleNameGetter{
            getObject(param0: java.util.spi.LocaleNameProvider, param1: java.util.Locale, param2: string, param3: any[]): string;
            getObject(param0: java.util.spi.LocaleServiceProvider, param1: java.util.Locale, param2: string, param3: any[]): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class LocaleISOData{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class LongSummaryStatistics{
            toString(): string;
            accept(param0: number);
            accept(param0: number);
            combine(param0: java.util.LongSummaryStatistics);
            getCount(): number;
            getSum(): number;
            getMin(): number;
            getMax(): number;
            getAverage(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
        }
        class MissingFormatArgumentException{
            getMessage(): string;
            getFormatSpecifier(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class MissingFormatWidthException{
            getMessage(): string;
            getFormatSpecifier(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NoSuchElementException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Observable{
            addObserver(param0: java.util.Observer);
            deleteObserver(param0: java.util.Observer);
            notifyObservers(param0: any);
            notifyObservers();
            deleteObservers();
            hasChanged(): boolean;
            countObservers(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Observer{
            update(param0: java.util.Observable, param1: any);
        }
        class Optional{
            get(): any;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            isPresent(): boolean;
            static of(param0: any): java.util.Optional;
            static empty(): java.util.Optional;
            filter(param0: java.util.function.Predicate): java.util.Optional;
            map(param0: java.util.function.Function): java.util.Optional;
            flatMap(param0: java.util.function.Function): java.util.Optional;
            orElse(param0: any): any;
            static ofNullable(param0: any): java.util.Optional;
            ifPresent(param0: java.util.function.Consumer);
            orElseGet(param0: java.util.function.Supplier): any;
            orElseThrow(param0: java.util.function.Supplier): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class OptionalDouble{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            isPresent(): boolean;
            static of(param0: number): java.util.OptionalDouble;
            static empty(): java.util.OptionalDouble;
            orElse(param0: number): number;
            ifPresent(param0: java.util.function.DoubleConsumer);
            orElseGet(param0: java.util.function.DoubleSupplier): number;
            orElseThrow(param0: java.util.function.Supplier): number;
            getAsDouble(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class OptionalInt{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            isPresent(): boolean;
            static of(param0: number): java.util.OptionalInt;
            static empty(): java.util.OptionalInt;
            orElse(param0: number): number;
            ifPresent(param0: java.util.function.IntConsumer);
            orElseGet(param0: java.util.function.IntSupplier): number;
            orElseThrow(param0: java.util.function.Supplier): number;
            getAsInt(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class OptionalLong{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            isPresent(): boolean;
            static of(param0: number): java.util.OptionalLong;
            static empty(): java.util.OptionalLong;
            orElse(param0: number): number;
            ifPresent(param0: java.util.function.LongConsumer);
            orElseGet(param0: java.util.function.LongSupplier): number;
            orElseThrow(param0: java.util.function.Supplier): number;
            getAsLong(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class PrimitiveIterator$OfDouble{
            next(): any;
            next(): number;
            nextDouble(): number;
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.Consumer);
            remove();
            hasNext(): boolean;
        }
        class PrimitiveIterator$OfInt{
            next(): any;
            next(): number;
            nextInt(): number;
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.Consumer);
            remove();
            hasNext(): boolean;
        }
        class PrimitiveIterator$OfLong{
            next(): number;
            next(): any;
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.Consumer);
            forEachRemaining(param0: java.util.function.LongConsumer);
            nextLong(): number;
            remove();
            hasNext(): boolean;
        }
        class PrimitiveIterator{
            forEachRemaining(param0: any);
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class PriorityQueue$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class PriorityQueue$Itr{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class PriorityQueue$PriorityQueueSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.PriorityQueue$PriorityQueueSpliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Properties$XmlSupport$1{
            run(): sun.util.spi.XmlPropertiesProvider;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Properties$XmlSupport{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class PropertyPermission{
            equals(param0: any): boolean;
            hashCode(): number;
            implies(param0: java.security.Permission): boolean;
            getActions(): string;
            newPermissionCollection(): java.security.PermissionCollection;
            toString(): string;
            getName(): string;
            checkGuard(param0: any);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class PropertyPermissionCollection{
            add(param0: java.security.Permission);
            implies(param0: java.security.Permission): boolean;
            elements(): java.util.Enumeration;
            toString(): string;
            setReadOnly();
            isReadOnly(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Random$RandomDoublesSpliterator{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Random$RandomDoublesSpliterator;
            trySplit(): java.util.Spliterator$OfDouble;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Random$RandomIntsSpliterator{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.IntConsumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.IntConsumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Random$RandomIntsSpliterator;
            trySplit(): java.util.Spliterator$OfInt;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Random$RandomLongsSpliterator{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.LongConsumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.LongConsumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Random$RandomLongsSpliterator;
            trySplit(): java.util.Spliterator$OfLong;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class RandomAccessSubList{
            subList(param0: number, param1: number): java.util.List;
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            size(): number;
            iterator(): java.util.Iterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            addAll(param0: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            add(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            clear();
            lastIndexOf(param0: any): number;
            listIterator(): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            replaceAll(param0: java.util.function.UnaryOperator);
            spliterator(): java.util.Spliterator;
            sort(param0: java.util.Comparator);
        }
        class RegularEnumSet$EnumSetIterator{
            remove();
            hasNext(): boolean;
            next(): any;
            next(): java.lang.Enum;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class RegularEnumSet{
            add(param0: java.lang.Enum): boolean;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            clone(): any;
            clone(): java.util.EnumSet;
            static copyOf(param0: java.util.EnumSet): java.util.EnumSet;
            static copyOf(param0: java.util.Collection): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum, param3: java.lang.Enum, param4: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: any[]): java.util.EnumSet;
            static of(param0: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum): java.util.EnumSet;
            static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum, param3: java.lang.Enum): java.util.EnumSet;
            static range(param0: java.lang.Enum, param1: java.lang.Enum): java.util.EnumSet;
            static noneOf(param0: java.lang.Class): java.util.EnumSet;
            static allOf(param0: java.lang.Class): java.util.EnumSet;
            static complementOf(param0: java.util.EnumSet): java.util.EnumSet;
            hashCode(): number;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class ResourceBundle$NoFallbackControl{
            getFallbackLocale(param0: string, param1: java.util.Locale): java.util.Locale;
            getFormats(param0: string): java.util.List;
            static getNoFallbackControl(param0: java.util.List): java.util.ResourceBundle$Control;
            getCandidateLocales(param0: string, param1: java.util.Locale): java.util.List;
            static getControl(param0: java.util.List): java.util.ResourceBundle$Control;
            newBundle(param0: string, param1: java.util.Locale, param2: string, param3: java.lang.ClassLoader, param4: boolean): java.util.ResourceBundle;
            getTimeToLive(param0: string, param1: java.util.Locale): number;
            needsReload(param0: string, param1: java.util.Locale, param2: string, param3: java.lang.ClassLoader, param4: java.util.ResourceBundle, param5: number): boolean;
            toBundleName(param0: string, param1: java.util.Locale): string;
            toResourceName(param0: string, param1: string): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Scanner$1{
            forName(param0: any): any;
            static moveToFront(param0: any[], param1: number);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Scanner{
            remove();
            toString(): string;
            hasNext(param0: string): boolean;
            hasNext(param0: java.util.regex.Pattern): boolean;
            hasNext(): boolean;
            next(): string;
            next(param0: string): string;
            next(param0: java.util.regex.Pattern): string;
            next(): any;
            close();
            skip(param0: string): java.util.Scanner;
            skip(param0: java.util.regex.Pattern): java.util.Scanner;
            reset(): java.util.Scanner;
            nextInt(): number;
            nextInt(param0: number): number;
            nextDouble(): number;
            match(): java.util.regex.MatchResult;
            locale(): java.util.Locale;
            ioException(): java.io.IOException;
            radix(): number;
            delimiter(): java.util.regex.Pattern;
            useDelimiter(param0: string): java.util.Scanner;
            useDelimiter(param0: java.util.regex.Pattern): java.util.Scanner;
            useLocale(param0: java.util.Locale): java.util.Scanner;
            useRadix(param0: number): java.util.Scanner;
            hasNextLine(): boolean;
            nextLine(): string;
            findInLine(param0: string): string;
            findInLine(param0: java.util.regex.Pattern): string;
            findWithinHorizon(param0: string, param1: number): string;
            findWithinHorizon(param0: java.util.regex.Pattern, param1: number): string;
            hasNextBoolean(): boolean;
            nextBoolean(): boolean;
            hasNextByte(param0: number): boolean;
            hasNextByte(): boolean;
            nextByte(param0: number): number;
            nextByte(): number;
            hasNextShort(): boolean;
            hasNextShort(param0: number): boolean;
            nextShort(): number;
            nextShort(param0: number): number;
            hasNextInt(param0: number): boolean;
            hasNextInt(): boolean;
            hasNextLong(param0: number): boolean;
            hasNextLong(): boolean;
            hasNextFloat(): boolean;
            nextFloat(): number;
            hasNextDouble(): boolean;
            hasNextBigInteger(param0: number): boolean;
            hasNextBigInteger(): boolean;
            nextBigInteger(): java.math.BigInteger;
            nextBigInteger(param0: number): java.math.BigInteger;
            hasNextBigDecimal(): boolean;
            nextBigDecimal(): java.math.BigDecimal;
            nextLong(): number;
            nextLong(param0: number): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class ServiceConfigurationError{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ServiceLoader$LazyIterator$1{
            run(): boolean;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ServiceLoader$LazyIterator$2{
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SimpleTimeZone{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clone(): any;
            getOffset(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number): number;
            getOffset(param0: number): number;
            setStartYear(param0: number);
            setStartRule(param0: number, param1: number, param2: number, param3: number);
            setStartRule(param0: number, param1: number, param2: number);
            setStartRule(param0: number, param1: number, param2: number, param3: number, param4: boolean);
            setEndRule(param0: number, param1: number, param2: number, param3: number, param4: boolean);
            setEndRule(param0: number, param1: number, param2: number);
            setEndRule(param0: number, param1: number, param2: number, param3: number);
            setDSTSavings(param0: number);
            setRawOffset(param0: number);
            getRawOffset(): number;
            useDaylightTime(): boolean;
            observesDaylightTime(): boolean;
            inDaylightTime(param0: java.util.Date): boolean;
            getDSTSavings(): number;
            hasSameRules(param0: java.util.TimeZone): boolean;
            static getDefault(): java.util.TimeZone;
            static setDefault(param0: java.util.TimeZone);
            getDisplayName(param0: boolean, param1: number): string;
            getDisplayName(param0: boolean, param1: number, param2: java.util.Locale): string;
            getDisplayName(): string;
            getDisplayName(param0: java.util.Locale): string;
            getID(): string;
            static getTimeZone(param0: string): java.util.TimeZone;
            static getTimeZone(param0: java.time.ZoneId): java.util.TimeZone;
            static getAvailableIDs(param0: number): any[];
            static getAvailableIDs(): any[];
            setID(param0: string);
            toZoneId(): java.time.ZoneId;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SortedSet$1{
            getComparator(): java.util.Comparator;
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterator$OfDouble{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.Consumer): boolean;
            tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfDouble;
            estimateSize(): number;
            getExactSizeIfKnown(): number;
            characteristics(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterator$OfInt{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.Consumer): boolean;
            tryAdvance(param0: java.util.function.IntConsumer): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfInt;
            estimateSize(): number;
            getExactSizeIfKnown(): number;
            characteristics(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterator$OfLong{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.LongConsumer);
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.Consumer): boolean;
            tryAdvance(param0: java.util.function.LongConsumer): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfLong;
            estimateSize(): number;
            getExactSizeIfKnown(): number;
            characteristics(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterator$OfPrimitive{
            forEachRemaining(param0: any);
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfPrimitive;
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            estimateSize(): number;
            getExactSizeIfKnown(): number;
            characteristics(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            getExactSizeIfKnown(): number;
            characteristics(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$1Adapter{
            hasNext(): boolean;
            next(): any;
            accept(param0: any);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove();
            forEachRemaining(param0: java.util.function.Consumer);
            andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
        }
        class Spliterators$2Adapter{
            hasNext(): boolean;
            accept(param0: number);
            nextInt(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            next(): number;
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.Consumer);
            remove();
            andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
        }
        class Spliterators$3Adapter{
            hasNext(): boolean;
            accept(param0: number);
            nextLong(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): number;
            next(): any;
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.Consumer);
            forEachRemaining(param0: java.util.function.LongConsumer);
            remove();
            andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
        }
        class Spliterators$4Adapter{
            hasNext(): boolean;
            accept(param0: number);
            nextDouble(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            next(): number;
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.Consumer);
            remove();
            andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
        }
        class Spliterators$AbstractDoubleSpliterator$HoldingDoubleConsumer{
            accept(param0: number);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
        }
        class Spliterators$AbstractDoubleSpliterator{
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfDouble;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.Consumer): boolean;
            tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$AbstractIntSpliterator$HoldingIntConsumer{
            accept(param0: number);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
        }
        class Spliterators$AbstractIntSpliterator{
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfInt;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.Consumer): boolean;
            tryAdvance(param0: java.util.function.IntConsumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$AbstractLongSpliterator$HoldingLongConsumer{
            accept(param0: number);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
        }
        class Spliterators$AbstractLongSpliterator{
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfLong;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.LongConsumer);
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.Consumer): boolean;
            tryAdvance(param0: java.util.function.LongConsumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$AbstractSpliterator$HoldingConsumer{
            accept(param0: any);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
        }
        class Spliterators$AbstractSpliterator{
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$ArraySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterators$DoubleArraySpliterator{
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            forEachRemaining(param0: any);
            tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfDouble;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterators$DoubleIteratorSpliterator{
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            forEachRemaining(param0: any);
            tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfDouble;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterators$EmptySpliterator$OfDouble{
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
            trySplit(): java.util.Spliterator$OfDouble;
            trySplit(): java.util.Spliterator$OfPrimitive;
            forEachRemaining(param0: any);
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$EmptySpliterator$OfInt{
            forEachRemaining(param0: java.util.function.IntConsumer);
            tryAdvance(param0: java.util.function.IntConsumer): boolean;
            trySplit(): java.util.Spliterator$OfInt;
            trySplit(): java.util.Spliterator$OfPrimitive;
            forEachRemaining(param0: any);
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$EmptySpliterator$OfLong{
            forEachRemaining(param0: java.util.function.LongConsumer);
            tryAdvance(param0: java.util.function.LongConsumer): boolean;
            trySplit(): java.util.Spliterator$OfLong;
            trySplit(): java.util.Spliterator$OfPrimitive;
            forEachRemaining(param0: any);
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$EmptySpliterator$OfRef{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            forEachRemaining(param0: any);
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class Spliterators$EmptySpliterator{
            forEachRemaining(param0: any);
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Spliterators$IntArraySpliterator{
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: any);
            tryAdvance(param0: java.util.function.IntConsumer): boolean;
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfInt;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterators$IntIteratorSpliterator{
            forEachRemaining(param0: java.util.function.IntConsumer);
            forEachRemaining(param0: any);
            tryAdvance(param0: java.util.function.IntConsumer): boolean;
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfInt;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterators$IteratorSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterators$LongArraySpliterator{
            forEachRemaining(param0: java.util.function.LongConsumer);
            forEachRemaining(param0: any);
            tryAdvance(param0: java.util.function.LongConsumer): boolean;
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfLong;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterators$LongIteratorSpliterator{
            forEachRemaining(param0: java.util.function.LongConsumer);
            forEachRemaining(param0: any);
            tryAdvance(param0: java.util.function.LongConsumer): boolean;
            tryAdvance(param0: any): boolean;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfLong;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class Spliterators{
            static iterator(param0: java.util.Spliterator): java.util.Iterator;
            static iterator(param0: java.util.Spliterator$OfInt): java.util.PrimitiveIterator$OfInt;
            static iterator(param0: java.util.Spliterator$OfLong): java.util.PrimitiveIterator$OfLong;
            static iterator(param0: java.util.Spliterator$OfDouble): java.util.PrimitiveIterator$OfDouble;
            static spliteratorUnknownSize(param0: java.util.PrimitiveIterator$OfInt, param1: number): java.util.Spliterator$OfInt;
            static spliteratorUnknownSize(param0: java.util.PrimitiveIterator$OfLong, param1: number): java.util.Spliterator$OfLong;
            static spliteratorUnknownSize(param0: java.util.Iterator, param1: number): java.util.Spliterator;
            static spliteratorUnknownSize(param0: java.util.PrimitiveIterator$OfDouble, param1: number): java.util.Spliterator$OfDouble;
            static spliterator(param0: java.util.Collection, param1: number): java.util.Spliterator;
            static spliterator(param0: java.util.PrimitiveIterator$OfInt, param1: number, param2: number): java.util.Spliterator$OfInt;
            static spliterator(param0: java.util.PrimitiveIterator$OfDouble, param1: number, param2: number): java.util.Spliterator$OfDouble;
            static spliterator(param0: java.util.PrimitiveIterator$OfLong, param1: number, param2: number): java.util.Spliterator$OfLong;
            static spliterator(param0: any[], param1: number, param2: number, param3: number): java.util.Spliterator$OfLong;
            static spliterator(param0: any[], param1: number): java.util.Spliterator$OfLong;
            static spliterator(param0: any[], param1: number, param2: number, param3: number): java.util.Spliterator$OfInt;
            static spliterator(param0: any[], param1: number): java.util.Spliterator;
            static spliterator(param0: any[], param1: number, param2: number, param3: number): java.util.Spliterator;
            static spliterator(param0: any[], param1: number): java.util.Spliterator$OfInt;
            static spliterator(param0: java.util.Iterator, param1: number, param2: number): java.util.Spliterator;
            static spliterator(param0: any[], param1: number, param2: number, param3: number): java.util.Spliterator$OfDouble;
            static spliterator(param0: any[], param1: number): java.util.Spliterator$OfDouble;
            static emptySpliterator(): java.util.Spliterator;
            static emptyIntSpliterator(): java.util.Spliterator$OfInt;
            static emptyLongSpliterator(): java.util.Spliterator$OfLong;
            static emptyDoubleSpliterator(): java.util.Spliterator$OfDouble;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SplittableRandom$RandomDoublesSpliterator{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.DoubleConsumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.SplittableRandom$RandomDoublesSpliterator;
            trySplit(): java.util.Spliterator$OfDouble;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class SplittableRandom$RandomIntsSpliterator{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.IntConsumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.IntConsumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.SplittableRandom$RandomIntsSpliterator;
            trySplit(): java.util.Spliterator$OfInt;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class SplittableRandom$RandomLongsSpliterator{
            forEachRemaining(param0: any);
            forEachRemaining(param0: java.util.function.LongConsumer);
            tryAdvance(param0: any): boolean;
            tryAdvance(param0: java.util.function.LongConsumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.Spliterator$OfPrimitive;
            trySplit(): java.util.SplittableRandom$RandomLongsSpliterator;
            trySplit(): java.util.Spliterator$OfLong;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class SplittableRandom{
            split(): java.util.SplittableRandom;
            nextInt(param0: number): number;
            nextInt(param0: number, param1: number): number;
            nextInt(): number;
            nextDouble(param0: number): number;
            nextDouble(): number;
            nextDouble(param0: number, param1: number): number;
            nextBoolean(): boolean;
            ints(param0: number, param1: number, param2: number): java.util.stream.IntStream;
            ints(param0: number): java.util.stream.IntStream;
            ints(): java.util.stream.IntStream;
            ints(param0: number, param1: number): java.util.stream.IntStream;
            longs(param0: number): java.util.stream.LongStream;
            longs(): java.util.stream.LongStream;
            longs(param0: number, param1: number, param2: number): java.util.stream.LongStream;
            longs(param0: number, param1: number): java.util.stream.LongStream;
            doubles(): java.util.stream.DoubleStream;
            doubles(param0: number, param1: number, param2: number): java.util.stream.DoubleStream;
            doubles(param0: number, param1: number): java.util.stream.DoubleStream;
            doubles(param0: number): java.util.stream.DoubleStream;
            nextLong(param0: number, param1: number): number;
            nextLong(): number;
            nextLong(param0: number): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StringJoiner{
            add(param0: java.lang.CharSequence): java.util.StringJoiner;
            toString(): string;
            length(): number;
            merge(param0: java.util.StringJoiner): java.util.StringJoiner;
            setEmptyValue(param0: java.lang.CharSequence): java.util.StringJoiner;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class SubList$1{
            add(param0: any);
            remove();
            hasNext(): boolean;
            next(): any;
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class SubList{
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            size(): number;
            subList(param0: number, param1: number): java.util.List;
            iterator(): java.util.Iterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            addAll(param0: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            add(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            clear();
            lastIndexOf(param0: any): number;
            listIterator(): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            replaceAll(param0: java.util.function.UnaryOperator);
            spliterator(): java.util.Spliterator;
            sort(param0: java.util.Comparator);
        }
        class TaskQueue{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Timer$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Timer{
            cancel();
            schedule(param0: java.util.TimerTask, param1: number, param2: number);
            schedule(param0: java.util.TimerTask, param1: java.util.Date);
            schedule(param0: java.util.TimerTask, param1: number);
            schedule(param0: java.util.TimerTask, param1: java.util.Date, param2: number);
            scheduleAtFixedRate(param0: java.util.TimerTask, param1: number, param2: number);
            scheduleAtFixedRate(param0: java.util.TimerTask, param1: java.util.Date, param2: number);
            purge(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TimerTask{
            run();
            cancel(): boolean;
            scheduledExecutionTime(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TimerThread{
            run();
            toString(): string;
            isInterrupted(): boolean;
            static currentThread(): java.lang.Thread;
            getName(): string;
            join(param0: number);
            join(param0: number, param1: number);
            join();
            getThreadGroup(): java.lang.ThreadGroup;
            getStackTrace(): any[];
            static holdsLock(param0: any): boolean;
            checkAccess();
            static dumpStack();
            static yield();
            setPriority(param0: number);
            setDaemon(param0: boolean);
            start();
            static sleep(param0: number, param1: number);
            static sleep(param0: number);
            stop();
            stop(param0: java.lang.Throwable);
            interrupt();
            static interrupted(): boolean;
            destroy();
            isAlive(): boolean;
            suspend();
            resume();
            getPriority(): number;
            setName(param0: string);
            static activeCount(): number;
            static enumerate(param0: any[]): number;
            countStackFrames(): number;
            isDaemon(): boolean;
            getContextClassLoader(): java.lang.ClassLoader;
            setContextClassLoader(param0: java.lang.ClassLoader);
            static getAllStackTraces(): java.util.Map;
            getId(): number;
            getState(): java.lang.Thread$State;
            static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
            static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
            getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
            setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TooManyListenersException{
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TreeMap$AscendingSubMap$AscendingEntrySetView{
            iterator(): java.util.Iterator;
            remove(param0: any): boolean;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            clear();
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class TreeMap$AscendingSubMap{
            entrySet(): java.util.Set;
            descendingMap(): java.util.NavigableMap;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            isEmpty(): boolean;
            size(): number;
            keySet(): java.util.Set;
            containsKey(param0: any): boolean;
            firstKey(): any;
            lastKey(): any;
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            navigableKeySet(): java.util.NavigableSet;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            putAll(param0: java.util.Map);
            containsValue(param0: any): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class TreeMap$DescendingKeyIterator{
            remove();
            next(): any;
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class TreeMap$DescendingKeySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.TreeMap$DescendingKeySpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class TreeMap$DescendingSubMap$DescendingEntrySetView{
            iterator(): java.util.Iterator;
            remove(param0: any): boolean;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            clear();
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class TreeMap$DescendingSubMap{
            entrySet(): java.util.Set;
            descendingMap(): java.util.NavigableMap;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            isEmpty(): boolean;
            size(): number;
            keySet(): java.util.Set;
            containsKey(param0: any): boolean;
            firstKey(): any;
            lastKey(): any;
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            navigableKeySet(): java.util.NavigableSet;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            putAll(param0: java.util.Map);
            containsValue(param0: any): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class TreeMap$EntryIterator{
            next(): java.util.Map$Entry;
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class TreeMap$EntrySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class TreeMap$EntrySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.TreeMap$EntrySpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class TreeMap$KeySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            trySplit(): java.util.TreeMap$KeySpliterator;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class TreeMap$NavigableSubMap$DescendingSubMapEntryIterator{
            remove();
            next(): java.util.Map$Entry;
            next(): any;
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class TreeMap$NavigableSubMap$DescendingSubMapKeyIterator{
            remove();
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class TreeMap$NavigableSubMap$EntrySetView{
            remove(param0: any): boolean;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            clear();
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
        }
        class TreeMap$NavigableSubMap$SubMapEntryIterator{
            remove();
            next(): java.util.Map$Entry;
            next(): any;
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class TreeMap$NavigableSubMap$SubMapIterator{
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove();
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class TreeMap$NavigableSubMap$SubMapKeyIterator{
            remove();
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            getComparator(): java.util.Comparator;
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
        }
        class TreeMap$NavigableSubMap{
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            isEmpty(): boolean;
            size(): number;
            keySet(): java.util.Set;
            containsKey(param0: any): boolean;
            firstKey(): any;
            lastKey(): any;
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            navigableKeySet(): java.util.NavigableSet;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            containsValue(param0: any): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            descendingMap(): java.util.NavigableMap;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            entrySet(): java.util.Set;
            comparator(): java.util.Comparator;
        }
        class TreeMap$SubMap{
            entrySet(): java.util.Set;
            firstKey(): any;
            lastKey(): any;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            size(): number;
            putAll(param0: java.util.Map);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class TreeMap$TreeMapSpliterator{
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TreeMap$ValueIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class TreeMap$ValueSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.TreeMap$ValueSpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class TreeMap$Values{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class Tripwire{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UUID$Holder{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UUID{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.util.UUID): number;
            timestamp(): number;
            version(): number;
            variant(): number;
            node(): number;
            static randomUUID(): java.util.UUID;
            static nameUUIDFromBytes(param0: any[]): java.util.UUID;
            static fromString(param0: string): java.util.UUID;
            getLeastSignificantBits(): number;
            getMostSignificantBits(): number;
            clockSequence(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UnknownFormatConversionException{
            getMessage(): string;
            getConversion(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class UnknownFormatFlagsException{
            getMessage(): string;
            getFlags(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Vector$VectorSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.Spliterator;
            estimateSize(): number;
            characteristics(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class WeakHashMap$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class WeakHashMap$EntryIterator{
            next(): java.util.Map$Entry;
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class WeakHashMap$EntrySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class WeakHashMap$EntrySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.WeakHashMap$EntrySpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class WeakHashMap$KeySpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.WeakHashMap$KeySpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class WeakHashMap$ValueIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class WeakHashMap$ValueSpliterator{
            forEachRemaining(param0: java.util.function.Consumer);
            tryAdvance(param0: java.util.function.Consumer): boolean;
            trySplit(): java.util.WeakHashMap$ValueSpliterator;
            trySplit(): java.util.Spliterator;
            characteristics(): number;
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            getExactSizeIfKnown(): number;
            hasCharacteristics(param0: number): boolean;
            getComparator(): java.util.Comparator;
        }
        class WeakHashMap$Values{
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class WeakHashMap$WeakHashMapSpliterator{
            estimateSize(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        namespace concurrent{
            class ArrayBlockingQueue$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ArrayBlockingQueue$Itrs$Node{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ArrayBlockingQueue$Itrs{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ArrayBlockingQueue{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                put(param0: any);
                toString(): string;
                clear();
                contains(param0: any): boolean;
                size(): number;
                toArray(): any[];
                toArray(param0: any[]): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                poll(): any;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                peek(): any;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offer(param0: any): boolean;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                drainTo(param0: java.util.Collection): number;
                remove(): any;
                addAll(param0: java.util.Collection): boolean;
                element(): any;
                isEmpty(): boolean;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class BlockingDeque{
                add(param0: any): boolean;
                remove(): any;
                remove(param0: any): boolean;
                put(param0: any);
                contains(param0: any): boolean;
                size(): number;
                iterator(): java.util.Iterator;
                push(param0: any);
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                poll(): any;
                peek(): any;
                addFirst(param0: any);
                addLast(param0: any);
                offerFirst(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offerFirst(param0: any): boolean;
                offerLast(param0: any): boolean;
                offerLast(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                pollFirst(param0: number, param1: java.util.concurrent.TimeUnit): any;
                pollLast(param0: number, param1: java.util.concurrent.TimeUnit): any;
                removeFirstOccurrence(param0: any): boolean;
                removeLastOccurrence(param0: any): boolean;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offer(param0: any): boolean;
                element(): any;
                take(): any;
                putFirst(param0: any);
                putLast(param0: any);
                takeFirst(): any;
                takeLast(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                equals(param0: any): boolean;
                hashCode(): number;
                clear();
                isEmpty(): boolean;
                toArray(param0: any[]): any[];
                toArray(): any[];
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                stream(): java.util.stream.Stream;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
                getFirst(): any;
                pop(): any;
                removeFirst(): any;
                pollFirst(): any;
                pollLast(): any;
                getLast(): any;
                peekFirst(): any;
                descendingIterator(): java.util.Iterator;
                peekLast(): any;
                removeLast(): any;
            }
            class BrokenBarrierException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Callable{
                call(): any;
            }
            class CancellationException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$AltResult{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$AsyncRun{
                run();
                exec(): boolean;
                run$$$capture();
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$AsyncSupply{
                run();
                exec(): boolean;
                run$$$capture();
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$AsynchronousCompletionTask{
            }
            class CompletableFuture$BiAccept{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$BiApply{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$BiCompletion{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$BiRelay{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$BiRun{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$CoCompletion{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$Completion{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$OrAccept{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$OrApply{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$OrRelay{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$OrRun{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$Signaller{
                isReleasable(): boolean;
                block(): boolean;
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$ThreadPerTaskExecutor{
                execute(param0: java.lang.Runnable);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniAccept{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniApply{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniCompletion{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniCompose{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniExceptionally{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniHandle{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniRelay{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniRun{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture$UniWhenComplete{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletableFuture{
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                toString(): string;
                join(): any;
                handle(param0: java.util.function.BiFunction): java.util.concurrent.CompletionStage;
                handle(param0: java.util.function.BiFunction): java.util.concurrent.CompletableFuture;
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                completeExceptionally(param0: java.lang.Throwable): boolean;
                static supplyAsync(param0: java.util.function.Supplier, param1: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                static supplyAsync(param0: java.util.function.Supplier): java.util.concurrent.CompletableFuture;
                static runAsync(param0: java.lang.Runnable, param1: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                static runAsync(param0: java.lang.Runnable): java.util.concurrent.CompletableFuture;
                static completedFuture(param0: any): java.util.concurrent.CompletableFuture;
                getNow(param0: any): any;
                thenApply(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                thenApply(param0: java.util.function.Function): java.util.concurrent.CompletableFuture;
                thenApplyAsync(param0: java.util.function.Function): java.util.concurrent.CompletableFuture;
                thenApplyAsync(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                thenApplyAsync(param0: java.util.function.Function, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenApplyAsync(param0: java.util.function.Function, param1: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                thenAccept(param0: java.util.function.Consumer): java.util.concurrent.CompletableFuture;
                thenAccept(param0: java.util.function.Consumer): java.util.concurrent.CompletionStage;
                thenAcceptAsync(param0: java.util.function.Consumer): java.util.concurrent.CompletableFuture;
                thenAcceptAsync(param0: java.util.function.Consumer, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenAcceptAsync(param0: java.util.function.Consumer): java.util.concurrent.CompletionStage;
                thenAcceptAsync(param0: java.util.function.Consumer, param1: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                thenRun(param0: java.lang.Runnable): java.util.concurrent.CompletableFuture;
                thenRun(param0: java.lang.Runnable): java.util.concurrent.CompletionStage;
                thenRunAsync(param0: java.lang.Runnable, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenRunAsync(param0: java.lang.Runnable, param1: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                thenRunAsync(param0: java.lang.Runnable): java.util.concurrent.CompletableFuture;
                thenRunAsync(param0: java.lang.Runnable): java.util.concurrent.CompletionStage;
                thenCombine(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction): java.util.concurrent.CompletionStage;
                thenCombine(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction): java.util.concurrent.CompletableFuture;
                thenCombineAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction): java.util.concurrent.CompletableFuture;
                thenCombineAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction, param2: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                thenCombineAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenCombineAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction): java.util.concurrent.CompletionStage;
                thenAcceptBoth(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer): java.util.concurrent.CompletableFuture;
                thenAcceptBoth(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer): java.util.concurrent.CompletionStage;
                thenAcceptBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenAcceptBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer): java.util.concurrent.CompletionStage;
                thenAcceptBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer, param2: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                thenAcceptBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer): java.util.concurrent.CompletableFuture;
                runAfterBoth(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletableFuture;
                runAfterBoth(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletionStage;
                runAfterBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                runAfterBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletionStage;
                runAfterBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable, param2: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                runAfterBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletableFuture;
                applyToEither(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function): java.util.concurrent.CompletionStage;
                applyToEither(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function): java.util.concurrent.CompletableFuture;
                applyToEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function): java.util.concurrent.CompletionStage;
                applyToEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function): java.util.concurrent.CompletableFuture;
                applyToEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function, param2: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                applyToEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                acceptEither(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer): java.util.concurrent.CompletionStage;
                acceptEither(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer): java.util.concurrent.CompletableFuture;
                acceptEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer): java.util.concurrent.CompletionStage;
                acceptEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer): java.util.concurrent.CompletableFuture;
                acceptEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                acceptEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer, param2: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                runAfterEither(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletionStage;
                runAfterEither(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletableFuture;
                runAfterEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletableFuture;
                runAfterEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable, param2: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                runAfterEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletionStage;
                runAfterEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenCompose(param0: java.util.function.Function): java.util.concurrent.CompletableFuture;
                thenCompose(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                thenComposeAsync(param0: java.util.function.Function, param1: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                thenComposeAsync(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                thenComposeAsync(param0: java.util.function.Function, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenComposeAsync(param0: java.util.function.Function): java.util.concurrent.CompletableFuture;
                whenComplete(param0: java.util.function.BiConsumer): java.util.concurrent.CompletionStage;
                whenComplete(param0: java.util.function.BiConsumer): java.util.concurrent.CompletableFuture;
                whenCompleteAsync(param0: java.util.function.BiConsumer): java.util.concurrent.CompletionStage;
                whenCompleteAsync(param0: java.util.function.BiConsumer, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                whenCompleteAsync(param0: java.util.function.BiConsumer): java.util.concurrent.CompletableFuture;
                whenCompleteAsync(param0: java.util.function.BiConsumer, param1: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                handleAsync(param0: java.util.function.BiFunction, param1: java.util.concurrent.Executor): java.util.concurrent.CompletableFuture;
                handleAsync(param0: java.util.function.BiFunction): java.util.concurrent.CompletableFuture;
                handleAsync(param0: java.util.function.BiFunction): java.util.concurrent.CompletionStage;
                handleAsync(param0: java.util.function.BiFunction, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                toCompletableFuture(): java.util.concurrent.CompletableFuture;
                exceptionally(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                exceptionally(param0: java.util.function.Function): java.util.concurrent.CompletableFuture;
                static anyOf(param0: any[]): java.util.concurrent.CompletableFuture;
                isCompletedExceptionally(): boolean;
                obtrudeValue(param0: any);
                obtrudeException(param0: java.lang.Throwable);
                getNumberOfDependents(): number;
                static allOf(param0: any[]): java.util.concurrent.CompletableFuture;
                complete(param0: any): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletionException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CompletionService{
                poll(param0: number, param1: java.util.concurrent.TimeUnit): java.util.concurrent.Future;
                poll(): java.util.concurrent.Future;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                take(): java.util.concurrent.Future;
            }
            class CompletionStage{
                handle(param0: java.util.function.BiFunction): java.util.concurrent.CompletionStage;
                thenApply(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                thenApplyAsync(param0: java.util.function.Function, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenApplyAsync(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                thenAccept(param0: java.util.function.Consumer): java.util.concurrent.CompletionStage;
                thenAcceptAsync(param0: java.util.function.Consumer, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenAcceptAsync(param0: java.util.function.Consumer): java.util.concurrent.CompletionStage;
                thenRun(param0: java.lang.Runnable): java.util.concurrent.CompletionStage;
                thenRunAsync(param0: java.lang.Runnable, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenRunAsync(param0: java.lang.Runnable): java.util.concurrent.CompletionStage;
                thenCombine(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction): java.util.concurrent.CompletionStage;
                thenCombineAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenCombineAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiFunction): java.util.concurrent.CompletionStage;
                thenAcceptBoth(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer): java.util.concurrent.CompletionStage;
                thenAcceptBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer): java.util.concurrent.CompletionStage;
                thenAcceptBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.BiConsumer, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                runAfterBoth(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletionStage;
                runAfterBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                runAfterBothAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletionStage;
                applyToEither(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function): java.util.concurrent.CompletionStage;
                applyToEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                applyToEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Function): java.util.concurrent.CompletionStage;
                acceptEither(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer): java.util.concurrent.CompletionStage;
                acceptEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer): java.util.concurrent.CompletionStage;
                acceptEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.util.function.Consumer, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                runAfterEither(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletionStage;
                runAfterEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable, param2: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                runAfterEitherAsync(param0: java.util.concurrent.CompletionStage, param1: java.lang.Runnable): java.util.concurrent.CompletionStage;
                thenCompose(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                thenComposeAsync(param0: java.util.function.Function, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                thenComposeAsync(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
                whenComplete(param0: java.util.function.BiConsumer): java.util.concurrent.CompletionStage;
                whenCompleteAsync(param0: java.util.function.BiConsumer, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                whenCompleteAsync(param0: java.util.function.BiConsumer): java.util.concurrent.CompletionStage;
                handleAsync(param0: java.util.function.BiFunction, param1: java.util.concurrent.Executor): java.util.concurrent.CompletionStage;
                handleAsync(param0: java.util.function.BiFunction): java.util.concurrent.CompletionStage;
                toCompletableFuture(): java.util.concurrent.CompletableFuture;
                exceptionally(param0: java.util.function.Function): java.util.concurrent.CompletionStage;
            }
            class ConcurrentHashMap$BulkTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$EntryIterator{
                next(): java.util.Map$Entry;
                next(): any;
                remove();
                hasNext(): boolean;
                hasMoreElements(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentHashMap$EntrySpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentHashMap$ForEachEntryTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ForEachKeyTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ForEachMappingTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ForEachTransformedEntryTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ForEachTransformedKeyTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ForEachTransformedMappingTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ForEachTransformedValueTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ForEachValueTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$KeySpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentHashMap$MapEntry{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getValue(): any;
                getKey(): any;
                setValue(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceEntriesTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceEntriesToDoubleTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceEntriesToIntTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceEntriesToLongTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceKeysTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceKeysToDoubleTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceKeysToIntTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceKeysToLongTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceMappingsTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceMappingsToDoubleTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceMappingsToIntTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceMappingsToLongTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceValuesTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceValuesToDoubleTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceValuesToIntTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$MapReduceValuesToLongTask{
                compute();
                getRawResult(): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ReduceEntriesTask{
                compute();
                getRawResult(): java.util.Map$Entry;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ReduceKeysTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ReduceValuesTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ReservationNode{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getValue(): any;
                getKey(): any;
                setValue(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$SearchEntriesTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$SearchKeysTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$SearchMappingsTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$SearchValuesTask{
                compute();
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$TableStack{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$TreeBin{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getValue(): any;
                getKey(): any;
                setValue(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$TreeNode{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getValue(): any;
                getKey(): any;
                setValue(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$ValueIterator{
                next(): any;
                nextElement(): any;
                remove();
                hasNext(): boolean;
                hasMoreElements(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentHashMap$ValueSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentLinkedDeque$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentLinkedDeque$AbstractItr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentLinkedDeque$CLDSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentLinkedDeque$DescendingItr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentLinkedDeque$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentLinkedDeque$Node{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentLinkedDeque{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                remove(): any;
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(): any[];
                toArray(param0: any[]): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                getFirst(): any;
                push(param0: any);
                pop(): any;
                poll(): any;
                peek(): any;
                addFirst(param0: any);
                addLast(param0: any);
                offerFirst(param0: any): boolean;
                offerLast(param0: any): boolean;
                removeFirst(): any;
                pollFirst(): any;
                pollLast(): any;
                getLast(): any;
                peekFirst(): any;
                removeFirstOccurrence(param0: any): boolean;
                removeLastOccurrence(param0: any): boolean;
                offer(param0: any): boolean;
                element(): any;
                descendingIterator(): java.util.Iterator;
                peekLast(): any;
                removeLast(): any;
                toString(): string;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class ConcurrentLinkedQueue$CLQSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentLinkedQueue$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentLinkedQueue$Node{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentLinkedQueue{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                poll(): any;
                peek(): any;
                offer(param0: any): boolean;
                remove(): any;
                clear();
                element(): any;
                toString(): string;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class ConcurrentNavigableMap{
                keySet(): java.util.NavigableSet;
                keySet(): java.util.Set;
                descendingMap(): java.util.NavigableMap;
                descendingMap(): java.util.concurrent.ConcurrentNavigableMap;
                navigableKeySet(): java.util.NavigableSet;
                descendingKeySet(): java.util.NavigableSet;
                subMap(param0: any, param1: any): java.util.SortedMap;
                subMap(param0: any, param1: any): java.util.concurrent.ConcurrentNavigableMap;
                subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
                subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.concurrent.ConcurrentNavigableMap;
                headMap(param0: any): java.util.SortedMap;
                headMap(param0: any, param1: boolean): java.util.NavigableMap;
                headMap(param0: any): java.util.concurrent.ConcurrentNavigableMap;
                headMap(param0: any, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                tailMap(param0: any, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                tailMap(param0: any): java.util.concurrent.ConcurrentNavigableMap;
                tailMap(param0: any, param1: boolean): java.util.NavigableMap;
                tailMap(param0: any): java.util.SortedMap;
                remove(param0: any, param1: any): boolean;
                replace(param0: any, param1: any, param2: any): boolean;
                replace(param0: any, param1: any): any;
                replaceAll(param0: java.util.function.BiFunction);
                putIfAbsent(param0: any, param1: any): any;
                forEach(param0: java.util.function.BiConsumer);
                getOrDefault(param0: any, param1: any): any;
                computeIfAbsent(param0: any, param1: java.util.function.Function): any;
                computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
                compute(param0: any, param1: java.util.function.BiFunction): any;
                merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
                remove(param0: any): any;
                get(param0: any): any;
                put(param0: any, param1: any): any;
                equals(param0: any): boolean;
                values(): java.util.Collection;
                hashCode(): number;
                clear();
                isEmpty(): boolean;
                size(): number;
                entrySet(): java.util.Set;
                putAll(param0: java.util.Map);
                containsValue(param0: any): boolean;
                containsKey(param0: any): boolean;
                lowerEntry(param0: any): java.util.Map$Entry;
                lowerKey(param0: any): any;
                floorEntry(param0: any): java.util.Map$Entry;
                floorKey(param0: any): any;
                ceilingEntry(param0: any): java.util.Map$Entry;
                ceilingKey(param0: any): any;
                higherEntry(param0: any): java.util.Map$Entry;
                higherKey(param0: any): any;
                firstEntry(): java.util.Map$Entry;
                lastEntry(): java.util.Map$Entry;
                pollFirstEntry(): java.util.Map$Entry;
                pollLastEntry(): java.util.Map$Entry;
                values(): java.util.Collection;
                entrySet(): java.util.Set;
                firstKey(): any;
                lastKey(): any;
                comparator(): java.util.Comparator;
                remove(param0: any, param1: any): boolean;
                replace(param0: any, param1: any): any;
                replace(param0: any, param1: any, param2: any): boolean;
                putIfAbsent(param0: any, param1: any): any;
            }
            class ConcurrentSkipListMap$CSLMSpliterator{
                estimateSize(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentSkipListMap$EntryIterator{
                next(): java.util.Map$Entry;
                next(): any;
                remove();
                hasNext(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentSkipListMap$EntrySet{
                remove(param0: any): boolean;
                equals(param0: any): boolean;
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                hashCode(): number;
                removeAll(param0: java.util.Collection): boolean;
                add(param0: any): boolean;
                toString(): string;
                addAll(param0: java.util.Collection): boolean;
                containsAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class ConcurrentSkipListMap$EntrySpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                estimateSize(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class ConcurrentSkipListMap$HeadIndex{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentSkipListMap$Index{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentSkipListMap$Iter{
                remove();
                hasNext(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                next(): any;
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentSkipListMap$KeyIterator{
                next(): any;
                remove();
                hasNext(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentSkipListMap$KeySet{
                remove(param0: any): boolean;
                equals(param0: any): boolean;
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(): any[];
                toArray(param0: any[]): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                first(): any;
                floor(param0: any): any;
                pollFirst(): any;
                pollLast(): any;
                descendingIterator(): java.util.Iterator;
                last(): any;
                lower(param0: any): any;
                ceiling(param0: any): any;
                higher(param0: any): any;
                descendingSet(): java.util.NavigableSet;
                subSet(param0: any, param1: any): java.util.NavigableSet;
                subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
                subSet(param0: any, param1: any): java.util.SortedSet;
                headSet(param0: any): java.util.SortedSet;
                headSet(param0: any, param1: boolean): java.util.NavigableSet;
                headSet(param0: any): java.util.NavigableSet;
                tailSet(param0: any): java.util.SortedSet;
                tailSet(param0: any, param1: boolean): java.util.NavigableSet;
                tailSet(param0: any): java.util.NavigableSet;
                comparator(): java.util.Comparator;
                hashCode(): number;
                removeAll(param0: java.util.Collection): boolean;
                add(param0: any): boolean;
                toString(): string;
                addAll(param0: java.util.Collection): boolean;
                containsAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class ConcurrentSkipListMap$KeySpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                estimateSize(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class ConcurrentSkipListMap$Node{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentSkipListMap$SubMap$SubMapEntryIterator{
                next(): any;
                next(): java.util.Map$Entry;
                characteristics(): number;
                remove();
                hasNext(): boolean;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentSkipListMap$SubMap$SubMapIter{
                remove();
                hasNext(): boolean;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                next(): any;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentSkipListMap$SubMap$SubMapKeyIterator{
                next(): any;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                remove();
                hasNext(): boolean;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class ConcurrentSkipListMap$SubMap$SubMapValueIterator{
                next(): any;
                characteristics(): number;
                remove();
                hasNext(): boolean;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentSkipListMap$SubMap{
                remove(param0: any): any;
                remove(param0: any, param1: any): boolean;
                get(param0: any): any;
                put(param0: any, param1: any): any;
                values(): java.util.Collection;
                clear();
                isEmpty(): boolean;
                replace(param0: any, param1: any, param2: any): boolean;
                replace(param0: any, param1: any): any;
                size(): number;
                entrySet(): java.util.Set;
                putIfAbsent(param0: any, param1: any): any;
                keySet(): java.util.Set;
                keySet(): java.util.NavigableSet;
                containsValue(param0: any): boolean;
                containsKey(param0: any): boolean;
                firstKey(): any;
                lastKey(): any;
                lowerEntry(param0: any): java.util.Map$Entry;
                lowerKey(param0: any): any;
                floorEntry(param0: any): java.util.Map$Entry;
                floorKey(param0: any): any;
                ceilingEntry(param0: any): java.util.Map$Entry;
                ceilingKey(param0: any): any;
                higherEntry(param0: any): java.util.Map$Entry;
                higherKey(param0: any): any;
                firstEntry(): java.util.Map$Entry;
                lastEntry(): java.util.Map$Entry;
                pollFirstEntry(): java.util.Map$Entry;
                pollLastEntry(): java.util.Map$Entry;
                descendingMap(): java.util.concurrent.ConcurrentSkipListMap$SubMap;
                descendingMap(): java.util.NavigableMap;
                descendingMap(): java.util.concurrent.ConcurrentNavigableMap;
                navigableKeySet(): java.util.NavigableSet;
                descendingKeySet(): java.util.NavigableSet;
                subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.concurrent.ConcurrentNavigableMap;
                subMap(param0: any, param1: any): java.util.concurrent.ConcurrentSkipListMap$SubMap;
                subMap(param0: any, param1: any): java.util.concurrent.ConcurrentNavigableMap;
                subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.concurrent.ConcurrentSkipListMap$SubMap;
                subMap(param0: any, param1: any): java.util.SortedMap;
                subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
                headMap(param0: any): java.util.concurrent.ConcurrentSkipListMap$SubMap;
                headMap(param0: any, param1: boolean): java.util.NavigableMap;
                headMap(param0: any, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                headMap(param0: any): java.util.SortedMap;
                headMap(param0: any): java.util.concurrent.ConcurrentNavigableMap;
                headMap(param0: any, param1: boolean): java.util.concurrent.ConcurrentSkipListMap$SubMap;
                tailMap(param0: any, param1: boolean): java.util.NavigableMap;
                tailMap(param0: any): java.util.SortedMap;
                tailMap(param0: any, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                tailMap(param0: any): java.util.concurrent.ConcurrentNavigableMap;
                tailMap(param0: any, param1: boolean): java.util.concurrent.ConcurrentSkipListMap$SubMap;
                tailMap(param0: any): java.util.concurrent.ConcurrentSkipListMap$SubMap;
                comparator(): java.util.Comparator;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                putAll(param0: java.util.Map);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                replaceAll(param0: java.util.function.BiFunction);
                forEach(param0: java.util.function.BiConsumer);
                getOrDefault(param0: any, param1: any): any;
                computeIfAbsent(param0: any, param1: java.util.function.Function): any;
                computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
                compute(param0: any, param1: java.util.function.BiFunction): any;
                merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            }
            class ConcurrentSkipListMap$ValueIterator{
                next(): any;
                remove();
                hasNext(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentSkipListMap$ValueSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                characteristics(): number;
                estimateSize(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ConcurrentSkipListMap$Values{
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                add(param0: any): boolean;
                remove(param0: any): boolean;
                toString(): string;
                addAll(param0: java.util.Collection): boolean;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class ConcurrentSkipListMap{
                remove(param0: any): any;
                remove(param0: any, param1: any): boolean;
                get(param0: any): any;
                put(param0: any, param1: any): any;
                equals(param0: any): boolean;
                values(): java.util.Collection;
                clone(): java.util.concurrent.ConcurrentSkipListMap;
                clone(): any;
                clear();
                isEmpty(): boolean;
                replace(param0: any, param1: any): any;
                replace(param0: any, param1: any, param2: any): boolean;
                replaceAll(param0: java.util.function.BiFunction);
                size(): number;
                entrySet(): java.util.Set;
                putIfAbsent(param0: any, param1: any): any;
                forEach(param0: java.util.function.BiConsumer);
                keySet(): java.util.Set;
                keySet(): java.util.NavigableSet;
                containsValue(param0: any): boolean;
                containsKey(param0: any): boolean;
                getOrDefault(param0: any, param1: any): any;
                computeIfAbsent(param0: any, param1: java.util.function.Function): any;
                computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
                compute(param0: any, param1: java.util.function.BiFunction): any;
                merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
                firstKey(): any;
                lastKey(): any;
                lowerEntry(param0: any): java.util.Map$Entry;
                lowerKey(param0: any): any;
                floorEntry(param0: any): java.util.Map$Entry;
                floorKey(param0: any): any;
                ceilingEntry(param0: any): java.util.Map$Entry;
                ceilingKey(param0: any): any;
                higherEntry(param0: any): java.util.Map$Entry;
                higherKey(param0: any): any;
                firstEntry(): java.util.Map$Entry;
                lastEntry(): java.util.Map$Entry;
                pollFirstEntry(): java.util.Map$Entry;
                pollLastEntry(): java.util.Map$Entry;
                descendingMap(): java.util.concurrent.ConcurrentNavigableMap;
                descendingMap(): java.util.NavigableMap;
                navigableKeySet(): java.util.NavigableSet;
                descendingKeySet(): java.util.NavigableSet;
                subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
                subMap(param0: any, param1: any): java.util.SortedMap;
                subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.concurrent.ConcurrentNavigableMap;
                subMap(param0: any, param1: any): java.util.concurrent.ConcurrentNavigableMap;
                headMap(param0: any): java.util.SortedMap;
                headMap(param0: any, param1: boolean): java.util.NavigableMap;
                headMap(param0: any, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                headMap(param0: any): java.util.concurrent.ConcurrentNavigableMap;
                tailMap(param0: any): java.util.SortedMap;
                tailMap(param0: any, param1: boolean): java.util.NavigableMap;
                tailMap(param0: any, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                tailMap(param0: any): java.util.concurrent.ConcurrentNavigableMap;
                comparator(): java.util.Comparator;
                toString(): string;
                hashCode(): number;
                putAll(param0: java.util.Map);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentSkipListSet{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                equals(param0: any): boolean;
                clone(): any;
                clone(): java.util.concurrent.ConcurrentSkipListSet;
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                first(): any;
                removeAll(param0: java.util.Collection): boolean;
                floor(param0: any): any;
                pollFirst(): any;
                pollLast(): any;
                descendingIterator(): java.util.Iterator;
                last(): any;
                lower(param0: any): any;
                ceiling(param0: any): any;
                higher(param0: any): any;
                descendingSet(): java.util.NavigableSet;
                subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
                subSet(param0: any, param1: any): java.util.NavigableSet;
                subSet(param0: any, param1: any): java.util.SortedSet;
                headSet(param0: any, param1: boolean): java.util.NavigableSet;
                headSet(param0: any): java.util.SortedSet;
                headSet(param0: any): java.util.NavigableSet;
                tailSet(param0: any, param1: boolean): java.util.NavigableSet;
                tailSet(param0: any): java.util.SortedSet;
                tailSet(param0: any): java.util.NavigableSet;
                comparator(): java.util.Comparator;
                hashCode(): number;
                toString(): string;
                toArray(param0: any[]): any[];
                toArray(): any[];
                addAll(param0: java.util.Collection): boolean;
                containsAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class CopyOnWriteArrayList$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CopyOnWriteArrayList$COWIterator{
                add(param0: any);
                remove();
                hasNext(): boolean;
                next(): any;
                set(param0: any);
                previousIndex(): number;
                hasPrevious(): boolean;
                previous(): any;
                nextIndex(): number;
                forEachRemaining(param0: java.util.function.Consumer);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CopyOnWriteArrayList$COWSubList{
                add(param0: number, param1: any);
                remove(param0: number): any;
                remove(param0: any): boolean;
                get(param0: number): any;
                clear();
                replaceAll(param0: java.util.function.UnaryOperator);
                size(): number;
                subList(param0: number, param1: number): java.util.List;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                set(param0: number, param1: any): any;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                listIterator(param0: number): java.util.ListIterator;
                removeIf(param0: java.util.function.Predicate): boolean;
                sort(param0: java.util.Comparator);
                add(param0: any): boolean;
                equals(param0: any): boolean;
                hashCode(): number;
                indexOf(param0: any): number;
                lastIndexOf(param0: any): number;
                addAll(param0: number, param1: java.util.Collection): boolean;
                listIterator(): java.util.ListIterator;
                toString(): string;
                isEmpty(): boolean;
                contains(param0: any): boolean;
                toArray(param0: any[]): any[];
                toArray(): any[];
                addAll(param0: java.util.Collection): boolean;
                containsAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                parallelStream(): java.util.stream.Stream;
            }
            class CopyOnWriteArrayList$COWSubListIterator{
                add(param0: any);
                remove();
                hasNext(): boolean;
                next(): any;
                set(param0: any);
                previousIndex(): number;
                hasPrevious(): boolean;
                previous(): any;
                nextIndex(): number;
                forEachRemaining(param0: java.util.function.Consumer);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CopyOnWriteArraySet{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                equals(param0: any): boolean;
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(): any[];
                toArray(param0: any[]): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                forEach(param0: java.util.function.Consumer);
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                removeIf(param0: java.util.function.Predicate): boolean;
                hashCode(): number;
                toString(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                parallelStream(): java.util.stream.Stream;
            }
            class CountDownLatch$Sync{
                toString(): string;
                acquire(param0: number);
                acquireShared(param0: number);
                acquireSharedInterruptibly(param0: number);
                tryAcquireSharedNanos(param0: number, param1: number): boolean;
                releaseShared(param0: number): boolean;
                hasContended(): boolean;
                getFirstQueuedThread(): java.lang.Thread;
                hasQueuedPredecessors(): boolean;
                getExclusiveQueuedThreads(): java.util.Collection;
                getSharedQueuedThreads(): java.util.Collection;
                owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                hasQueuedThreads(): boolean;
                getQueueLength(): number;
                getQueuedThreads(): java.util.Collection;
                hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                acquireInterruptibly(param0: number);
                tryAcquireNanos(param0: number, param1: number): boolean;
                release(param0: number): boolean;
                isQueued(param0: java.lang.Thread): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CountDownLatch{
                toString(): string;
                countDown();
                getCount(): number;
                await();
                await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CountedCompleter{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CyclicBarrier$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CyclicBarrier$Generation{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CyclicBarrier{
                reset();
                getParties(): number;
                isBroken(): boolean;
                getNumberWaiting(): number;
                await(param0: number, param1: java.util.concurrent.TimeUnit): number;
                await(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DelayQueue$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                next(): java.util.concurrent.Delayed;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class Exchanger$Node{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Exchanger$Participant{
                initialValue(): java.util.concurrent.Exchanger$Node;
                initialValue(): any;
                remove();
                get(): any;
                set(param0: any);
                static withInitial(param0: java.util.function.Supplier): java.lang.ThreadLocal;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Exchanger{
                exchange(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): any;
                exchange(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ExecutionException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ExecutorCompletionService$QueueingFuture{
                run();
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                get(): any;
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                run$$$capture();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ExecutorCompletionService{
                poll(param0: number, param1: java.util.concurrent.TimeUnit): java.util.concurrent.Future;
                poll(): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                take(): java.util.concurrent.Future;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$1{
                call(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$2{
                call(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$DefaultThreadFactory{
                newThread(param0: java.lang.Runnable): java.lang.Thread;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$DelegatedExecutorService{
                shutdown();
                execute(param0: java.lang.Runnable);
                invokeAll(param0: java.util.Collection): java.util.List;
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                shutdownNow(): java.util.List;
                isTerminated(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                invokeAny(param0: java.util.Collection): any;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$DelegatedScheduledExecutorService{
                scheduleWithFixedDelay(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                schedule(param0: java.util.concurrent.Callable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                scheduleAtFixedRate(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                shutdown();
                execute(param0: java.lang.Runnable);
                invokeAll(param0: java.util.Collection): java.util.List;
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                shutdownNow(): java.util.List;
                isTerminated(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                invokeAny(param0: java.util.Collection): any;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$FinalizableDelegatedExecutorService{
                shutdown();
                execute(param0: java.lang.Runnable);
                invokeAll(param0: java.util.Collection): java.util.List;
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                shutdownNow(): java.util.List;
                isTerminated(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                invokeAny(param0: java.util.Collection): any;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$PrivilegedCallable$1{
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$PrivilegedCallable{
                call(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$PrivilegedCallableUsingCurrentClassLoader$1{
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$PrivilegedCallableUsingCurrentClassLoader{
                call(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$PrivilegedThreadFactory$1$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$PrivilegedThreadFactory$1{
                run();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$PrivilegedThreadFactory{
                newThread(param0: java.lang.Runnable): java.lang.Thread;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Executors$RunnableAdapter{
                call(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinPool$1{
                run(): java.util.concurrent.ForkJoinPool;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinPool$DefaultCommonPoolForkJoinWorkerThreadFactory{
                newThread(param0: java.util.concurrent.ForkJoinPool): java.util.concurrent.ForkJoinWorkerThread;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinPool$DefaultForkJoinWorkerThreadFactory{
                newThread(param0: java.util.concurrent.ForkJoinPool): java.util.concurrent.ForkJoinWorkerThread;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinPool$EmptyTask{
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: java.lang.Void);
                setRawResult(param0: any);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinPool$ForkJoinWorkerThreadFactory{
                newThread(param0: java.util.concurrent.ForkJoinPool): java.util.concurrent.ForkJoinWorkerThread;
            }
            class ForkJoinPool$InnocuousForkJoinWorkerThreadFactory$1{
                run(): java.util.concurrent.ForkJoinWorkerThread;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinPool$InnocuousForkJoinWorkerThreadFactory{
                newThread(param0: java.util.concurrent.ForkJoinPool): java.util.concurrent.ForkJoinWorkerThread;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinPool$ManagedBlocker{
                isReleasable(): boolean;
                block(): boolean;
            }
            class ForkJoinPool$WorkQueue{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinPool{
                invoke(param0: java.util.concurrent.ForkJoinTask): any;
                shutdown();
                toString(): string;
                getFactory(): java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory;
                execute(param0: java.lang.Runnable);
                execute(param0: java.util.concurrent.ForkJoinTask);
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                static getCommonPoolParallelism(): number;
                invokeAll(param0: java.util.Collection): java.util.List;
                getQueuedTaskCount(): number;
                static commonPool(): java.util.concurrent.ForkJoinPool;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.util.concurrent.ForkJoinTask): java.util.concurrent.ForkJoinTask;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                getParallelism(): number;
                getPoolSize(): number;
                getAsyncMode(): boolean;
                getRunningThreadCount(): number;
                getActiveThreadCount(): number;
                isQuiescent(): boolean;
                getStealCount(): number;
                getQueuedSubmissionCount(): number;
                hasQueuedSubmissions(): boolean;
                shutdownNow(): java.util.List;
                isTerminated(): boolean;
                isTerminating(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                awaitQuiescence(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                static managedBlock(param0: java.util.concurrent.ForkJoinPool$ManagedBlocker);
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                invokeAny(param0: java.util.Collection): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinTask$AdaptedCallable{
                run();
                exec(): boolean;
                getRawResult(): any;
                setRawResult(param0: any);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinTask$AdaptedRunnable{
                run();
                exec(): boolean;
                getRawResult(): any;
                setRawResult(param0: any);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinTask$AdaptedRunnableAction{
                run();
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: java.lang.Void);
                setRawResult(param0: any);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinTask$ExceptionNode{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinTask$RunnableExecuteAction{
                exec(): boolean;
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                setRawResult(param0: any);
                setRawResult(param0: java.lang.Void);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinTask{
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                getRawResult(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinWorkerThread$InnocuousForkJoinWorkerThread{
                getContextClassLoader(): java.lang.ClassLoader;
                setContextClassLoader(param0: java.lang.ClassLoader);
                setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                run();
                getPool(): java.util.concurrent.ForkJoinPool;
                getPoolIndex(): number;
                toString(): string;
                isInterrupted(): boolean;
                static currentThread(): java.lang.Thread;
                getName(): string;
                join(param0: number);
                join(param0: number, param1: number);
                join();
                getThreadGroup(): java.lang.ThreadGroup;
                getStackTrace(): any[];
                static holdsLock(param0: any): boolean;
                checkAccess();
                static dumpStack();
                static yield();
                setPriority(param0: number);
                setDaemon(param0: boolean);
                start();
                static sleep(param0: number, param1: number);
                static sleep(param0: number);
                stop();
                stop(param0: java.lang.Throwable);
                interrupt();
                static interrupted(): boolean;
                destroy();
                isAlive(): boolean;
                suspend();
                resume();
                getPriority(): number;
                setName(param0: string);
                static activeCount(): number;
                static enumerate(param0: any[]): number;
                countStackFrames(): number;
                isDaemon(): boolean;
                static getAllStackTraces(): java.util.Map;
                getId(): number;
                getState(): java.lang.Thread$State;
                static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForkJoinWorkerThread{
                run();
                getPool(): java.util.concurrent.ForkJoinPool;
                getPoolIndex(): number;
                toString(): string;
                isInterrupted(): boolean;
                static currentThread(): java.lang.Thread;
                getName(): string;
                join(param0: number);
                join(param0: number, param1: number);
                join();
                getThreadGroup(): java.lang.ThreadGroup;
                getStackTrace(): any[];
                static holdsLock(param0: any): boolean;
                checkAccess();
                static dumpStack();
                static yield();
                setPriority(param0: number);
                setDaemon(param0: boolean);
                start();
                static sleep(param0: number, param1: number);
                static sleep(param0: number);
                stop();
                stop(param0: java.lang.Throwable);
                interrupt();
                static interrupted(): boolean;
                destroy();
                isAlive(): boolean;
                suspend();
                resume();
                getPriority(): number;
                setName(param0: string);
                static activeCount(): number;
                static enumerate(param0: any[]): number;
                countStackFrames(): number;
                isDaemon(): boolean;
                getContextClassLoader(): java.lang.ClassLoader;
                setContextClassLoader(param0: java.lang.ClassLoader);
                static getAllStackTraces(): java.util.Map;
                getId(): number;
                getState(): java.lang.Thread$State;
                static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Future{
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                get(): any;
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
            }
            class FutureTask$WaitNode{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FutureTask{
                run();
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                get(): any;
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                run$$$capture();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LinkedBlockingDeque$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LinkedBlockingDeque$AbstractItr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class LinkedBlockingDeque$DescendingItr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class LinkedBlockingDeque$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class LinkedBlockingDeque$LBDSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class LinkedBlockingDeque$Node{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LinkedBlockingDeque{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                remove(): any;
                put(param0: any);
                toString(): string;
                clear();
                contains(param0: any): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                getFirst(): any;
                push(param0: any);
                pop(): any;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                poll(): any;
                peek(): any;
                addFirst(param0: any);
                addLast(param0: any);
                offerFirst(param0: any): boolean;
                offerFirst(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offerLast(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offerLast(param0: any): boolean;
                removeFirst(): any;
                pollFirst(param0: number, param1: java.util.concurrent.TimeUnit): any;
                pollFirst(): any;
                pollLast(param0: number, param1: java.util.concurrent.TimeUnit): any;
                pollLast(): any;
                getLast(): any;
                peekFirst(): any;
                removeFirstOccurrence(param0: any): boolean;
                removeLastOccurrence(param0: any): boolean;
                offer(param0: any): boolean;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                element(): any;
                descendingIterator(): java.util.Iterator;
                peekLast(): any;
                removeLast(): any;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                drainTo(param0: java.util.Collection): number;
                putFirst(param0: any);
                putLast(param0: any);
                takeFirst(): any;
                takeLast(): any;
                addAll(param0: java.util.Collection): boolean;
                isEmpty(): boolean;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class LinkedBlockingQueue$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class LinkedBlockingQueue$LBQSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class LinkedBlockingQueue$Node{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LinkedBlockingQueue{
                remove(param0: any): boolean;
                put(param0: any);
                toString(): string;
                clear();
                contains(param0: any): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                poll(): any;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                peek(): any;
                offer(param0: any): boolean;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                add(param0: any): boolean;
                remove(): any;
                addAll(param0: java.util.Collection): boolean;
                element(): any;
                isEmpty(): boolean;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class LinkedTransferQueue$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class LinkedTransferQueue$LTQSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class LinkedTransferQueue$Node{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LinkedTransferQueue{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                put(param0: any);
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                poll(): any;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                peek(): any;
                transfer(param0: any);
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offer(param0: any): boolean;
                tryTransfer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                tryTransfer(param0: any): boolean;
                hasWaitingConsumer(): boolean;
                getWaitingConsumerCount(): number;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                drainTo(param0: java.util.Collection): number;
                remove(): any;
                clear();
                addAll(param0: java.util.Collection): boolean;
                element(): any;
                toString(): string;
                toArray(param0: any[]): any[];
                toArray(): any[];
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class Phaser$QNode{
                isReleasable(): boolean;
                block(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Phaser{
                toString(): string;
                register(): number;
                getParent(): java.util.concurrent.Phaser;
                getRoot(): java.util.concurrent.Phaser;
                getPhase(): number;
                bulkRegister(param0: number): number;
                arrive(): number;
                arriveAndDeregister(): number;
                arriveAndAwaitAdvance(): number;
                awaitAdvance(param0: number): number;
                awaitAdvanceInterruptibly(param0: number): number;
                awaitAdvanceInterruptibly(param0: number, param1: number, param2: java.util.concurrent.TimeUnit): number;
                forceTermination();
                getRegisteredParties(): number;
                getArrivedParties(): number;
                getUnarrivedParties(): number;
                isTerminated(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PriorityBlockingQueue$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class PriorityBlockingQueue$PBQSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class PriorityBlockingQueue{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                put(param0: any);
                toString(): string;
                clear();
                contains(param0: any): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                poll(): any;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                peek(): any;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offer(param0: any): boolean;
                take(): any;
                comparator(): java.util.Comparator;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                remove(): any;
                addAll(param0: java.util.Collection): boolean;
                element(): any;
                isEmpty(): boolean;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class RecursiveAction{
                getRawResult(): any;
                getRawResult(): java.lang.Void;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class RecursiveTask{
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                complete(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class RejectedExecutionException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class RunnableFuture{
                run();
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                get(): any;
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
            }
            class RunnableScheduledFuture{
                isPeriodic(): boolean;
                run();
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                get(): any;
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                getDelay(param0: java.util.concurrent.TimeUnit): number;
                compareTo(param0: any): number;
            }
            class ScheduledExecutorService{
                scheduleWithFixedDelay(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                schedule(param0: java.util.concurrent.Callable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                scheduleAtFixedRate(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                shutdown();
                invokeAll(param0: java.util.Collection): java.util.List;
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                shutdownNow(): java.util.List;
                isTerminated(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                invokeAny(param0: java.util.Collection): any;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                execute(param0: java.lang.Runnable);
            }
            class ScheduledFuture{
                getDelay(param0: java.util.concurrent.TimeUnit): number;
                compareTo(param0: any): number;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                get(): any;
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
            }
            class ScheduledThreadPoolExecutor$DelayedWorkQueue$Itr{
                remove();
                hasNext(): boolean;
                next(): any;
                next(): java.lang.Runnable;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ScheduledThreadPoolExecutor$DelayedWorkQueue{
                add(param0: java.lang.Runnable): boolean;
                add(param0: any): boolean;
                remove(param0: any): boolean;
                put(param0: any);
                put(param0: java.lang.Runnable);
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(): any[];
                toArray(param0: any[]): any[];
                iterator(): java.util.Iterator;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): java.util.concurrent.RunnableScheduledFuture;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                poll(): any;
                poll(): java.util.concurrent.RunnableScheduledFuture;
                peek(): any;
                peek(): java.util.concurrent.RunnableScheduledFuture;
                offer(param0: any): boolean;
                offer(param0: java.lang.Runnable): boolean;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offer(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                take(): java.util.concurrent.RunnableScheduledFuture;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                drainTo(param0: java.util.Collection): number;
                remove(): any;
                addAll(param0: java.util.Collection): boolean;
                element(): any;
                toString(): string;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                spliterator(): java.util.Spliterator;
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class ScheduledThreadPoolExecutor$ScheduledFutureTask{
                run();
                compareTo(param0: java.util.concurrent.Delayed): number;
                compareTo(param0: any): number;
                getDelay(param0: java.util.concurrent.TimeUnit): number;
                isPeriodic(): boolean;
                cancel(param0: boolean): boolean;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                get(): any;
                isDone(): boolean;
                isCancelled(): boolean;
                run$$$capture();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ScheduledThreadPoolExecutor{
                shutdown();
                execute(param0: java.lang.Runnable);
                getQueue(): java.util.concurrent.BlockingQueue;
                scheduleWithFixedDelay(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                setContinueExistingPeriodicTasksAfterShutdownPolicy(param0: boolean);
                getContinueExistingPeriodicTasksAfterShutdownPolicy(): boolean;
                setExecuteExistingDelayedTasksAfterShutdownPolicy(param0: boolean);
                getExecuteExistingDelayedTasksAfterShutdownPolicy(): boolean;
                setRemoveOnCancelPolicy(param0: boolean);
                getRemoveOnCancelPolicy(): boolean;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                shutdownNow(): java.util.List;
                schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                schedule(param0: java.util.concurrent.Callable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                scheduleAtFixedRate(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                remove(param0: java.lang.Runnable): boolean;
                toString(): string;
                allowCoreThreadTimeOut(param0: boolean);
                getPoolSize(): number;
                isTerminated(): boolean;
                isTerminating(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                setThreadFactory(param0: java.util.concurrent.ThreadFactory);
                getThreadFactory(): java.util.concurrent.ThreadFactory;
                setRejectedExecutionHandler(param0: java.util.concurrent.RejectedExecutionHandler);
                getRejectedExecutionHandler(): java.util.concurrent.RejectedExecutionHandler;
                setCorePoolSize(param0: number);
                getCorePoolSize(): number;
                prestartCoreThread(): boolean;
                prestartAllCoreThreads(): number;
                allowsCoreThreadTimeOut(): boolean;
                setMaximumPoolSize(param0: number);
                getMaximumPoolSize(): number;
                setKeepAliveTime(param0: number, param1: java.util.concurrent.TimeUnit);
                getKeepAliveTime(param0: java.util.concurrent.TimeUnit): number;
                getActiveCount(): number;
                getLargestPoolSize(): number;
                getTaskCount(): number;
                getCompletedTaskCount(): number;
                purge();
                invokeAll(param0: java.util.Collection): java.util.List;
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                invokeAny(param0: java.util.Collection): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Semaphore$FairSync{
                toString(): string;
                acquire(param0: number);
                acquireShared(param0: number);
                acquireSharedInterruptibly(param0: number);
                tryAcquireSharedNanos(param0: number, param1: number): boolean;
                releaseShared(param0: number): boolean;
                hasContended(): boolean;
                getFirstQueuedThread(): java.lang.Thread;
                hasQueuedPredecessors(): boolean;
                getExclusiveQueuedThreads(): java.util.Collection;
                getSharedQueuedThreads(): java.util.Collection;
                owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                hasQueuedThreads(): boolean;
                getQueueLength(): number;
                getQueuedThreads(): java.util.Collection;
                hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                acquireInterruptibly(param0: number);
                tryAcquireNanos(param0: number, param1: number): boolean;
                release(param0: number): boolean;
                isQueued(param0: java.lang.Thread): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Semaphore$NonfairSync{
                toString(): string;
                acquire(param0: number);
                acquireShared(param0: number);
                acquireSharedInterruptibly(param0: number);
                tryAcquireSharedNanos(param0: number, param1: number): boolean;
                releaseShared(param0: number): boolean;
                hasContended(): boolean;
                getFirstQueuedThread(): java.lang.Thread;
                hasQueuedPredecessors(): boolean;
                getExclusiveQueuedThreads(): java.util.Collection;
                getSharedQueuedThreads(): java.util.Collection;
                owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                hasQueuedThreads(): boolean;
                getQueueLength(): number;
                getQueuedThreads(): java.util.Collection;
                hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                acquireInterruptibly(param0: number);
                tryAcquireNanos(param0: number, param1: number): boolean;
                release(param0: number): boolean;
                isQueued(param0: java.lang.Thread): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Semaphore$Sync{
                toString(): string;
                acquire(param0: number);
                acquireShared(param0: number);
                acquireSharedInterruptibly(param0: number);
                tryAcquireSharedNanos(param0: number, param1: number): boolean;
                releaseShared(param0: number): boolean;
                hasContended(): boolean;
                getFirstQueuedThread(): java.lang.Thread;
                hasQueuedPredecessors(): boolean;
                getExclusiveQueuedThreads(): java.util.Collection;
                getSharedQueuedThreads(): java.util.Collection;
                owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                hasQueuedThreads(): boolean;
                getQueueLength(): number;
                getQueuedThreads(): java.util.Collection;
                hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                acquireInterruptibly(param0: number);
                tryAcquireNanos(param0: number, param1: number): boolean;
                release(param0: number): boolean;
                isQueued(param0: java.lang.Thread): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Semaphore{
                toString(): string;
                tryAcquire(param0: number): boolean;
                tryAcquire(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                tryAcquire(): boolean;
                tryAcquire(param0: number, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                acquire();
                acquire(param0: number);
                isFair(): boolean;
                hasQueuedThreads(): boolean;
                getQueueLength(): number;
                release();
                release(param0: number);
                drainPermits(): number;
                acquireUninterruptibly(param0: number);
                acquireUninterruptibly();
                availablePermits(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SynchronousQueue$FifoWaitQueue{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SynchronousQueue$LifoWaitQueue{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SynchronousQueue$TransferQueue$QNode{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SynchronousQueue$TransferQueue{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SynchronousQueue$WaitQueue{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadLocalRandom$RandomDoublesSpliterator{
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.concurrent.ThreadLocalRandom$RandomDoublesSpliterator;
                trySplit(): java.util.Spliterator$OfDouble;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ThreadLocalRandom$RandomIntsSpliterator{
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.IntConsumer);
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.concurrent.ThreadLocalRandom$RandomIntsSpliterator;
                trySplit(): java.util.Spliterator$OfInt;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ThreadLocalRandom$RandomLongsSpliterator{
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.LongConsumer);
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.concurrent.ThreadLocalRandom$RandomLongsSpliterator;
                trySplit(): java.util.Spliterator$OfLong;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class ThreadLocalRandom{
                nextInt(): number;
                nextInt(param0: number, param1: number): number;
                nextInt(param0: number): number;
                nextDouble(param0: number): number;
                nextDouble(param0: number, param1: number): number;
                nextDouble(): number;
                static current(): java.util.concurrent.ThreadLocalRandom;
                nextBoolean(): boolean;
                nextFloat(): number;
                ints(param0: number, param1: number, param2: number): java.util.stream.IntStream;
                ints(param0: number): java.util.stream.IntStream;
                ints(param0: number, param1: number): java.util.stream.IntStream;
                ints(): java.util.stream.IntStream;
                longs(param0: number): java.util.stream.LongStream;
                longs(param0: number, param1: number, param2: number): java.util.stream.LongStream;
                longs(): java.util.stream.LongStream;
                longs(param0: number, param1: number): java.util.stream.LongStream;
                doubles(param0: number, param1: number, param2: number): java.util.stream.DoubleStream;
                doubles(): java.util.stream.DoubleStream;
                doubles(param0: number): java.util.stream.DoubleStream;
                doubles(param0: number, param1: number): java.util.stream.DoubleStream;
                setSeed(param0: number);
                nextGaussian(): number;
                nextLong(param0: number): number;
                nextLong(): number;
                nextLong(param0: number, param1: number): number;
                nextBytes(param0: any[]);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadPoolExecutor$CallerRunsPolicy{
                rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadPoolExecutor$DiscardOldestPolicy{
                rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadPoolExecutor$DiscardPolicy{
                rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeoutException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TransferQueue{
                transfer(param0: any);
                tryTransfer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                tryTransfer(param0: any): boolean;
                hasWaitingConsumer(): boolean;
                getWaitingConsumerCount(): number;
                add(param0: any): boolean;
                remove(param0: any): boolean;
                put(param0: any);
                contains(param0: any): boolean;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                offer(param0: any): boolean;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                remove(): any;
                poll(): any;
                peek(): any;
                element(): any;
                equals(param0: any): boolean;
                hashCode(): number;
                clear();
                isEmpty(): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                stream(): java.util.stream.Stream;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            namespace atomic{
                class AtomicIntegerArray{
                    get(param0: number): number;
                    toString(): string;
                    length(): number;
                    set(param0: number, param1: number);
                    lazySet(param0: number, param1: number);
                    getAndAdd(param0: number, param1: number): number;
                    getAndSet(param0: number, param1: number): number;
                    compareAndSet(param0: number, param1: number, param2: number): boolean;
                    weakCompareAndSet(param0: number, param1: number, param2: number): boolean;
                    getAndIncrement(param0: number): number;
                    getAndDecrement(param0: number): number;
                    incrementAndGet(param0: number): number;
                    decrementAndGet(param0: number): number;
                    addAndGet(param0: number, param1: number): number;
                    getAndUpdate(param0: number, param1: java.util.function.IntUnaryOperator): number;
                    updateAndGet(param0: number, param1: java.util.function.IntUnaryOperator): number;
                    getAndAccumulate(param0: number, param1: number, param2: java.util.function.IntBinaryOperator): number;
                    accumulateAndGet(param0: number, param1: number, param2: java.util.function.IntBinaryOperator): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl$1{
                    run(): java.lang.reflect.Field;
                    run(): any;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl{
                    get(param0: any): number;
                    set(param0: any, param1: number);
                    lazySet(param0: any, param1: number);
                    getAndAdd(param0: any, param1: number): number;
                    getAndSet(param0: any, param1: number): number;
                    compareAndSet(param0: any, param1: number, param2: number): boolean;
                    weakCompareAndSet(param0: any, param1: number, param2: number): boolean;
                    getAndIncrement(param0: any): number;
                    getAndDecrement(param0: any): number;
                    incrementAndGet(param0: any): number;
                    decrementAndGet(param0: any): number;
                    addAndGet(param0: any, param1: number): number;
                    getAndUpdate(param0: any, param1: java.util.function.IntUnaryOperator): number;
                    updateAndGet(param0: any, param1: java.util.function.IntUnaryOperator): number;
                    getAndAccumulate(param0: any, param1: number, param2: java.util.function.IntBinaryOperator): number;
                    accumulateAndGet(param0: any, param1: number, param2: java.util.function.IntBinaryOperator): number;
                    static newUpdater(param0: java.lang.Class, param1: string): java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicIntegerFieldUpdater{
                    get(param0: any): number;
                    set(param0: any, param1: number);
                    lazySet(param0: any, param1: number);
                    getAndAdd(param0: any, param1: number): number;
                    getAndSet(param0: any, param1: number): number;
                    compareAndSet(param0: any, param1: number, param2: number): boolean;
                    weakCompareAndSet(param0: any, param1: number, param2: number): boolean;
                    getAndIncrement(param0: any): number;
                    getAndDecrement(param0: any): number;
                    incrementAndGet(param0: any): number;
                    decrementAndGet(param0: any): number;
                    addAndGet(param0: any, param1: number): number;
                    getAndUpdate(param0: any, param1: java.util.function.IntUnaryOperator): number;
                    updateAndGet(param0: any, param1: java.util.function.IntUnaryOperator): number;
                    getAndAccumulate(param0: any, param1: number, param2: java.util.function.IntBinaryOperator): number;
                    accumulateAndGet(param0: any, param1: number, param2: java.util.function.IntBinaryOperator): number;
                    static newUpdater(param0: java.lang.Class, param1: string): java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicLongArray{
                    get(param0: number): number;
                    toString(): string;
                    length(): number;
                    set(param0: number, param1: number);
                    lazySet(param0: number, param1: number);
                    getAndAdd(param0: number, param1: number): number;
                    getAndSet(param0: number, param1: number): number;
                    compareAndSet(param0: number, param1: number, param2: number): boolean;
                    weakCompareAndSet(param0: number, param1: number, param2: number): boolean;
                    getAndIncrement(param0: number): number;
                    getAndDecrement(param0: number): number;
                    incrementAndGet(param0: number): number;
                    decrementAndGet(param0: number): number;
                    addAndGet(param0: number, param1: number): number;
                    getAndUpdate(param0: number, param1: java.util.function.LongUnaryOperator): number;
                    updateAndGet(param0: number, param1: java.util.function.LongUnaryOperator): number;
                    getAndAccumulate(param0: number, param1: number, param2: java.util.function.LongBinaryOperator): number;
                    accumulateAndGet(param0: number, param1: number, param2: java.util.function.LongBinaryOperator): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicLongFieldUpdater$CASUpdater$1{
                    run(): java.lang.reflect.Field;
                    run(): any;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicLongFieldUpdater$CASUpdater{
                    get(param0: any): number;
                    set(param0: any, param1: number);
                    lazySet(param0: any, param1: number);
                    getAndAdd(param0: any, param1: number): number;
                    getAndSet(param0: any, param1: number): number;
                    compareAndSet(param0: any, param1: number, param2: number): boolean;
                    weakCompareAndSet(param0: any, param1: number, param2: number): boolean;
                    getAndIncrement(param0: any): number;
                    getAndDecrement(param0: any): number;
                    incrementAndGet(param0: any): number;
                    decrementAndGet(param0: any): number;
                    addAndGet(param0: any, param1: number): number;
                    getAndUpdate(param0: any, param1: java.util.function.LongUnaryOperator): number;
                    updateAndGet(param0: any, param1: java.util.function.LongUnaryOperator): number;
                    getAndAccumulate(param0: any, param1: number, param2: java.util.function.LongBinaryOperator): number;
                    accumulateAndGet(param0: any, param1: number, param2: java.util.function.LongBinaryOperator): number;
                    static newUpdater(param0: java.lang.Class, param1: string): java.util.concurrent.atomic.AtomicLongFieldUpdater;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicLongFieldUpdater$LockedUpdater$1{
                    run(): java.lang.reflect.Field;
                    run(): any;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicLongFieldUpdater$LockedUpdater{
                    get(param0: any): number;
                    set(param0: any, param1: number);
                    lazySet(param0: any, param1: number);
                    compareAndSet(param0: any, param1: number, param2: number): boolean;
                    weakCompareAndSet(param0: any, param1: number, param2: number): boolean;
                    getAndAdd(param0: any, param1: number): number;
                    getAndSet(param0: any, param1: number): number;
                    getAndIncrement(param0: any): number;
                    getAndDecrement(param0: any): number;
                    incrementAndGet(param0: any): number;
                    decrementAndGet(param0: any): number;
                    addAndGet(param0: any, param1: number): number;
                    getAndUpdate(param0: any, param1: java.util.function.LongUnaryOperator): number;
                    updateAndGet(param0: any, param1: java.util.function.LongUnaryOperator): number;
                    getAndAccumulate(param0: any, param1: number, param2: java.util.function.LongBinaryOperator): number;
                    accumulateAndGet(param0: any, param1: number, param2: java.util.function.LongBinaryOperator): number;
                    static newUpdater(param0: java.lang.Class, param1: string): java.util.concurrent.atomic.AtomicLongFieldUpdater;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicLongFieldUpdater{
                    get(param0: any): number;
                    set(param0: any, param1: number);
                    lazySet(param0: any, param1: number);
                    getAndAdd(param0: any, param1: number): number;
                    getAndSet(param0: any, param1: number): number;
                    compareAndSet(param0: any, param1: number, param2: number): boolean;
                    weakCompareAndSet(param0: any, param1: number, param2: number): boolean;
                    getAndIncrement(param0: any): number;
                    getAndDecrement(param0: any): number;
                    incrementAndGet(param0: any): number;
                    decrementAndGet(param0: any): number;
                    addAndGet(param0: any, param1: number): number;
                    getAndUpdate(param0: any, param1: java.util.function.LongUnaryOperator): number;
                    updateAndGet(param0: any, param1: java.util.function.LongUnaryOperator): number;
                    getAndAccumulate(param0: any, param1: number, param2: java.util.function.LongBinaryOperator): number;
                    accumulateAndGet(param0: any, param1: number, param2: java.util.function.LongBinaryOperator): number;
                    static newUpdater(param0: java.lang.Class, param1: string): java.util.concurrent.atomic.AtomicLongFieldUpdater;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicMarkableReference$Pair{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicMarkableReference{
                    get(param0: any[]): any;
                    set(param0: any, param1: boolean);
                    compareAndSet(param0: any, param1: any, param2: boolean, param3: boolean): boolean;
                    weakCompareAndSet(param0: any, param1: any, param2: boolean, param3: boolean): boolean;
                    getReference(): any;
                    isMarked(): boolean;
                    attemptMark(param0: any, param1: boolean): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicReference{
                    get(): any;
                    toString(): string;
                    set(param0: any);
                    lazySet(param0: any);
                    getAndSet(param0: any): any;
                    compareAndSet(param0: any, param1: any): boolean;
                    weakCompareAndSet(param0: any, param1: any): boolean;
                    getAndUpdate(param0: java.util.function.UnaryOperator): any;
                    updateAndGet(param0: java.util.function.UnaryOperator): any;
                    getAndAccumulate(param0: any, param1: java.util.function.BinaryOperator): any;
                    accumulateAndGet(param0: any, param1: java.util.function.BinaryOperator): any;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicReferenceArray{
                    get(param0: number): any;
                    toString(): string;
                    length(): number;
                    set(param0: number, param1: any);
                    lazySet(param0: number, param1: any);
                    getAndSet(param0: number, param1: any): any;
                    compareAndSet(param0: number, param1: any, param2: any): boolean;
                    weakCompareAndSet(param0: number, param1: any, param2: any): boolean;
                    getAndUpdate(param0: number, param1: java.util.function.UnaryOperator): any;
                    updateAndGet(param0: number, param1: java.util.function.UnaryOperator): any;
                    getAndAccumulate(param0: number, param1: any, param2: java.util.function.BinaryOperator): any;
                    accumulateAndGet(param0: number, param1: any, param2: java.util.function.BinaryOperator): any;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicStampedReference$Pair{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicStampedReference{
                    get(param0: any[]): any;
                    set(param0: any, param1: number);
                    compareAndSet(param0: any, param1: any, param2: number, param3: number): boolean;
                    weakCompareAndSet(param0: any, param1: any, param2: number, param3: number): boolean;
                    getReference(): any;
                    getStamp(): number;
                    attemptStamp(param0: any, param1: number): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class DoubleAccumulator$SerializationProxy{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class DoubleAccumulator{
                    get(): number;
                    toString(): string;
                    intValue(): number;
                    longValue(): number;
                    floatValue(): number;
                    doubleValue(): number;
                    reset();
                    accumulate(param0: number);
                    getThenReset(): number;
                    byteValue(): number;
                    shortValue(): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class DoubleAdder$SerializationProxy{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class DoubleAdder{
                    add(param0: number);
                    toString(): string;
                    intValue(): number;
                    longValue(): number;
                    floatValue(): number;
                    doubleValue(): number;
                    reset();
                    sum(): number;
                    sumThenReset(): number;
                    byteValue(): number;
                    shortValue(): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class LongAccumulator$SerializationProxy{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class LongAccumulator{
                    get(): number;
                    toString(): string;
                    intValue(): number;
                    longValue(): number;
                    floatValue(): number;
                    doubleValue(): number;
                    reset();
                    accumulate(param0: number);
                    getThenReset(): number;
                    byteValue(): number;
                    shortValue(): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class LongAdder$SerializationProxy{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class LongAdder{
                    add(param0: number);
                    toString(): string;
                    intValue(): number;
                    longValue(): number;
                    floatValue(): number;
                    doubleValue(): number;
                    increment();
                    reset();
                    sum(): number;
                    sumThenReset(): number;
                    decrement();
                    byteValue(): number;
                    shortValue(): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class Striped64$Cell{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class Striped64{
                    byteValue(): number;
                    shortValue(): number;
                    intValue(): number;
                    longValue(): number;
                    floatValue(): number;
                    doubleValue(): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl$1{
                    run(): java.lang.reflect.Field;
                    run(): any;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl{
                    get(param0: any): any;
                    set(param0: any, param1: any);
                    lazySet(param0: any, param1: any);
                    getAndSet(param0: any, param1: any): any;
                    compareAndSet(param0: any, param1: any, param2: any): boolean;
                    weakCompareAndSet(param0: any, param1: any, param2: any): boolean;
                    getAndUpdate(param0: any, param1: java.util.function.UnaryOperator): any;
                    updateAndGet(param0: any, param1: java.util.function.UnaryOperator): any;
                    getAndAccumulate(param0: any, param1: any, param2: java.util.function.BinaryOperator): any;
                    accumulateAndGet(param0: any, param1: any, param2: java.util.function.BinaryOperator): any;
                    static newUpdater(param0: java.lang.Class, param1: java.lang.Class, param2: string): java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicReferenceFieldUpdater{
                    get(param0: any): any;
                    set(param0: any, param1: any);
                    lazySet(param0: any, param1: any);
                    getAndSet(param0: any, param1: any): any;
                    compareAndSet(param0: any, param1: any, param2: any): boolean;
                    weakCompareAndSet(param0: any, param1: any, param2: any): boolean;
                    getAndUpdate(param0: any, param1: java.util.function.UnaryOperator): any;
                    updateAndGet(param0: any, param1: java.util.function.UnaryOperator): any;
                    getAndAccumulate(param0: any, param1: any, param2: java.util.function.BinaryOperator): any;
                    accumulateAndGet(param0: any, param1: any, param2: java.util.function.BinaryOperator): any;
                    static newUpdater(param0: java.lang.Class, param1: java.lang.Class, param2: string): java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicLong{
                    get(): number;
                    toString(): string;
                    intValue(): number;
                    longValue(): number;
                    floatValue(): number;
                    doubleValue(): number;
                    set(param0: number);
                    lazySet(param0: number);
                    getAndAdd(param0: number): number;
                    getAndSet(param0: number): number;
                    compareAndSet(param0: number, param1: number): boolean;
                    weakCompareAndSet(param0: number, param1: number): boolean;
                    getAndIncrement(): number;
                    getAndDecrement(): number;
                    incrementAndGet(): number;
                    decrementAndGet(): number;
                    addAndGet(param0: number): number;
                    getAndUpdate(param0: java.util.function.LongUnaryOperator): number;
                    updateAndGet(param0: java.util.function.LongUnaryOperator): number;
                    getAndAccumulate(param0: number, param1: java.util.function.LongBinaryOperator): number;
                    accumulateAndGet(param0: number, param1: java.util.function.LongBinaryOperator): number;
                    byteValue(): number;
                    shortValue(): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicInteger{
                    get(): number;
                    toString(): string;
                    intValue(): number;
                    longValue(): number;
                    floatValue(): number;
                    doubleValue(): number;
                    set(param0: number);
                    lazySet(param0: number);
                    getAndAdd(param0: number): number;
                    getAndSet(param0: number): number;
                    compareAndSet(param0: number, param1: number): boolean;
                    weakCompareAndSet(param0: number, param1: number): boolean;
                    getAndIncrement(): number;
                    getAndDecrement(): number;
                    incrementAndGet(): number;
                    decrementAndGet(): number;
                    addAndGet(param0: number): number;
                    getAndUpdate(param0: java.util.function.IntUnaryOperator): number;
                    updateAndGet(param0: java.util.function.IntUnaryOperator): number;
                    getAndAccumulate(param0: number, param1: java.util.function.IntBinaryOperator): number;
                    accumulateAndGet(param0: number, param1: java.util.function.IntBinaryOperator): number;
                    byteValue(): number;
                    shortValue(): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AtomicBoolean{
                    get(): boolean;
                    toString(): string;
                    set(param0: boolean);
                    lazySet(param0: boolean);
                    getAndSet(param0: boolean): boolean;
                    compareAndSet(param0: boolean, param1: boolean): boolean;
                    weakCompareAndSet(param0: boolean, param1: boolean): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
            }
            namespace locks{
                class AbstractQueuedLongSynchronizer$ConditionObject{
                    signalAll();
                    awaitUninterruptibly();
                    awaitUntil(param0: java.util.Date): boolean;
                    signal();
                    await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    await();
                    awaitNanos(param0: number): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AbstractQueuedLongSynchronizer$Node{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AbstractQueuedLongSynchronizer{
                    toString(): string;
                    acquire(param0: number);
                    acquireShared(param0: number);
                    acquireSharedInterruptibly(param0: number);
                    tryAcquireSharedNanos(param0: number, param1: number): boolean;
                    releaseShared(param0: number): boolean;
                    hasContended(): boolean;
                    getFirstQueuedThread(): java.lang.Thread;
                    hasQueuedPredecessors(): boolean;
                    getExclusiveQueuedThreads(): java.util.Collection;
                    getSharedQueuedThreads(): java.util.Collection;
                    owns(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject): boolean;
                    hasQueuedThreads(): boolean;
                    getQueueLength(): number;
                    getQueuedThreads(): java.util.Collection;
                    hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject): number;
                    getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject): java.util.Collection;
                    acquireInterruptibly(param0: number);
                    tryAcquireNanos(param0: number, param1: number): boolean;
                    release(param0: number): boolean;
                    isQueued(param0: java.lang.Thread): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantLock$FairSync{
                    toString(): string;
                    acquire(param0: number);
                    acquireShared(param0: number);
                    acquireSharedInterruptibly(param0: number);
                    tryAcquireSharedNanos(param0: number, param1: number): boolean;
                    releaseShared(param0: number): boolean;
                    hasContended(): boolean;
                    getFirstQueuedThread(): java.lang.Thread;
                    hasQueuedPredecessors(): boolean;
                    getExclusiveQueuedThreads(): java.util.Collection;
                    getSharedQueuedThreads(): java.util.Collection;
                    owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    hasQueuedThreads(): boolean;
                    getQueueLength(): number;
                    getQueuedThreads(): java.util.Collection;
                    hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                    getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                    acquireInterruptibly(param0: number);
                    tryAcquireNanos(param0: number, param1: number): boolean;
                    release(param0: number): boolean;
                    isQueued(param0: java.lang.Thread): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantReadWriteLock$FairSync{
                    toString(): string;
                    acquire(param0: number);
                    acquireShared(param0: number);
                    acquireSharedInterruptibly(param0: number);
                    tryAcquireSharedNanos(param0: number, param1: number): boolean;
                    releaseShared(param0: number): boolean;
                    hasContended(): boolean;
                    getFirstQueuedThread(): java.lang.Thread;
                    hasQueuedPredecessors(): boolean;
                    getExclusiveQueuedThreads(): java.util.Collection;
                    getSharedQueuedThreads(): java.util.Collection;
                    owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    hasQueuedThreads(): boolean;
                    getQueueLength(): number;
                    getQueuedThreads(): java.util.Collection;
                    hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                    getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                    acquireInterruptibly(param0: number);
                    tryAcquireNanos(param0: number, param1: number): boolean;
                    release(param0: number): boolean;
                    isQueued(param0: java.lang.Thread): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantReadWriteLock$Sync$HoldCounter{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class StampedLock$ReadLockView{
                    lock();
                    lockInterruptibly();
                    tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    tryLock(): boolean;
                    unlock();
                    newCondition(): java.util.concurrent.locks.Condition;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class StampedLock$ReadWriteLockView{
                    readLock(): java.util.concurrent.locks.Lock;
                    writeLock(): java.util.concurrent.locks.Lock;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class StampedLock$WNode{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class StampedLock$WriteLockView{
                    lock();
                    lockInterruptibly();
                    tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    tryLock(): boolean;
                    unlock();
                    newCondition(): java.util.concurrent.locks.Condition;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class StampedLock{
                    toString(): string;
                    unlock(param0: number);
                    tryWriteLock(): number;
                    tryWriteLock(param0: number, param1: java.util.concurrent.TimeUnit): number;
                    tryReadLock(param0: number, param1: java.util.concurrent.TimeUnit): number;
                    tryReadLock(): number;
                    getReadLockCount(): number;
                    isWriteLocked(): boolean;
                    readLock(): number;
                    readLockInterruptibly(): number;
                    writeLock(): number;
                    asReadLock(): java.util.concurrent.locks.Lock;
                    asWriteLock(): java.util.concurrent.locks.Lock;
                    writeLockInterruptibly(): number;
                    tryOptimisticRead(): number;
                    unlockWrite(param0: number);
                    unlockRead(param0: number);
                    tryConvertToWriteLock(param0: number): number;
                    tryConvertToReadLock(param0: number): number;
                    tryConvertToOptimisticRead(param0: number): number;
                    tryUnlockWrite(): boolean;
                    tryUnlockRead(): boolean;
                    isReadLocked(): boolean;
                    asReadWriteLock(): java.util.concurrent.locks.ReadWriteLock;
                    validate(param0: number): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantReadWriteLock$WriteLock{
                    lock();
                    toString(): string;
                    lockInterruptibly();
                    tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    tryLock(): boolean;
                    unlock();
                    newCondition(): java.util.concurrent.locks.Condition;
                    getHoldCount(): number;
                    isHeldByCurrentThread(): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter{
                    initialValue(): java.util.concurrent.locks.ReentrantReadWriteLock$Sync$HoldCounter;
                    initialValue(): any;
                    remove();
                    get(): any;
                    set(param0: any);
                    static withInitial(param0: java.util.function.Supplier): java.lang.ThreadLocal;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantReadWriteLock$Sync{
                    toString(): string;
                    acquire(param0: number);
                    acquireShared(param0: number);
                    acquireSharedInterruptibly(param0: number);
                    tryAcquireSharedNanos(param0: number, param1: number): boolean;
                    releaseShared(param0: number): boolean;
                    hasContended(): boolean;
                    getFirstQueuedThread(): java.lang.Thread;
                    hasQueuedPredecessors(): boolean;
                    getExclusiveQueuedThreads(): java.util.Collection;
                    getSharedQueuedThreads(): java.util.Collection;
                    owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    hasQueuedThreads(): boolean;
                    getQueueLength(): number;
                    getQueuedThreads(): java.util.Collection;
                    hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                    getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                    acquireInterruptibly(param0: number);
                    tryAcquireNanos(param0: number, param1: number): boolean;
                    release(param0: number): boolean;
                    isQueued(param0: java.lang.Thread): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantReadWriteLock$ReadLock{
                    lock();
                    toString(): string;
                    lockInterruptibly();
                    tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    tryLock(): boolean;
                    unlock();
                    newCondition(): java.util.concurrent.locks.Condition;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantReadWriteLock$NonfairSync{
                    toString(): string;
                    acquire(param0: number);
                    acquireShared(param0: number);
                    acquireSharedInterruptibly(param0: number);
                    tryAcquireSharedNanos(param0: number, param1: number): boolean;
                    releaseShared(param0: number): boolean;
                    hasContended(): boolean;
                    getFirstQueuedThread(): java.lang.Thread;
                    hasQueuedPredecessors(): boolean;
                    getExclusiveQueuedThreads(): java.util.Collection;
                    getSharedQueuedThreads(): java.util.Collection;
                    owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    hasQueuedThreads(): boolean;
                    getQueueLength(): number;
                    getQueuedThreads(): java.util.Collection;
                    hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                    getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                    acquireInterruptibly(param0: number);
                    tryAcquireNanos(param0: number, param1: number): boolean;
                    release(param0: number): boolean;
                    isQueued(param0: java.lang.Thread): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantReadWriteLock{
                    toString(): string;
                    isFair(): boolean;
                    hasQueuedThreads(): boolean;
                    hasQueuedThread(param0: java.lang.Thread): boolean;
                    getQueueLength(): number;
                    hasWaiters(param0: java.util.concurrent.locks.Condition): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.Condition): number;
                    getReadLockCount(): number;
                    isWriteLocked(): boolean;
                    getWriteHoldCount(): number;
                    getReadHoldCount(): number;
                    readLock(): java.util.concurrent.locks.Lock;
                    readLock(): java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock;
                    writeLock(): java.util.concurrent.locks.Lock;
                    writeLock(): java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock;
                    isWriteLockedByCurrentThread(): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantLock$Sync{
                    toString(): string;
                    acquire(param0: number);
                    acquireShared(param0: number);
                    acquireSharedInterruptibly(param0: number);
                    tryAcquireSharedNanos(param0: number, param1: number): boolean;
                    releaseShared(param0: number): boolean;
                    hasContended(): boolean;
                    getFirstQueuedThread(): java.lang.Thread;
                    hasQueuedPredecessors(): boolean;
                    getExclusiveQueuedThreads(): java.util.Collection;
                    getSharedQueuedThreads(): java.util.Collection;
                    owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    hasQueuedThreads(): boolean;
                    getQueueLength(): number;
                    getQueuedThreads(): java.util.Collection;
                    hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                    getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                    acquireInterruptibly(param0: number);
                    tryAcquireNanos(param0: number, param1: number): boolean;
                    release(param0: number): boolean;
                    isQueued(param0: java.lang.Thread): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantLock$NonfairSync{
                    toString(): string;
                    acquire(param0: number);
                    acquireShared(param0: number);
                    acquireSharedInterruptibly(param0: number);
                    tryAcquireSharedNanos(param0: number, param1: number): boolean;
                    releaseShared(param0: number): boolean;
                    hasContended(): boolean;
                    getFirstQueuedThread(): java.lang.Thread;
                    hasQueuedPredecessors(): boolean;
                    getExclusiveQueuedThreads(): java.util.Collection;
                    getSharedQueuedThreads(): java.util.Collection;
                    owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    hasQueuedThreads(): boolean;
                    getQueueLength(): number;
                    getQueuedThreads(): java.util.Collection;
                    hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                    getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                    acquireInterruptibly(param0: number);
                    tryAcquireNanos(param0: number, param1: number): boolean;
                    release(param0: number): boolean;
                    isQueued(param0: java.lang.Thread): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReentrantLock{
                    lock();
                    toString(): string;
                    lockInterruptibly();
                    tryLock(): boolean;
                    tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    unlock();
                    newCondition(): java.util.concurrent.locks.Condition;
                    getHoldCount(): number;
                    isHeldByCurrentThread(): boolean;
                    isLocked(): boolean;
                    isFair(): boolean;
                    hasQueuedThreads(): boolean;
                    hasQueuedThread(param0: java.lang.Thread): boolean;
                    getQueueLength(): number;
                    hasWaiters(param0: java.util.concurrent.locks.Condition): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.Condition): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class ReadWriteLock{
                    readLock(): java.util.concurrent.locks.Lock;
                    writeLock(): java.util.concurrent.locks.Lock;
                }
                class LockSupport{
                    static park();
                    static park(param0: any);
                    static unpark(param0: java.lang.Thread);
                    static parkUntil(param0: number);
                    static parkUntil(param0: any, param1: number);
                    static getBlocker(param0: java.lang.Thread): any;
                    static parkNanos(param0: any, param1: number);
                    static parkNanos(param0: number);
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class Lock{
                    lock();
                    lockInterruptibly();
                    tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    tryLock(): boolean;
                    unlock();
                    newCondition(): java.util.concurrent.locks.Condition;
                }
                class Condition{
                    signalAll();
                    awaitUninterruptibly();
                    awaitUntil(param0: java.util.Date): boolean;
                    signal();
                    await();
                    await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    awaitNanos(param0: number): number;
                }
                class AbstractQueuedSynchronizer$Node{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AbstractQueuedSynchronizer$ConditionObject{
                    signalAll();
                    awaitUninterruptibly();
                    awaitUntil(param0: java.util.Date): boolean;
                    signal();
                    await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    await();
                    awaitNanos(param0: number): number;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AbstractQueuedSynchronizer{
                    toString(): string;
                    acquire(param0: number);
                    acquireShared(param0: number);
                    acquireSharedInterruptibly(param0: number);
                    tryAcquireSharedNanos(param0: number, param1: number): boolean;
                    releaseShared(param0: number): boolean;
                    hasContended(): boolean;
                    getFirstQueuedThread(): java.lang.Thread;
                    hasQueuedPredecessors(): boolean;
                    getExclusiveQueuedThreads(): java.util.Collection;
                    getSharedQueuedThreads(): java.util.Collection;
                    owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    hasQueuedThreads(): boolean;
                    getQueueLength(): number;
                    getQueuedThreads(): java.util.Collection;
                    hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                    getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                    getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                    acquireInterruptibly(param0: number);
                    tryAcquireNanos(param0: number, param1: number): boolean;
                    release(param0: number): boolean;
                    isQueued(param0: java.lang.Thread): boolean;
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
                class AbstractOwnableSynchronizer{
                    wait(param0: number, param1: number);
                    wait(param0: number);
                    wait();
                    equals(param0: any): boolean;
                    toString(): string;
                    hashCode(): number;
                    getClass(): java.lang.Class;
                    notify();
                    notifyAll();
                }
            }
            class TimeUnit$7{
                toMillis(param0: number): number;
                convert(param0: number, param1: java.util.concurrent.TimeUnit): number;
                toNanos(param0: number): number;
                toMicros(param0: number): number;
                toSeconds(param0: number): number;
                toMinutes(param0: number): number;
                toHours(param0: number): number;
                toDays(param0: number): number;
                static values(): any[];
                static valueOf(param0: string): java.util.concurrent.TimeUnit;
                sleep(param0: number);
                timedWait(param0: any, param1: number);
                timedJoin(param0: java.lang.Thread, param1: number);
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeUnit$6{
                toMillis(param0: number): number;
                convert(param0: number, param1: java.util.concurrent.TimeUnit): number;
                toNanos(param0: number): number;
                toMicros(param0: number): number;
                toSeconds(param0: number): number;
                toMinutes(param0: number): number;
                toHours(param0: number): number;
                toDays(param0: number): number;
                static values(): any[];
                static valueOf(param0: string): java.util.concurrent.TimeUnit;
                sleep(param0: number);
                timedWait(param0: any, param1: number);
                timedJoin(param0: java.lang.Thread, param1: number);
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeUnit$5{
                toMillis(param0: number): number;
                convert(param0: number, param1: java.util.concurrent.TimeUnit): number;
                toNanos(param0: number): number;
                toMicros(param0: number): number;
                toSeconds(param0: number): number;
                toMinutes(param0: number): number;
                toHours(param0: number): number;
                toDays(param0: number): number;
                static values(): any[];
                static valueOf(param0: string): java.util.concurrent.TimeUnit;
                sleep(param0: number);
                timedWait(param0: any, param1: number);
                timedJoin(param0: java.lang.Thread, param1: number);
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeUnit$4{
                toMillis(param0: number): number;
                convert(param0: number, param1: java.util.concurrent.TimeUnit): number;
                toNanos(param0: number): number;
                toMicros(param0: number): number;
                toSeconds(param0: number): number;
                toMinutes(param0: number): number;
                toHours(param0: number): number;
                toDays(param0: number): number;
                static values(): any[];
                static valueOf(param0: string): java.util.concurrent.TimeUnit;
                sleep(param0: number);
                timedWait(param0: any, param1: number);
                timedJoin(param0: java.lang.Thread, param1: number);
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeUnit$3{
                toMillis(param0: number): number;
                convert(param0: number, param1: java.util.concurrent.TimeUnit): number;
                toNanos(param0: number): number;
                toMicros(param0: number): number;
                toSeconds(param0: number): number;
                toMinutes(param0: number): number;
                toHours(param0: number): number;
                toDays(param0: number): number;
                static values(): any[];
                static valueOf(param0: string): java.util.concurrent.TimeUnit;
                sleep(param0: number);
                timedWait(param0: any, param1: number);
                timedJoin(param0: java.lang.Thread, param1: number);
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeUnit$2{
                toMillis(param0: number): number;
                convert(param0: number, param1: java.util.concurrent.TimeUnit): number;
                toNanos(param0: number): number;
                toMicros(param0: number): number;
                toSeconds(param0: number): number;
                toMinutes(param0: number): number;
                toHours(param0: number): number;
                toDays(param0: number): number;
                static values(): any[];
                static valueOf(param0: string): java.util.concurrent.TimeUnit;
                sleep(param0: number);
                timedWait(param0: any, param1: number);
                timedJoin(param0: java.lang.Thread, param1: number);
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeUnit$1{
                toMillis(param0: number): number;
                convert(param0: number, param1: java.util.concurrent.TimeUnit): number;
                toNanos(param0: number): number;
                toMicros(param0: number): number;
                toSeconds(param0: number): number;
                toMinutes(param0: number): number;
                toHours(param0: number): number;
                toDays(param0: number): number;
                static values(): any[];
                static valueOf(param0: string): java.util.concurrent.TimeUnit;
                sleep(param0: number);
                timedWait(param0: any, param1: number);
                timedJoin(param0: java.lang.Thread, param1: number);
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeUnit{
                static values(): any[];
                static valueOf(param0: string): java.util.concurrent.TimeUnit;
                sleep(param0: number);
                toMillis(param0: number): number;
                convert(param0: number, param1: java.util.concurrent.TimeUnit): number;
                toNanos(param0: number): number;
                toMicros(param0: number): number;
                toSeconds(param0: number): number;
                toMinutes(param0: number): number;
                toHours(param0: number): number;
                toDays(param0: number): number;
                timedWait(param0: any, param1: number);
                timedJoin(param0: java.lang.Thread, param1: number);
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadPoolExecutor$Worker{
                run();
                lock();
                tryLock(): boolean;
                unlock();
                isLocked(): boolean;
                toString(): string;
                acquire(param0: number);
                acquireShared(param0: number);
                acquireSharedInterruptibly(param0: number);
                tryAcquireSharedNanos(param0: number, param1: number): boolean;
                releaseShared(param0: number): boolean;
                hasContended(): boolean;
                getFirstQueuedThread(): java.lang.Thread;
                hasQueuedPredecessors(): boolean;
                getExclusiveQueuedThreads(): java.util.Collection;
                getSharedQueuedThreads(): java.util.Collection;
                owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                hasQueuedThreads(): boolean;
                getQueueLength(): number;
                getQueuedThreads(): java.util.Collection;
                hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): boolean;
                getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): number;
                getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject): java.util.Collection;
                acquireInterruptibly(param0: number);
                tryAcquireNanos(param0: number, param1: number): boolean;
                release(param0: number): boolean;
                isQueued(param0: java.lang.Thread): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadPoolExecutor$AbortPolicy{
                rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadPoolExecutor{
                remove(param0: java.lang.Runnable): boolean;
                shutdown();
                toString(): string;
                execute(param0: java.lang.Runnable);
                getQueue(): java.util.concurrent.BlockingQueue;
                allowCoreThreadTimeOut(param0: boolean);
                getPoolSize(): number;
                shutdownNow(): java.util.List;
                isTerminated(): boolean;
                isTerminating(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                setThreadFactory(param0: java.util.concurrent.ThreadFactory);
                getThreadFactory(): java.util.concurrent.ThreadFactory;
                setRejectedExecutionHandler(param0: java.util.concurrent.RejectedExecutionHandler);
                getRejectedExecutionHandler(): java.util.concurrent.RejectedExecutionHandler;
                setCorePoolSize(param0: number);
                getCorePoolSize(): number;
                prestartCoreThread(): boolean;
                prestartAllCoreThreads(): number;
                allowsCoreThreadTimeOut(): boolean;
                setMaximumPoolSize(param0: number);
                getMaximumPoolSize(): number;
                setKeepAliveTime(param0: number, param1: java.util.concurrent.TimeUnit);
                getKeepAliveTime(param0: java.util.concurrent.TimeUnit): number;
                getActiveCount(): number;
                getLargestPoolSize(): number;
                getTaskCount(): number;
                getCompletedTaskCount(): number;
                purge();
                invokeAll(param0: java.util.Collection): java.util.List;
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                invokeAny(param0: java.util.Collection): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ThreadFactory{
                newThread(param0: java.lang.Runnable): java.lang.Thread;
            }
            class SynchronousQueue$Transferer{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SynchronousQueue$TransferStack$SNode{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SynchronousQueue$TransferStack{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SynchronousQueue{
                remove(param0: any): boolean;
                put(param0: any);
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(): any[];
                toArray(param0: any[]): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                poll(): any;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                peek(): any;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offer(param0: any): boolean;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                drainTo(param0: java.util.Collection): number;
                add(param0: any): boolean;
                remove(): any;
                addAll(param0: java.util.Collection): boolean;
                element(): any;
                toString(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class RejectedExecutionHandler{
                rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor);
            }
            class Executors{
                static callable(param0: java.lang.Runnable, param1: any): java.util.concurrent.Callable;
                static callable(param0: java.lang.Runnable): java.util.concurrent.Callable;
                static callable(param0: java.security.PrivilegedAction): java.util.concurrent.Callable;
                static callable(param0: java.security.PrivilegedExceptionAction): java.util.concurrent.Callable;
                static defaultThreadFactory(): java.util.concurrent.ThreadFactory;
                static newFixedThreadPool(param0: number): java.util.concurrent.ExecutorService;
                static newFixedThreadPool(param0: number, param1: java.util.concurrent.ThreadFactory): java.util.concurrent.ExecutorService;
                static newWorkStealingPool(): java.util.concurrent.ExecutorService;
                static newWorkStealingPool(param0: number): java.util.concurrent.ExecutorService;
                static newSingleThreadExecutor(): java.util.concurrent.ExecutorService;
                static newSingleThreadExecutor(param0: java.util.concurrent.ThreadFactory): java.util.concurrent.ExecutorService;
                static newCachedThreadPool(param0: java.util.concurrent.ThreadFactory): java.util.concurrent.ExecutorService;
                static newCachedThreadPool(): java.util.concurrent.ExecutorService;
                static newSingleThreadScheduledExecutor(param0: java.util.concurrent.ThreadFactory): java.util.concurrent.ScheduledExecutorService;
                static newSingleThreadScheduledExecutor(): java.util.concurrent.ScheduledExecutorService;
                static newScheduledThreadPool(param0: number): java.util.concurrent.ScheduledExecutorService;
                static newScheduledThreadPool(param0: number, param1: java.util.concurrent.ThreadFactory): java.util.concurrent.ScheduledExecutorService;
                static unconfigurableExecutorService(param0: java.util.concurrent.ExecutorService): java.util.concurrent.ExecutorService;
                static unconfigurableScheduledExecutorService(param0: java.util.concurrent.ScheduledExecutorService): java.util.concurrent.ScheduledExecutorService;
                static privilegedThreadFactory(): java.util.concurrent.ThreadFactory;
                static privilegedCallable(param0: java.util.concurrent.Callable): java.util.concurrent.Callable;
                static privilegedCallableUsingCurrentClassLoader(param0: java.util.concurrent.Callable): java.util.concurrent.Callable;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ExecutorService{
                shutdown();
                invokeAll(param0: java.util.Collection): java.util.List;
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                shutdownNow(): java.util.List;
                isTerminated(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                invokeAny(param0: java.util.Collection): any;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                execute(param0: java.lang.Runnable);
            }
            class Executor{
                execute(param0: java.lang.Runnable);
            }
            class Delayed{
                getDelay(param0: java.util.concurrent.TimeUnit): number;
                compareTo(param0: any): number;
            }
            class DelayQueue{
                add(param0: any): boolean;
                add(param0: java.util.concurrent.Delayed): boolean;
                remove(param0: any): boolean;
                put(param0: any);
                put(param0: java.util.concurrent.Delayed);
                clear();
                size(): number;
                toArray(): any[];
                toArray(param0: any[]): any[];
                iterator(): java.util.Iterator;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): java.util.concurrent.Delayed;
                poll(): java.util.concurrent.Delayed;
                poll(): any;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                peek(): any;
                peek(): java.util.concurrent.Delayed;
                offer(param0: java.util.concurrent.Delayed, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                offer(param0: java.util.concurrent.Delayed): boolean;
                offer(param0: any): boolean;
                take(): java.util.concurrent.Delayed;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                remove(): any;
                addAll(param0: java.util.Collection): boolean;
                element(): any;
                toString(): string;
                isEmpty(): boolean;
                contains(param0: any): boolean;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                spliterator(): java.util.Spliterator;
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class CopyOnWriteArrayList{
                add(param0: any): boolean;
                add(param0: number, param1: any);
                remove(param0: any): boolean;
                remove(param0: number): any;
                get(param0: number): any;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                clone(): any;
                indexOf(param0: any, param1: number): number;
                indexOf(param0: any): number;
                clear();
                isEmpty(): boolean;
                lastIndexOf(param0: any): number;
                lastIndexOf(param0: any, param1: number): number;
                contains(param0: any): boolean;
                replaceAll(param0: java.util.function.UnaryOperator);
                size(): number;
                subList(param0: number, param1: number): java.util.List;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                addAll(param0: number, param1: java.util.Collection): boolean;
                forEach(param0: java.util.function.Consumer);
                set(param0: number, param1: any): any;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                listIterator(): java.util.ListIterator;
                listIterator(param0: number): java.util.ListIterator;
                removeIf(param0: java.util.function.Predicate): boolean;
                sort(param0: java.util.Comparator);
                addAllAbsent(param0: java.util.Collection): number;
                addIfAbsent(param0: any): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                parallelStream(): java.util.stream.Stream;
            }
            class ConcurrentMap{
                remove(param0: any, param1: any): boolean;
                replace(param0: any, param1: any, param2: any): boolean;
                replace(param0: any, param1: any): any;
                replaceAll(param0: java.util.function.BiFunction);
                putIfAbsent(param0: any, param1: any): any;
                forEach(param0: java.util.function.BiConsumer);
                getOrDefault(param0: any, param1: any): any;
                computeIfAbsent(param0: any, param1: java.util.function.Function): any;
                computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
                compute(param0: any, param1: java.util.function.BiFunction): any;
                merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
                remove(param0: any): any;
                get(param0: any): any;
                put(param0: any, param1: any): any;
                equals(param0: any): boolean;
                values(): java.util.Collection;
                hashCode(): number;
                clear();
                isEmpty(): boolean;
                size(): number;
                entrySet(): java.util.Set;
                putAll(param0: java.util.Map);
                keySet(): java.util.Set;
                containsValue(param0: any): boolean;
                containsKey(param0: any): boolean;
            }
            class ConcurrentHashMap$ValuesView{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                contains(param0: any): boolean;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                forEach(param0: java.util.function.Consumer);
                toString(): string;
                clear();
                isEmpty(): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                getMap(): java.util.concurrent.ConcurrentHashMap;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
            }
            class ConcurrentHashMap$Traverser{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$Segment{
                lock();
                toString(): string;
                lockInterruptibly();
                tryLock(): boolean;
                tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                unlock();
                newCondition(): java.util.concurrent.locks.Condition;
                getHoldCount(): number;
                isHeldByCurrentThread(): boolean;
                isLocked(): boolean;
                isFair(): boolean;
                hasQueuedThreads(): boolean;
                hasQueuedThread(param0: java.lang.Thread): boolean;
                getQueueLength(): number;
                hasWaiters(param0: java.util.concurrent.locks.Condition): boolean;
                getWaitQueueLength(param0: java.util.concurrent.locks.Condition): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$Node{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getValue(): any;
                getKey(): any;
                setValue(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$KeySetView{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                equals(param0: any): boolean;
                hashCode(): number;
                contains(param0: any): boolean;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                forEach(param0: java.util.function.Consumer);
                getMap(): java.util.concurrent.ConcurrentHashMap;
                getMappedValue(): any;
                toString(): string;
                clear();
                isEmpty(): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
            }
            class ConcurrentHashMap$KeyIterator{
                next(): any;
                nextElement(): any;
                remove();
                hasNext(): boolean;
                hasMoreElements(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ConcurrentHashMap$ForwardingNode{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getValue(): any;
                getKey(): any;
                setValue(param0: any): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$EntrySetView{
                add(param0: any): boolean;
                add(param0: java.util.Map$Entry): boolean;
                remove(param0: any): boolean;
                equals(param0: any): boolean;
                hashCode(): number;
                contains(param0: any): boolean;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                forEach(param0: java.util.function.Consumer);
                toString(): string;
                clear();
                isEmpty(): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                getMap(): java.util.concurrent.ConcurrentHashMap;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
            }
            class ConcurrentHashMap$CounterCell{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap$CollectionView{
                remove(param0: any): boolean;
                toString(): string;
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                getMap(): java.util.concurrent.ConcurrentHashMap;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                add(param0: any): boolean;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class ConcurrentHashMap$BaseIterator{
                remove();
                hasNext(): boolean;
                hasMoreElements(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ConcurrentHashMap{
                remove(param0: any, param1: any): boolean;
                remove(param0: any): any;
                get(param0: any): any;
                put(param0: any, param1: any): any;
                equals(param0: any): boolean;
                toString(): string;
                values(): java.util.Collection;
                hashCode(): number;
                clear();
                isEmpty(): boolean;
                replace(param0: any, param1: any, param2: any): boolean;
                replace(param0: any, param1: any): any;
                contains(param0: any): boolean;
                replaceAll(param0: java.util.function.BiFunction);
                size(): number;
                entrySet(): java.util.Set;
                putAll(param0: java.util.Map);
                putIfAbsent(param0: any, param1: any): any;
                elements(): java.util.Enumeration;
                forEach(param0: number, param1: java.util.function.BiFunction, param2: java.util.function.Consumer);
                forEach(param0: java.util.function.BiConsumer);
                forEach(param0: number, param1: java.util.function.BiConsumer);
                keys(): java.util.Enumeration;
                keySet(param0: any): java.util.concurrent.ConcurrentHashMap$KeySetView;
                keySet(): java.util.Set;
                keySet(): java.util.concurrent.ConcurrentHashMap$KeySetView;
                containsValue(param0: any): boolean;
                containsKey(param0: any): boolean;
                getOrDefault(param0: any, param1: any): any;
                computeIfAbsent(param0: any, param1: java.util.function.Function): any;
                computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
                compute(param0: any, param1: java.util.function.BiFunction): any;
                merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
                search(param0: number, param1: java.util.function.BiFunction): any;
                mappingCount(): number;
                static newKeySet(): java.util.concurrent.ConcurrentHashMap$KeySetView;
                static newKeySet(param0: number): java.util.concurrent.ConcurrentHashMap$KeySetView;
                reduce(param0: number, param1: java.util.function.BiFunction, param2: java.util.function.BiFunction): any;
                reduceToDouble(param0: number, param1: java.util.function.ToDoubleBiFunction, param2: number, param3: java.util.function.DoubleBinaryOperator): number;
                reduceToLong(param0: number, param1: java.util.function.ToLongBiFunction, param2: number, param3: java.util.function.LongBinaryOperator): number;
                reduceToInt(param0: number, param1: java.util.function.ToIntBiFunction, param2: number, param3: java.util.function.IntBinaryOperator): number;
                forEachKey(param0: number, param1: java.util.function.Consumer);
                forEachKey(param0: number, param1: java.util.function.Function, param2: java.util.function.Consumer);
                searchKeys(param0: number, param1: java.util.function.Function): any;
                reduceKeys(param0: number, param1: java.util.function.Function, param2: java.util.function.BiFunction): any;
                reduceKeys(param0: number, param1: java.util.function.BiFunction): any;
                reduceKeysToDouble(param0: number, param1: java.util.function.ToDoubleFunction, param2: number, param3: java.util.function.DoubleBinaryOperator): number;
                reduceKeysToLong(param0: number, param1: java.util.function.ToLongFunction, param2: number, param3: java.util.function.LongBinaryOperator): number;
                reduceKeysToInt(param0: number, param1: java.util.function.ToIntFunction, param2: number, param3: java.util.function.IntBinaryOperator): number;
                forEachValue(param0: number, param1: java.util.function.Consumer);
                forEachValue(param0: number, param1: java.util.function.Function, param2: java.util.function.Consumer);
                searchValues(param0: number, param1: java.util.function.Function): any;
                reduceValues(param0: number, param1: java.util.function.BiFunction): any;
                reduceValues(param0: number, param1: java.util.function.Function, param2: java.util.function.BiFunction): any;
                reduceValuesToDouble(param0: number, param1: java.util.function.ToDoubleFunction, param2: number, param3: java.util.function.DoubleBinaryOperator): number;
                reduceValuesToLong(param0: number, param1: java.util.function.ToLongFunction, param2: number, param3: java.util.function.LongBinaryOperator): number;
                reduceValuesToInt(param0: number, param1: java.util.function.ToIntFunction, param2: number, param3: java.util.function.IntBinaryOperator): number;
                forEachEntry(param0: number, param1: java.util.function.Consumer);
                forEachEntry(param0: number, param1: java.util.function.Function, param2: java.util.function.Consumer);
                searchEntries(param0: number, param1: java.util.function.Function): any;
                reduceEntries(param0: number, param1: java.util.function.BiFunction): java.util.Map$Entry;
                reduceEntries(param0: number, param1: java.util.function.Function, param2: java.util.function.BiFunction): any;
                reduceEntriesToDouble(param0: number, param1: java.util.function.ToDoubleFunction, param2: number, param3: java.util.function.DoubleBinaryOperator): number;
                reduceEntriesToLong(param0: number, param1: java.util.function.ToLongFunction, param2: number, param3: java.util.function.LongBinaryOperator): number;
                reduceEntriesToInt(param0: number, param1: java.util.function.ToIntFunction, param2: number, param3: java.util.function.IntBinaryOperator): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class BlockingQueue{
                add(param0: any): boolean;
                remove(param0: any): boolean;
                put(param0: any);
                contains(param0: any): boolean;
                poll(param0: number, param1: java.util.concurrent.TimeUnit): any;
                offer(param0: any): boolean;
                offer(param0: any, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                take(): any;
                remainingCapacity(): number;
                drainTo(param0: java.util.Collection): number;
                drainTo(param0: java.util.Collection, param1: number): number;
                remove(): any;
                poll(): any;
                peek(): any;
                element(): any;
                equals(param0: any): boolean;
                hashCode(): number;
                clear();
                isEmpty(): boolean;
                size(): number;
                toArray(param0: any[]): any[];
                toArray(): any[];
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                addAll(param0: java.util.Collection): boolean;
                stream(): java.util.stream.Stream;
                containsAll(param0: java.util.Collection): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
            }
            class AbstractExecutorService{
                invokeAll(param0: java.util.Collection): java.util.List;
                invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                submit(param0: java.lang.Runnable, param1: any): java.util.concurrent.Future;
                invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): any;
                invokeAny(param0: java.util.Collection): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                shutdown();
                shutdownNow(): java.util.List;
                isTerminated(): boolean;
                isShutdown(): boolean;
                awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                execute(param0: java.lang.Runnable);
            }
        }
        namespace function{
            class BiConsumer{
                accept(param0: any, param1: any);
                andThen(param0: java.util.function.BiConsumer): java.util.function.BiConsumer;
            }
            class BiPredicate{
                test(param0: any, param1: any): boolean;
                and(param0: java.util.function.BiPredicate): java.util.function.BiPredicate;
                or(param0: java.util.function.BiPredicate): java.util.function.BiPredicate;
                negate(): java.util.function.BiPredicate;
            }
            class BinaryOperator{
                static maxBy(param0: java.util.Comparator): java.util.function.BinaryOperator;
                static minBy(param0: java.util.Comparator): java.util.function.BinaryOperator;
                apply(param0: any, param1: any): any;
                andThen(param0: java.util.function.Function): java.util.function.BiFunction;
            }
            class BooleanSupplier{
                getAsBoolean(): boolean;
            }
            class Consumer{
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class DoubleBinaryOperator{
                applyAsDouble(param0: number, param1: number): number;
            }
            class DoubleConsumer{
                accept(param0: number);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoubleFunction{
                apply(param0: number): any;
            }
            class DoublePredicate{
                test(param0: number): boolean;
                and(param0: java.util.function.DoublePredicate): java.util.function.DoublePredicate;
                or(param0: java.util.function.DoublePredicate): java.util.function.DoublePredicate;
                negate(): java.util.function.DoublePredicate;
            }
            class DoubleSupplier{
                getAsDouble(): number;
            }
            class DoubleToIntFunction{
                applyAsInt(param0: number): number;
            }
            class DoubleToLongFunction{
                applyAsLong(param0: number): number;
            }
            class DoubleUnaryOperator{
                static identity(): java.util.function.DoubleUnaryOperator;
                applyAsDouble(param0: number): number;
                compose(param0: java.util.function.DoubleUnaryOperator): java.util.function.DoubleUnaryOperator;
                andThen(param0: java.util.function.DoubleUnaryOperator): java.util.function.DoubleUnaryOperator;
            }
            class Function{
                apply(param0: any): any;
                static identity(): java.util.function.Function;
                compose(param0: java.util.function.Function): java.util.function.Function;
                andThen(param0: java.util.function.Function): java.util.function.Function;
            }
            class IntBinaryOperator{
                applyAsInt(param0: number, param1: number): number;
            }
            class IntConsumer{
                accept(param0: number);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntFunction{
                apply(param0: number): any;
            }
            class IntPredicate{
                test(param0: number): boolean;
                and(param0: java.util.function.IntPredicate): java.util.function.IntPredicate;
                or(param0: java.util.function.IntPredicate): java.util.function.IntPredicate;
                negate(): java.util.function.IntPredicate;
            }
            class IntSupplier{
                getAsInt(): number;
            }
            class IntToDoubleFunction{
                applyAsDouble(param0: number): number;
            }
            class IntToLongFunction{
                applyAsLong(param0: number): number;
            }
            class IntUnaryOperator{
                static identity(): java.util.function.IntUnaryOperator;
                applyAsInt(param0: number): number;
                compose(param0: java.util.function.IntUnaryOperator): java.util.function.IntUnaryOperator;
                andThen(param0: java.util.function.IntUnaryOperator): java.util.function.IntUnaryOperator;
            }
            class LongBinaryOperator{
                applyAsLong(param0: number, param1: number): number;
            }
            class LongConsumer{
                accept(param0: number);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongFunction{
                apply(param0: number): any;
            }
            class LongPredicate{
                test(param0: number): boolean;
                and(param0: java.util.function.LongPredicate): java.util.function.LongPredicate;
                or(param0: java.util.function.LongPredicate): java.util.function.LongPredicate;
                negate(): java.util.function.LongPredicate;
            }
            class LongSupplier{
                getAsLong(): number;
            }
            class LongToDoubleFunction{
                applyAsDouble(param0: number): number;
            }
            class LongToIntFunction{
                applyAsInt(param0: number): number;
            }
            class LongUnaryOperator{
                static identity(): java.util.function.LongUnaryOperator;
                applyAsLong(param0: number): number;
                compose(param0: java.util.function.LongUnaryOperator): java.util.function.LongUnaryOperator;
                andThen(param0: java.util.function.LongUnaryOperator): java.util.function.LongUnaryOperator;
            }
            class ObjDoubleConsumer{
                accept(param0: any, param1: number);
            }
            class ObjIntConsumer{
                accept(param0: any, param1: number);
            }
            class ObjLongConsumer{
                accept(param0: any, param1: number);
            }
            class Predicate{
                test(param0: any): boolean;
                and(param0: java.util.function.Predicate): java.util.function.Predicate;
                or(param0: java.util.function.Predicate): java.util.function.Predicate;
                negate(): java.util.function.Predicate;
                static isEqual(param0: any): java.util.function.Predicate;
            }
            class Supplier{
                get(): any;
            }
            class ToDoubleBiFunction{
                applyAsDouble(param0: any, param1: any): number;
            }
            class ToDoubleFunction{
                applyAsDouble(param0: any): number;
            }
            class ToIntBiFunction{
                applyAsInt(param0: any, param1: any): number;
            }
            class ToIntFunction{
                applyAsInt(param0: any): number;
            }
            class ToLongBiFunction{
                applyAsLong(param0: any, param1: any): number;
            }
            class ToLongFunction{
                applyAsLong(param0: any): number;
            }
            class UnaryOperator{
                static identity(): java.util.function.UnaryOperator;
                apply(param0: any): any;
                compose(param0: java.util.function.Function): java.util.function.Function;
                andThen(param0: java.util.function.Function): java.util.function.Function;
            }
            class BiFunction{
                apply(param0: any, param1: any): any;
                andThen(param0: java.util.function.Function): java.util.function.BiFunction;
            }
        }
        namespace jar{
            class JarException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarFile$1{
                hasMoreElements(): boolean;
                nextElement(): any;
                nextElement(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarFile$2{
                hasMoreElements(): boolean;
                nextElement(): any;
                nextElement(): java.util.jar.JarFile$JarFileEntry;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarFile$3{
                hasMoreElements(): boolean;
                nextElement(): any;
                nextElement(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarInputStream{
                read(param0: any[], param1: number, param2: number): number;
                getManifest(): java.util.jar.Manifest;
                getNextEntry(): java.util.zip.ZipEntry;
                getNextJarEntry(): java.util.jar.JarEntry;
                close();
                skip(param0: number): number;
                available(): number;
                closeEntry();
                read(): number;
                mark(param0: number);
                markSupported(): boolean;
                reset();
                read(param0: any[]): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarOutputStream{
                putNextEntry(param0: java.util.zip.ZipEntry);
                write(param0: any[], param1: number, param2: number);
                close();
                setMethod(param0: number);
                setComment(param0: string);
                closeEntry();
                setLevel(param0: number);
                finish();
                write(param0: number);
                flush();
                write(param0: any[]);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarVerifier$1{
                hasMoreElements(): boolean;
                nextElement(): any;
                nextElement(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarVerifier$2{
                hasMoreElements(): boolean;
                nextElement(): any;
                nextElement(): java.util.jar.JarEntry;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarVerifier$4{
                hasMoreElements(): boolean;
                nextElement(): any;
                nextElement(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarVerifier$VerifierCodeSource{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getLocation(): java.net.URL;
                getCertificates(): any[];
                implies(param0: java.security.CodeSource): boolean;
                getCodeSigners(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarVerifier$VerifierStream{
                read(param0: any[], param1: number, param2: number): number;
                read(): number;
                close();
                available(): number;
                read(param0: any[]): number;
                mark(param0: number);
                skip(param0: number): number;
                markSupported(): boolean;
                reset();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pack200$Packer{
                pack(param0: java.util.jar.JarInputStream, param1: java.io.OutputStream);
                pack(param0: java.util.jar.JarFile, param1: java.io.OutputStream);
                properties(): java.util.SortedMap;
                addPropertyChangeListener(param0: java.beans.PropertyChangeListener);
                removePropertyChangeListener(param0: java.beans.PropertyChangeListener);
            }
            class Pack200$Unpacker{
                unpack(param0: java.io.File, param1: java.util.jar.JarOutputStream);
                unpack(param0: java.io.InputStream, param1: java.util.jar.JarOutputStream);
                properties(): java.util.SortedMap;
                addPropertyChangeListener(param0: java.beans.PropertyChangeListener);
                removePropertyChangeListener(param0: java.beans.PropertyChangeListener);
            }
            class Pack200{
                static newPacker(): java.util.jar.Pack200$Packer;
                static newUnpacker(): java.util.jar.Pack200$Unpacker;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Manifest$FastInputStream{
                read(param0: any[], param1: number, param2: number): number;
                read(): number;
                readLine(param0: any[]): number;
                readLine(param0: any[], param1: number, param2: number): number;
                close();
                skip(param0: number): number;
                available(): number;
                peek(): number;
                read(param0: any[]): number;
                mark(param0: number);
                markSupported(): boolean;
                reset();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Manifest{
                equals(param0: any): boolean;
                hashCode(): number;
                clone(): any;
                clear();
                write(param0: java.io.OutputStream);
                read(param0: java.io.InputStream);
                getMainAttributes(): java.util.jar.Attributes;
                getEntries(): java.util.Map;
                getAttributes(param0: string): java.util.jar.Attributes;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JavaUtilJarAccessImpl{
                getCodeSource(param0: java.util.jar.JarFile, param1: java.net.URL, param2: string): java.security.CodeSource;
                getTrustedAttributes(param0: java.util.jar.Manifest, param1: string): java.util.jar.Attributes;
                jarFileHasClassPathAttribute(param0: java.util.jar.JarFile): boolean;
                ensureInitialization(param0: java.util.jar.JarFile);
                entryNames(param0: java.util.jar.JarFile, param1: any[]): java.util.Enumeration;
                entries2(param0: java.util.jar.JarFile): java.util.Enumeration;
                getCodeSources(param0: java.util.jar.JarFile, param1: java.net.URL): any[];
                setEagerValidation(param0: java.util.jar.JarFile, param1: boolean);
                getManifestDigests(param0: java.util.jar.JarFile): java.util.List;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarVerifier$3{
                hasMoreElements(): boolean;
                nextElement(): any;
                nextElement(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarVerifier{
                update(param0: number, param1: sun.security.util.ManifestEntryVerifier);
                update(param0: number, param1: any[], param2: number, param3: number, param4: sun.security.util.ManifestEntryVerifier);
                getCodeSource(param0: java.net.URL, param1: string): java.security.CodeSource;
                getCodeSource(param0: java.net.URL, param1: java.util.jar.JarFile, param2: java.util.jar.JarEntry): java.security.CodeSource;
                getCodeSigners(param0: java.util.jar.JarFile, param1: java.util.jar.JarEntry): any[];
                getCodeSigners(param0: string): any[];
                entryNames(param0: java.util.jar.JarFile, param1: any[]): java.util.Enumeration;
                entries2(param0: java.util.jar.JarFile, param1: java.util.Enumeration): java.util.Enumeration;
                getCodeSources(param0: java.util.jar.JarFile, param1: java.net.URL): any[];
                setEagerValidation(param0: boolean);
                getManifestDigests(): java.util.List;
                beginEntry(param0: java.util.jar.JarEntry, param1: sun.security.util.ManifestEntryVerifier);
                getCerts(param0: string): any[];
                getCerts(param0: java.util.jar.JarFile, param1: java.util.jar.JarEntry): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarFile$JarFileEntry{
                getCertificates(): any[];
                getCodeSigners(): any[];
                getAttributes(): java.util.jar.Attributes;
                toString(): string;
                hashCode(): number;
                clone(): any;
                getName(): string;
                getMethod(): number;
                getSize(): number;
                isDirectory(): boolean;
                getLastModifiedTime(): java.nio.file.attribute.FileTime;
                setLastModifiedTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                setSize(param0: number);
                getComment(): string;
                setTime(param0: number);
                getTime(): number;
                setLastAccessTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                getLastAccessTime(): java.nio.file.attribute.FileTime;
                setCreationTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                getCreationTime(): java.nio.file.attribute.FileTime;
                getCompressedSize(): number;
                setCompressedSize(param0: number);
                setCrc(param0: number);
                getCrc(): number;
                setMethod(param0: number);
                setExtra(param0: any[]);
                getExtra(): any[];
                setComment(param0: string);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarFile$JarEntryIterator{
                hasNext(): boolean;
                next(): any;
                next(): java.util.jar.JarEntry;
                hasMoreElements(): boolean;
                nextElement(): java.util.jar.JarEntry;
                nextElement(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                remove();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class JarFile{
                stream(): java.util.stream.Stream;
                getInputStream(param0: java.util.zip.ZipEntry): java.io.InputStream;
                getManifest(): java.util.jar.Manifest;
                entries(): java.util.Enumeration;
                getEntry(param0: string): java.util.zip.ZipEntry;
                getJarEntry(param0: string): java.util.jar.JarEntry;
                getName(): string;
                size(): number;
                close();
                getComment(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class JarEntry{
                getCertificates(): any[];
                getCodeSigners(): any[];
                getAttributes(): java.util.jar.Attributes;
                toString(): string;
                hashCode(): number;
                clone(): any;
                getName(): string;
                getMethod(): number;
                getSize(): number;
                isDirectory(): boolean;
                getLastModifiedTime(): java.nio.file.attribute.FileTime;
                setLastModifiedTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                setSize(param0: number);
                getComment(): string;
                setTime(param0: number);
                getTime(): number;
                setLastAccessTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                getLastAccessTime(): java.nio.file.attribute.FileTime;
                setCreationTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                getCreationTime(): java.nio.file.attribute.FileTime;
                getCompressedSize(): number;
                setCompressedSize(param0: number);
                setCrc(param0: number);
                getCrc(): number;
                setMethod(param0: number);
                setExtra(param0: any[]);
                getExtra(): any[];
                setComment(param0: string);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Attributes$Name{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Attributes{
                remove(param0: any): any;
                get(param0: any): any;
                put(param0: any, param1: any): any;
                equals(param0: any): boolean;
                values(): java.util.Collection;
                hashCode(): number;
                clone(): any;
                clear();
                isEmpty(): boolean;
                getValue(param0: java.util.jar.Attributes$Name): string;
                getValue(param0: string): string;
                size(): number;
                entrySet(): java.util.Set;
                putAll(param0: java.util.Map);
                keySet(): java.util.Set;
                containsValue(param0: any): boolean;
                containsKey(param0: any): boolean;
                putValue(param0: string, param1: string): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                toString(): string;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                remove(param0: any, param1: any): boolean;
                replace(param0: any, param1: any): any;
                replace(param0: any, param1: any, param2: any): boolean;
                replaceAll(param0: java.util.function.BiFunction);
                putIfAbsent(param0: any, param1: any): any;
                forEach(param0: java.util.function.BiConsumer);
                getOrDefault(param0: any, param1: any): any;
                computeIfAbsent(param0: any, param1: java.util.function.Function): any;
                computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
                compute(param0: any, param1: java.util.function.BiFunction): any;
                merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            }
        }
        namespace logging{
            class ConsoleHandler{
                close();
                publish(param0: java.util.logging.LogRecord);
                flush();
                isLoggable(param0: java.util.logging.LogRecord): boolean;
                setEncoding(param0: string);
                getEncoding(): string;
                setLevel(param0: java.util.logging.Level);
                setFilter(param0: java.util.logging.Filter);
                setFormatter(param0: java.util.logging.Formatter);
                getFormatter(): java.util.logging.Formatter;
                getFilter(): java.util.logging.Filter;
                setErrorManager(param0: java.util.logging.ErrorManager);
                getErrorManager(): java.util.logging.ErrorManager;
                getLevel(): java.util.logging.Level;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ErrorManager{
                error(param0: string, param1: java.lang.Exception, param2: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileHandler$1{
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileHandler$InitializationErrorManager{
                error(param0: string, param1: java.lang.Exception, param2: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileHandler$MeteredStream{
                write(param0: any[], param1: number, param2: number);
                write(param0: any[]);
                write(param0: number);
                flush();
                close();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileHandler{
                close();
                publish(param0: java.util.logging.LogRecord);
                flush();
                isLoggable(param0: java.util.logging.LogRecord): boolean;
                setEncoding(param0: string);
                getEncoding(): string;
                setLevel(param0: java.util.logging.Level);
                setFilter(param0: java.util.logging.Filter);
                setFormatter(param0: java.util.logging.Formatter);
                getFormatter(): java.util.logging.Formatter;
                getFilter(): java.util.logging.Filter;
                setErrorManager(param0: java.util.logging.ErrorManager);
                getErrorManager(): java.util.logging.ErrorManager;
                getLevel(): java.util.logging.Level;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Filter{
                isLoggable(param0: java.util.logging.LogRecord): boolean;
            }
            class Formatter{
                format(param0: java.util.logging.LogRecord): string;
                getHead(param0: java.util.logging.Handler): string;
                getTail(param0: java.util.logging.Handler): string;
                formatMessage(param0: java.util.logging.LogRecord): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Level$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$4{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$6{
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$7{
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$Beans{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogRecord{
                getMessage(): string;
                getParameters(): any[];
                setLevel(param0: java.util.logging.Level);
                getMillis(): number;
                getLevel(): java.util.logging.Level;
                getLoggerName(): string;
                setLoggerName(param0: string);
                getResourceBundle(): java.util.ResourceBundle;
                setResourceBundle(param0: java.util.ResourceBundle);
                getResourceBundleName(): string;
                setResourceBundleName(param0: string);
                getSequenceNumber(): number;
                setSequenceNumber(param0: number);
                getSourceClassName(): string;
                setSourceClassName(param0: string);
                getSourceMethodName(): string;
                setSourceMethodName(param0: string);
                setMessage(param0: string);
                setParameters(param0: any[]);
                getThreadID(): number;
                setThreadID(param0: number);
                setMillis(param0: number);
                getThrown(): java.lang.Throwable;
                setThrown(param0: java.lang.Throwable);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Logger$LoggerBundle{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Logger$SystemLoggerHelper$1{
                run(): string;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Logger$SystemLoggerHelper{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Logging{
                getLoggerNames(): java.util.List;
                getLoggerLevel(param0: string): string;
                setLoggerLevel(param0: string, param1: string);
                getParentLoggerName(param0: string): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LoggingMXBean{
                getLoggerNames(): java.util.List;
                getLoggerLevel(param0: string): string;
                setLoggerLevel(param0: string, param1: string);
                getParentLoggerName(param0: string): string;
            }
            class MemoryHandler{
                push();
                flush();
                close();
                isLoggable(param0: java.util.logging.LogRecord): boolean;
                publish(param0: java.util.logging.LogRecord);
                setPushLevel(param0: java.util.logging.Level);
                getPushLevel(): java.util.logging.Level;
                getEncoding(): string;
                setLevel(param0: java.util.logging.Level);
                setFilter(param0: java.util.logging.Filter);
                setFormatter(param0: java.util.logging.Formatter);
                setEncoding(param0: string);
                getFormatter(): java.util.logging.Formatter;
                getFilter(): java.util.logging.Filter;
                setErrorManager(param0: java.util.logging.ErrorManager);
                getErrorManager(): java.util.logging.ErrorManager;
                getLevel(): java.util.logging.Level;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SimpleFormatter{
                format(param0: java.util.logging.LogRecord): string;
                getHead(param0: java.util.logging.Handler): string;
                getTail(param0: java.util.logging.Handler): string;
                formatMessage(param0: java.util.logging.LogRecord): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SocketHandler{
                close();
                publish(param0: java.util.logging.LogRecord);
                flush();
                isLoggable(param0: java.util.logging.LogRecord): boolean;
                setEncoding(param0: string);
                getEncoding(): string;
                setLevel(param0: java.util.logging.Level);
                setFilter(param0: java.util.logging.Filter);
                setFormatter(param0: java.util.logging.Formatter);
                getFormatter(): java.util.logging.Formatter;
                getFilter(): java.util.logging.Filter;
                setErrorManager(param0: java.util.logging.ErrorManager);
                getErrorManager(): java.util.logging.ErrorManager;
                getLevel(): java.util.logging.Level;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamHandler{
                flush();
                close();
                isLoggable(param0: java.util.logging.LogRecord): boolean;
                publish(param0: java.util.logging.LogRecord);
                setEncoding(param0: string);
                getEncoding(): string;
                setLevel(param0: java.util.logging.Level);
                setFilter(param0: java.util.logging.Filter);
                setFormatter(param0: java.util.logging.Formatter);
                getFormatter(): java.util.logging.Formatter;
                getFilter(): java.util.logging.Filter;
                setErrorManager(param0: java.util.logging.ErrorManager);
                getErrorManager(): java.util.logging.ErrorManager;
                getLevel(): java.util.logging.Level;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class XMLFormatter{
                format(param0: java.util.logging.LogRecord): string;
                getHead(param0: java.util.logging.Handler): string;
                getTail(param0: java.util.logging.Handler): string;
                formatMessage(param0: java.util.logging.LogRecord): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LoggingProxyImpl{
                getProperty(param0: string): string;
                log(param0: any, param1: any, param2: string);
                log(param0: any, param1: any, param2: string, param3: java.lang.Throwable);
                log(param0: any, param1: any, param2: string, param3: any[]);
                parseLevel(param0: string): any;
                getLevelValue(param0: any): number;
                getLogger(param0: string): any;
                isLoggable(param0: any, param1: any): boolean;
                setLevel(param0: any, param1: any);
                getLevel(param0: any): any;
                getLevelName(param0: any): string;
                getLoggerNames(): java.util.List;
                getLoggerLevel(param0: string): string;
                setLoggerLevel(param0: string, param1: string);
                getParentLoggerName(param0: string): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LoggingPermission{
                equals(param0: any): boolean;
                hashCode(): number;
                implies(param0: java.security.Permission): boolean;
                getActions(): string;
                newPermissionCollection(): java.security.PermissionCollection;
                toString(): string;
                getName(): string;
                checkGuard(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Logger$1{
                run(): java.util.ResourceBundle;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Logger{
                log(param0: java.util.logging.Level, param1: string, param2: any[]);
                log(param0: java.util.logging.Level, param1: string, param2: java.lang.Throwable);
                log(param0: java.util.logging.Level, param1: java.lang.Throwable, param2: java.util.function.Supplier);
                log(param0: java.util.logging.Level, param1: string);
                log(param0: java.util.logging.Level, param1: string, param2: any);
                log(param0: java.util.logging.LogRecord);
                log(param0: java.util.logging.Level, param1: java.util.function.Supplier);
                getName(): string;
                getParent(): java.util.logging.Logger;
                setParent(param0: java.util.logging.Logger);
                static getGlobal(): java.util.logging.Logger;
                static getAnonymousLogger(param0: string): java.util.logging.Logger;
                static getAnonymousLogger(): java.util.logging.Logger;
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: java.lang.Throwable, param4: java.util.function.Supplier);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: java.util.function.Supplier);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: any[]);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: java.lang.Throwable);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: any);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: java.lang.Throwable);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: java.util.ResourceBundle, param4: string, param5: java.lang.Throwable);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: any);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: any[]);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: java.util.ResourceBundle, param4: string, param5: any[]);
                entering(param0: string, param1: string, param2: any[]);
                entering(param0: string, param1: string);
                entering(param0: string, param1: string, param2: any);
                exiting(param0: string, param1: string);
                exiting(param0: string, param1: string, param2: any);
                throwing(param0: string, param1: string, param2: java.lang.Throwable);
                severe(param0: java.util.function.Supplier);
                severe(param0: string);
                fine(param0: string);
                fine(param0: java.util.function.Supplier);
                finer(param0: java.util.function.Supplier);
                finer(param0: string);
                finest(param0: string);
                finest(param0: java.util.function.Supplier);
                removeHandler(param0: java.util.logging.Handler);
                getHandlers(): any[];
                setUseParentHandlers(param0: boolean);
                getUseParentHandlers(): boolean;
                info(param0: java.util.function.Supplier);
                info(param0: string);
                config(param0: string);
                config(param0: java.util.function.Supplier);
                static getLogger(param0: string, param1: string): java.util.logging.Logger;
                static getLogger(param0: string): java.util.logging.Logger;
                isLoggable(param0: java.util.logging.Level): boolean;
                setLevel(param0: java.util.logging.Level);
                setFilter(param0: java.util.logging.Filter);
                warning(param0: string);
                warning(param0: java.util.function.Supplier);
                getFilter(): java.util.logging.Filter;
                getLevel(): java.util.logging.Level;
                getResourceBundle(): java.util.ResourceBundle;
                setResourceBundle(param0: java.util.ResourceBundle);
                getResourceBundleName(): string;
                addHandler(param0: java.util.logging.Handler);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$SystemLoggerContext{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$RootLogger{
                log(param0: java.util.logging.LogRecord);
                removeHandler(param0: java.util.logging.Handler);
                addHandler(param0: java.util.logging.Handler);
                log(param0: java.util.logging.Level, param1: string, param2: any[]);
                log(param0: java.util.logging.Level, param1: string, param2: java.lang.Throwable);
                log(param0: java.util.logging.Level, param1: java.lang.Throwable, param2: java.util.function.Supplier);
                log(param0: java.util.logging.Level, param1: string);
                log(param0: java.util.logging.Level, param1: string, param2: any);
                log(param0: java.util.logging.Level, param1: java.util.function.Supplier);
                getName(): string;
                getParent(): java.util.logging.Logger;
                setParent(param0: java.util.logging.Logger);
                static getGlobal(): java.util.logging.Logger;
                static getAnonymousLogger(param0: string): java.util.logging.Logger;
                static getAnonymousLogger(): java.util.logging.Logger;
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: java.lang.Throwable, param4: java.util.function.Supplier);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: java.util.function.Supplier);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: any[]);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: java.lang.Throwable);
                logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: any);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: java.lang.Throwable);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: java.util.ResourceBundle, param4: string, param5: java.lang.Throwable);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: any);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: any[]);
                logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: java.util.ResourceBundle, param4: string, param5: any[]);
                entering(param0: string, param1: string, param2: any[]);
                entering(param0: string, param1: string);
                entering(param0: string, param1: string, param2: any);
                exiting(param0: string, param1: string);
                exiting(param0: string, param1: string, param2: any);
                throwing(param0: string, param1: string, param2: java.lang.Throwable);
                severe(param0: java.util.function.Supplier);
                severe(param0: string);
                fine(param0: string);
                fine(param0: java.util.function.Supplier);
                finer(param0: java.util.function.Supplier);
                finer(param0: string);
                finest(param0: string);
                finest(param0: java.util.function.Supplier);
                getHandlers(): any[];
                setUseParentHandlers(param0: boolean);
                getUseParentHandlers(): boolean;
                info(param0: java.util.function.Supplier);
                info(param0: string);
                config(param0: string);
                config(param0: java.util.function.Supplier);
                static getLogger(param0: string, param1: string): java.util.logging.Logger;
                static getLogger(param0: string): java.util.logging.Logger;
                isLoggable(param0: java.util.logging.Level): boolean;
                setLevel(param0: java.util.logging.Level);
                setFilter(param0: java.util.logging.Filter);
                warning(param0: string);
                warning(param0: java.util.function.Supplier);
                getFilter(): java.util.logging.Filter;
                getLevel(): java.util.logging.Level;
                getResourceBundle(): java.util.ResourceBundle;
                setResourceBundle(param0: java.util.ResourceBundle);
                getResourceBundleName(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$LoggerWeakRef{
                get(): any;
                clear();
                isEnqueued(): boolean;
                enqueue(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$LoggerContext$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$LoggerContext{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$LogNode{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$Cleaner{
                run();
                toString(): string;
                isInterrupted(): boolean;
                static currentThread(): java.lang.Thread;
                getName(): string;
                join(param0: number);
                join(param0: number, param1: number);
                join();
                getThreadGroup(): java.lang.ThreadGroup;
                getStackTrace(): any[];
                static holdsLock(param0: any): boolean;
                checkAccess();
                static dumpStack();
                static yield();
                setPriority(param0: number);
                setDaemon(param0: boolean);
                start();
                static sleep(param0: number, param1: number);
                static sleep(param0: number);
                stop();
                stop(param0: java.lang.Throwable);
                interrupt();
                static interrupted(): boolean;
                destroy();
                isAlive(): boolean;
                suspend();
                resume();
                getPriority(): number;
                setName(param0: string);
                static activeCount(): number;
                static enumerate(param0: any[]): number;
                countStackFrames(): number;
                isDaemon(): boolean;
                getContextClassLoader(): java.lang.ClassLoader;
                setContextClassLoader(param0: java.lang.ClassLoader);
                static getAllStackTraces(): java.util.Map;
                getId(): number;
                getState(): java.lang.Thread$State;
                static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$5{
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$3{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$2{
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager$1{
                run(): java.util.logging.LogManager;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LogManager{
                getProperty(param0: string): string;
                checkAccess();
                reset();
                static getLoggingMXBean(): java.util.logging.LoggingMXBean;
                readConfiguration(param0: java.io.InputStream);
                readConfiguration();
                addLogger(param0: java.util.logging.Logger): boolean;
                getLogger(param0: string): java.util.logging.Logger;
                addPropertyChangeListener(param0: java.beans.PropertyChangeListener);
                removePropertyChangeListener(param0: java.beans.PropertyChangeListener);
                static getLogManager(): java.util.logging.LogManager;
                getLoggerNames(): java.util.Enumeration;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Level$KnownLevel{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Level{
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                intValue(): number;
                getName(): string;
                static parse(param0: string): java.util.logging.Level;
                getResourceBundleName(): string;
                getLocalizedName(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Handler{
                flush();
                close();
                getEncoding(): string;
                isLoggable(param0: java.util.logging.LogRecord): boolean;
                setLevel(param0: java.util.logging.Level);
                publish(param0: java.util.logging.LogRecord);
                setFilter(param0: java.util.logging.Filter);
                setFormatter(param0: java.util.logging.Formatter);
                setEncoding(param0: string);
                getFormatter(): java.util.logging.Formatter;
                getFilter(): java.util.logging.Filter;
                setErrorManager(param0: java.util.logging.ErrorManager);
                getErrorManager(): java.util.logging.ErrorManager;
                getLevel(): java.util.logging.Level;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        namespace prefs{
            class AbstractPreferences$1{
                run(): boolean;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class AbstractPreferences$EventDispatchThread{
                run();
                toString(): string;
                isInterrupted(): boolean;
                static currentThread(): java.lang.Thread;
                getName(): string;
                join(param0: number);
                join(param0: number, param1: number);
                join();
                getThreadGroup(): java.lang.ThreadGroup;
                getStackTrace(): any[];
                static holdsLock(param0: any): boolean;
                checkAccess();
                static dumpStack();
                static yield();
                setPriority(param0: number);
                setDaemon(param0: boolean);
                start();
                static sleep(param0: number, param1: number);
                static sleep(param0: number);
                stop();
                stop(param0: java.lang.Throwable);
                interrupt();
                static interrupted(): boolean;
                destroy();
                isAlive(): boolean;
                suspend();
                resume();
                getPriority(): number;
                setName(param0: string);
                static activeCount(): number;
                static enumerate(param0: any[]): number;
                countStackFrames(): number;
                isDaemon(): boolean;
                getContextClassLoader(): java.lang.ClassLoader;
                setContextClassLoader(param0: java.lang.ClassLoader);
                static getAllStackTraces(): java.util.Map;
                getId(): number;
                getState(): java.lang.Thread$State;
                static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class AbstractPreferences$NodeAddedEvent{
                getParent(): java.util.prefs.Preferences;
                getChild(): java.util.prefs.Preferences;
                toString(): string;
                getSource(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class AbstractPreferences$NodeRemovedEvent{
                getParent(): java.util.prefs.Preferences;
                getChild(): java.util.prefs.Preferences;
                toString(): string;
                getSource(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class AbstractPreferences{
                name(): string;
                remove(param0: string);
                parent(): java.util.prefs.Preferences;
                get(param0: string, param1: string): string;
                put(param0: string, param1: string);
                toString(): string;
                getBoolean(param0: string, param1: boolean): boolean;
                putBoolean(param0: string, param1: boolean);
                getInt(param0: string, param1: number): number;
                putInt(param0: string, param1: number);
                getLong(param0: string, param1: number): number;
                putLong(param0: string, param1: number);
                getFloat(param0: string, param1: number): number;
                putFloat(param0: string, param1: number);
                getDouble(param0: string, param1: number): number;
                putDouble(param0: string, param1: number);
                clear();
                keys(): any[];
                flush();
                removeNode();
                sync();
                putByteArray(param0: string, param1: any[]);
                node(param0: string): java.util.prefs.Preferences;
                isUserNode(): boolean;
                getByteArray(param0: string, param1: any[]): any[];
                childrenNames(): any[];
                nodeExists(param0: string): boolean;
                absolutePath(): string;
                addPreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener);
                removePreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener);
                addNodeChangeListener(param0: java.util.prefs.NodeChangeListener);
                removeNodeChangeListener(param0: java.util.prefs.NodeChangeListener);
                exportNode(param0: java.io.OutputStream);
                exportSubtree(param0: java.io.OutputStream);
                static userRoot(): java.util.prefs.Preferences;
                static userNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;
                static systemNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;
                static systemRoot(): java.util.prefs.Preferences;
                static importPreferences(param0: java.io.InputStream);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class BackingStoreException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Base64{
                static main(param0: any[]);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$10{
                run(): number;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$11{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$12{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$2{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$3{
                run();
                cancel(): boolean;
                scheduledExecutionTime(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$4$1{
                run();
                toString(): string;
                isInterrupted(): boolean;
                static currentThread(): java.lang.Thread;
                getName(): string;
                join(param0: number);
                join(param0: number, param1: number);
                join();
                getThreadGroup(): java.lang.ThreadGroup;
                getStackTrace(): any[];
                static holdsLock(param0: any): boolean;
                checkAccess();
                static dumpStack();
                static yield();
                setPriority(param0: number);
                setDaemon(param0: boolean);
                start();
                static sleep(param0: number, param1: number);
                static sleep(param0: number);
                stop();
                stop(param0: java.lang.Throwable);
                interrupt();
                static interrupted(): boolean;
                destroy();
                isAlive(): boolean;
                suspend();
                resume();
                getPriority(): number;
                setName(param0: string);
                static activeCount(): number;
                static enumerate(param0: any[]): number;
                countStackFrames(): number;
                isDaemon(): boolean;
                getContextClassLoader(): java.lang.ClassLoader;
                setContextClassLoader(param0: java.lang.ClassLoader);
                static getAllStackTraces(): java.util.Map;
                getId(): number;
                getState(): java.lang.Thread$State;
                static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$4{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$5{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$6{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$7{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$8{
                run(): any[];
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$9{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$Change{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$NodeCreate{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$Put{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences$Remove{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferences{
                flush();
                removeNode();
                sync();
                isUserNode(): boolean;
                name(): string;
                remove(param0: string);
                parent(): java.util.prefs.Preferences;
                get(param0: string, param1: string): string;
                put(param0: string, param1: string);
                toString(): string;
                getBoolean(param0: string, param1: boolean): boolean;
                putBoolean(param0: string, param1: boolean);
                getInt(param0: string, param1: number): number;
                putInt(param0: string, param1: number);
                getLong(param0: string, param1: number): number;
                putLong(param0: string, param1: number);
                getFloat(param0: string, param1: number): number;
                putFloat(param0: string, param1: number);
                getDouble(param0: string, param1: number): number;
                putDouble(param0: string, param1: number);
                clear();
                keys(): any[];
                putByteArray(param0: string, param1: any[]);
                node(param0: string): java.util.prefs.Preferences;
                getByteArray(param0: string, param1: any[]): any[];
                childrenNames(): any[];
                nodeExists(param0: string): boolean;
                absolutePath(): string;
                addPreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener);
                removePreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener);
                addNodeChangeListener(param0: java.util.prefs.NodeChangeListener);
                removeNodeChangeListener(param0: java.util.prefs.NodeChangeListener);
                exportNode(param0: java.io.OutputStream);
                exportSubtree(param0: java.io.OutputStream);
                static userRoot(): java.util.prefs.Preferences;
                static userNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;
                static systemNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;
                static systemRoot(): java.util.prefs.Preferences;
                static importPreferences(param0: java.io.InputStream);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FileSystemPreferencesFactory{
                userRoot(): java.util.prefs.Preferences;
                systemRoot(): java.util.prefs.Preferences;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InvalidPreferencesFormatException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MacOSXPreferences{
                flush();
                sync();
                name(): string;
                remove(param0: string);
                parent(): java.util.prefs.Preferences;
                get(param0: string, param1: string): string;
                put(param0: string, param1: string);
                toString(): string;
                getBoolean(param0: string, param1: boolean): boolean;
                putBoolean(param0: string, param1: boolean);
                getInt(param0: string, param1: number): number;
                putInt(param0: string, param1: number);
                getLong(param0: string, param1: number): number;
                putLong(param0: string, param1: number);
                getFloat(param0: string, param1: number): number;
                putFloat(param0: string, param1: number);
                getDouble(param0: string, param1: number): number;
                putDouble(param0: string, param1: number);
                clear();
                keys(): any[];
                removeNode();
                putByteArray(param0: string, param1: any[]);
                node(param0: string): java.util.prefs.Preferences;
                isUserNode(): boolean;
                getByteArray(param0: string, param1: any[]): any[];
                childrenNames(): any[];
                nodeExists(param0: string): boolean;
                absolutePath(): string;
                addPreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener);
                removePreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener);
                addNodeChangeListener(param0: java.util.prefs.NodeChangeListener);
                removeNodeChangeListener(param0: java.util.prefs.NodeChangeListener);
                exportNode(param0: java.io.OutputStream);
                exportSubtree(param0: java.io.OutputStream);
                static userRoot(): java.util.prefs.Preferences;
                static userNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;
                static systemNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;
                static systemRoot(): java.util.prefs.Preferences;
                static importPreferences(param0: java.io.InputStream);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MacOSXPreferencesFactory{
                userRoot(): java.util.prefs.Preferences;
                systemRoot(): java.util.prefs.Preferences;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MacOSXPreferencesFile$1{
                run(): java.lang.Void;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MacOSXPreferencesFile$2{
                run();
                cancel(): boolean;
                scheduledExecutionTime(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MacOSXPreferencesFile$3{
                run();
                toString(): string;
                isInterrupted(): boolean;
                static currentThread(): java.lang.Thread;
                getName(): string;
                join(param0: number);
                join(param0: number, param1: number);
                join();
                getThreadGroup(): java.lang.ThreadGroup;
                getStackTrace(): any[];
                static holdsLock(param0: any): boolean;
                checkAccess();
                static dumpStack();
                static yield();
                setPriority(param0: number);
                setDaemon(param0: boolean);
                start();
                static sleep(param0: number, param1: number);
                static sleep(param0: number);
                stop();
                stop(param0: java.lang.Throwable);
                interrupt();
                static interrupted(): boolean;
                destroy();
                isAlive(): boolean;
                suspend();
                resume();
                getPriority(): number;
                setName(param0: string);
                static activeCount(): number;
                static enumerate(param0: any[]): number;
                countStackFrames(): number;
                isDaemon(): boolean;
                getContextClassLoader(): java.lang.ClassLoader;
                setContextClassLoader(param0: java.lang.ClassLoader);
                static getAllStackTraces(): java.util.Map;
                getId(): number;
                getState(): java.lang.Thread$State;
                static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                static getDefaultUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                getUncaughtExceptionHandler(): java.lang.Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(param0: java.lang.Thread$UncaughtExceptionHandler);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MacOSXPreferencesFile$FlushTask{
                run();
                cancel(): boolean;
                scheduledExecutionTime(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MacOSXPreferencesFile$SyncTask{
                run();
                cancel(): boolean;
                scheduledExecutionTime(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MacOSXPreferencesFile{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class NodeChangeEvent{
                getParent(): java.util.prefs.Preferences;
                getChild(): java.util.prefs.Preferences;
                toString(): string;
                getSource(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class NodeChangeListener{
                childAdded(param0: java.util.prefs.NodeChangeEvent);
                childRemoved(param0: java.util.prefs.NodeChangeEvent);
            }
            class PreferenceChangeEvent{
                getKey(): string;
                getNode(): java.util.prefs.Preferences;
                getNewValue(): string;
                toString(): string;
                getSource(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PreferenceChangeListener{
                preferenceChange(param0: java.util.prefs.PreferenceChangeEvent);
            }
            class Preferences$1{
                run(): string;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Preferences$2{
                run(): java.util.prefs.PreferencesFactory;
                run(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Preferences{
                name(): string;
                remove(param0: string);
                parent(): java.util.prefs.Preferences;
                get(param0: string, param1: string): string;
                put(param0: string, param1: string);
                toString(): string;
                getBoolean(param0: string, param1: boolean): boolean;
                putBoolean(param0: string, param1: boolean);
                getInt(param0: string, param1: number): number;
                putInt(param0: string, param1: number);
                getLong(param0: string, param1: number): number;
                putLong(param0: string, param1: number);
                getFloat(param0: string, param1: number): number;
                putFloat(param0: string, param1: number);
                getDouble(param0: string, param1: number): number;
                putDouble(param0: string, param1: number);
                clear();
                keys(): any[];
                flush();
                removeNode();
                sync();
                putByteArray(param0: string, param1: any[]);
                node(param0: string): java.util.prefs.Preferences;
                isUserNode(): boolean;
                static userRoot(): java.util.prefs.Preferences;
                static userNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;
                static systemNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;
                static systemRoot(): java.util.prefs.Preferences;
                getByteArray(param0: string, param1: any[]): any[];
                childrenNames(): any[];
                nodeExists(param0: string): boolean;
                absolutePath(): string;
                addPreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener);
                removePreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener);
                addNodeChangeListener(param0: java.util.prefs.NodeChangeListener);
                removeNodeChangeListener(param0: java.util.prefs.NodeChangeListener);
                exportNode(param0: java.io.OutputStream);
                exportSubtree(param0: java.io.OutputStream);
                static importPreferences(param0: java.io.InputStream);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PreferencesFactory{
                userRoot(): java.util.prefs.Preferences;
                systemRoot(): java.util.prefs.Preferences;
            }
            class XmlSupport$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class XmlSupport$EH{
                error(param0: org.xml.sax.SAXParseException);
                warning(param0: org.xml.sax.SAXParseException);
                fatalError(param0: org.xml.sax.SAXParseException);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class XmlSupport$Resolver{
                resolveEntity(param0: string, param1: string): org.xml.sax.InputSource;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class XmlSupport{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        namespace regex{
            class ASCII{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MatchResult{
                group(): string;
                group(param0: number): string;
                start(param0: number): number;
                start(): number;
                end(param0: number): number;
                end(): number;
                groupCount(): number;
            }
            class Matcher{
                group(param0: string): string;
                group(): string;
                group(param0: number): string;
                toString(): string;
                matches(): boolean;
                replaceFirst(param0: string): string;
                replaceAll(param0: string): string;
                static quoteReplacement(param0: string): string;
                find(): boolean;
                find(param0: number): boolean;
                start(param0: string): number;
                start(param0: number): number;
                start(): number;
                reset(param0: java.lang.CharSequence): java.util.regex.Matcher;
                reset(): java.util.regex.Matcher;
                appendReplacement(param0: java.lang.StringBuffer, param1: string): java.util.regex.Matcher;
                appendTail(param0: java.lang.StringBuffer): java.lang.StringBuffer;
                end(param0: string): number;
                end(): number;
                end(param0: number): number;
                region(param0: number, param1: number): java.util.regex.Matcher;
                pattern(): java.util.regex.Pattern;
                hitEnd(): boolean;
                requireEnd(): boolean;
                toMatchResult(): java.util.regex.MatchResult;
                usePattern(param0: java.util.regex.Pattern): java.util.regex.Matcher;
                groupCount(): number;
                lookingAt(): boolean;
                regionStart(): number;
                regionEnd(): number;
                hasTransparentBounds(): boolean;
                useTransparentBounds(param0: boolean): java.util.regex.Matcher;
                hasAnchoringBounds(): boolean;
                useAnchoringBounds(param0: boolean): java.util.regex.Matcher;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$1MatcherIterator{
                hasNext(): boolean;
                next(): string;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                remove();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class Pattern$2{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$3{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$4{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$5{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$6{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$7{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$All{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$BackRef{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Begin{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Behind{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$BehindS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$BitClass{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Block{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$BmpCharProperty{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$BnM{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$BnMS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Bound{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Branch{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$BranchConn{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CIBackRef{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Caret{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Category{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharProperty$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharProperty{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$10{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$11{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$12{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$13{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$14{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$15{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$16{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$17{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$18{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$19{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$2{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$20{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$21{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$22{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$23{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$3{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$4{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$5{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$6{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$7{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$8{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$9{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$CharPropertyFactory{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames$CloneableProperty{
                clone(): java.util.regex.Pattern$CharPropertyNames$CloneableProperty;
                clone(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$CharPropertyNames{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Conditional{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Ctype{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Curly{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Dollar{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Dot{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$End{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$First{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$GroupCurly{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$GroupHead{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$GroupRef{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$GroupTail{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$HorizWS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$LastMatch{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$LastNode{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$LazyLoop{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$LineEnding{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Loop{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Neg{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Node{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$NotBehind{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$NotBehindS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Pos{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Prolog{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Ques{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Script{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Single{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SingleI{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SingleS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SingleU{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Slice{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SliceI{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SliceIS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SliceNode{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SliceS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SliceU{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$SliceUS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Start{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$StartS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$TreeInfo{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$UnixCaret{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$UnixDollar{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$UnixDot{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$Utype{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern$VertWS{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Pattern{
                toString(): string;
                flags(): number;
                static matches(param0: string, param1: java.lang.CharSequence): boolean;
                split(param0: java.lang.CharSequence, param1: number): any[];
                split(param0: java.lang.CharSequence): any[];
                static compile(param0: string): java.util.regex.Pattern;
                static compile(param0: string, param1: number): java.util.regex.Pattern;
                matcher(param0: java.lang.CharSequence): java.util.regex.Matcher;
                static quote(param0: string): string;
                pattern(): string;
                asPredicate(): java.util.function.Predicate;
                splitAsStream(param0: java.lang.CharSequence): java.util.stream.Stream;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PatternSyntaxException{
                getMessage(): string;
                getIndex(): number;
                getDescription(): string;
                getPattern(): string;
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$1{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$10{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$11{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$12{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$13{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$14{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$15{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$16{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$17{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$18{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$19{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$2{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$3{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$4{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$5{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$6{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$7{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$8{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp$9{
                is(param0: number): boolean;
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class UnicodeProp{
                static forName(param0: string): java.util.regex.UnicodeProp;
                static values(): any[];
                static valueOf(param0: string): java.util.regex.UnicodeProp;
                is(param0: number): boolean;
                static forPOSIXName(param0: string): java.util.regex.UnicodeProp;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        namespace spi{
            class CalendarNameProvider{
                getDisplayName(param0: string, param1: number, param2: number, param3: number, param4: java.util.Locale): string;
                getDisplayNames(param0: string, param1: number, param2: number, param3: java.util.Locale): java.util.Map;
                getAvailableLocales(): any[];
                isSupportedLocale(param0: java.util.Locale): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TimeZoneNameProvider{
                getDisplayName(param0: string, param1: boolean, param2: number, param3: java.util.Locale): string;
                getGenericDisplayName(param0: string, param1: number, param2: java.util.Locale): string;
                getAvailableLocales(): any[];
                isSupportedLocale(param0: java.util.Locale): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ResourceBundleControlProvider{
                getControl(param0: string): java.util.ResourceBundle$Control;
            }
            class LocaleServiceProvider{
                getAvailableLocales(): any[];
                isSupportedLocale(param0: java.util.Locale): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LocaleNameProvider{
                getDisplayLanguage(param0: string, param1: java.util.Locale): string;
                getDisplayScript(param0: string, param1: java.util.Locale): string;
                getDisplayCountry(param0: string, param1: java.util.Locale): string;
                getDisplayVariant(param0: string, param1: java.util.Locale): string;
                getAvailableLocales(): any[];
                isSupportedLocale(param0: java.util.Locale): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CurrencyNameProvider{
                getDisplayName(param0: string, param1: java.util.Locale): string;
                getSymbol(param0: string, param1: java.util.Locale): string;
                getAvailableLocales(): any[];
                isSupportedLocale(param0: java.util.Locale): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CalendarDataProvider{
                getFirstDayOfWeek(param0: java.util.Locale): number;
                getMinimalDaysInFirstWeek(param0: java.util.Locale): number;
                getAvailableLocales(): any[];
                isSupportedLocale(param0: java.util.Locale): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        namespace stream{
            class AbstractPipeline{
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                iterator(): java.util.Iterator;
                unordered(): java.util.stream.BaseStream;
            }
            class AbstractShortCircuitTask{
                compute();
                getLocalResult(): any;
                getRawResult(): any;
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class AbstractSpinedBuffer{
                count(): number;
                clear();
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class AbstractTask{
                compute();
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class BaseStream{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                unordered(): java.util.stream.BaseStream;
                isParallel(): boolean;
            }
            class Collector$Characteristics{
                static values(): any[];
                static valueOf(param0: string): java.util.stream.Collector$Characteristics;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Collector{
                combiner(): java.util.function.BinaryOperator;
                static of(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BinaryOperator, param3: java.util.function.Function, param4: any[]): java.util.stream.Collector;
                static of(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BinaryOperator, param3: any[]): java.util.stream.Collector;
                supplier(): java.util.function.Supplier;
                accumulator(): java.util.function.BiConsumer;
                finisher(): java.util.function.Function;
                characteristics(): java.util.Set;
            }
            class Collectors$1OptionalBox{
                accept(param0: any);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Collectors$CollectorImpl{
                combiner(): java.util.function.BinaryOperator;
                supplier(): java.util.function.Supplier;
                accumulator(): java.util.function.BiConsumer;
                finisher(): java.util.function.Function;
                characteristics(): java.util.Set;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Collectors$Partition$1{
                size(): number;
                iterator(): java.util.Iterator;
                equals(param0: any): boolean;
                hashCode(): number;
                removeAll(param0: java.util.Collection): boolean;
                add(param0: any): boolean;
                remove(param0: any): boolean;
                toString(): string;
                clear();
                isEmpty(): boolean;
                contains(param0: any): boolean;
                toArray(param0: any[]): any[];
                toArray(): any[];
                addAll(param0: java.util.Collection): boolean;
                containsAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                stream(): java.util.stream.Stream;
                removeIf(param0: java.util.function.Predicate): boolean;
                parallelStream(): java.util.stream.Stream;
                forEach(param0: java.util.function.Consumer);
                spliterator(): java.util.Spliterator;
            }
            class Collectors$Partition{
                entrySet(): java.util.Set;
                remove(param0: any): any;
                get(param0: any): any;
                put(param0: any, param1: any): any;
                equals(param0: any): boolean;
                toString(): string;
                values(): java.util.Collection;
                hashCode(): number;
                clear();
                isEmpty(): boolean;
                size(): number;
                putAll(param0: java.util.Map);
                keySet(): java.util.Set;
                containsValue(param0: any): boolean;
                containsKey(param0: any): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                remove(param0: any, param1: any): boolean;
                replace(param0: any, param1: any): any;
                replace(param0: any, param1: any, param2: any): boolean;
                replaceAll(param0: java.util.function.BiFunction);
                putIfAbsent(param0: any, param1: any): any;
                forEach(param0: java.util.function.BiConsumer);
                getOrDefault(param0: any, param1: any): any;
                computeIfAbsent(param0: any, param1: java.util.function.Function): any;
                computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
                compute(param0: any, param1: java.util.function.BiFunction): any;
                merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            }
            class Collectors{
                static toMap(param0: java.util.function.Function, param1: java.util.function.Function, param2: java.util.function.BinaryOperator, param3: java.util.function.Supplier): java.util.stream.Collector;
                static toMap(param0: java.util.function.Function, param1: java.util.function.Function): java.util.stream.Collector;
                static toMap(param0: java.util.function.Function, param1: java.util.function.Function, param2: java.util.function.BinaryOperator): java.util.stream.Collector;
                static maxBy(param0: java.util.Comparator): java.util.stream.Collector;
                static minBy(param0: java.util.Comparator): java.util.stream.Collector;
                static toList(): java.util.stream.Collector;
                static toCollection(param0: java.util.function.Supplier): java.util.stream.Collector;
                static toSet(): java.util.stream.Collector;
                static joining(param0: java.lang.CharSequence, param1: java.lang.CharSequence, param2: java.lang.CharSequence): java.util.stream.Collector;
                static joining(param0: java.lang.CharSequence): java.util.stream.Collector;
                static joining(): java.util.stream.Collector;
                static mapping(param0: java.util.function.Function, param1: java.util.stream.Collector): java.util.stream.Collector;
                static collectingAndThen(param0: java.util.stream.Collector, param1: java.util.function.Function): java.util.stream.Collector;
                static counting(): java.util.stream.Collector;
                static summingInt(param0: java.util.function.ToIntFunction): java.util.stream.Collector;
                static summingLong(param0: java.util.function.ToLongFunction): java.util.stream.Collector;
                static summingDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.Collector;
                static averagingInt(param0: java.util.function.ToIntFunction): java.util.stream.Collector;
                static averagingLong(param0: java.util.function.ToLongFunction): java.util.stream.Collector;
                static averagingDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.Collector;
                static reducing(param0: java.util.function.BinaryOperator): java.util.stream.Collector;
                static reducing(param0: any, param1: java.util.function.BinaryOperator): java.util.stream.Collector;
                static reducing(param0: any, param1: java.util.function.Function, param2: java.util.function.BinaryOperator): java.util.stream.Collector;
                static groupingBy(param0: java.util.function.Function): java.util.stream.Collector;
                static groupingBy(param0: java.util.function.Function, param1: java.util.stream.Collector): java.util.stream.Collector;
                static groupingBy(param0: java.util.function.Function, param1: java.util.function.Supplier, param2: java.util.stream.Collector): java.util.stream.Collector;
                static groupingByConcurrent(param0: java.util.function.Function, param1: java.util.function.Supplier, param2: java.util.stream.Collector): java.util.stream.Collector;
                static groupingByConcurrent(param0: java.util.function.Function, param1: java.util.stream.Collector): java.util.stream.Collector;
                static groupingByConcurrent(param0: java.util.function.Function): java.util.stream.Collector;
                static partitioningBy(param0: java.util.function.Predicate, param1: java.util.stream.Collector): java.util.stream.Collector;
                static partitioningBy(param0: java.util.function.Predicate): java.util.stream.Collector;
                static toConcurrentMap(param0: java.util.function.Function, param1: java.util.function.Function): java.util.stream.Collector;
                static toConcurrentMap(param0: java.util.function.Function, param1: java.util.function.Function, param2: java.util.function.BinaryOperator, param3: java.util.function.Supplier): java.util.stream.Collector;
                static toConcurrentMap(param0: java.util.function.Function, param1: java.util.function.Function, param2: java.util.function.BinaryOperator): java.util.stream.Collector;
                static summarizingInt(param0: java.util.function.ToIntFunction): java.util.stream.Collector;
                static summarizingLong(param0: java.util.function.ToLongFunction): java.util.stream.Collector;
                static summarizingDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.Collector;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DistinctOps$1$1{
                accept(param0: any);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class DistinctOps$1$2{
                accept(param0: any);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class DistinctOps$1{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DistinctOps{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$1$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoublePipeline$1{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$2$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoublePipeline$2{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$3$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoublePipeline$3{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$4$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoublePipeline$4{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$5$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoublePipeline$5{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$6{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$7$1{
                accept(param0: number);
                begin(param0: number);
                cancellationRequested(): boolean;
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoublePipeline$7{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$8$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoublePipeline$8{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$Head{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.DoubleConsumer);
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$StatefulOp{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline$StatelessOp{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoublePipeline{
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator$OfDouble;
                spliterator(): java.util.Spliterator;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                parallel(): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                sequential(): java.util.stream.DoubleStream;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.BaseStream;
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DoubleStream$1{
                hasNext(): boolean;
                nextDouble(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                next(): any;
                next(): number;
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.Consumer);
                remove();
            }
            class DoubleStream$Builder{
                add(param0: number): java.util.stream.DoubleStream$Builder;
                accept(param0: number);
                build(): java.util.stream.DoubleStream;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class DoubleStream{
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                static concat(param0: java.util.stream.DoubleStream, param1: java.util.stream.DoubleStream): java.util.stream.DoubleStream;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                static of(param0: number): java.util.stream.DoubleStream;
                static of(param0: any[]): java.util.stream.DoubleStream;
                sum(): number;
                static empty(): java.util.stream.DoubleStream;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                parallel(): java.util.stream.BaseStream;
                parallel(): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                static builder(): java.util.stream.DoubleStream$Builder;
                static iterate(param0: number, param1: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                static generate(param0: java.util.function.DoubleSupplier): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.BaseStream;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                unordered(): java.util.stream.BaseStream;
                isParallel(): boolean;
            }
            class FindOps$FindOp{
                inputShape(): java.util.stream.StreamShape;
                getOpFlags(): number;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FindOps$FindSink$OfDouble{
                get(): any;
                get(): java.util.OptionalDouble;
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class FindOps$FindSink$OfInt{
                get(): any;
                get(): java.util.OptionalInt;
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class FindOps$FindSink$OfLong{
                get(): any;
                get(): java.util.OptionalLong;
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class FindOps$FindSink$OfRef{
                get(): java.util.Optional;
                get(): any;
                accept(param0: any);
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class FindOps$FindSink{
                accept(param0: any);
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                get(): any;
            }
            class FindOps$FindTask{
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                compute();
                getLocalResult(): any;
                getRawResult(): any;
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class FindOps{
                static makeInt(param0: boolean): java.util.stream.TerminalOp;
                static makeLong(param0: boolean): java.util.stream.TerminalOp;
                static makeRef(param0: boolean): java.util.stream.TerminalOp;
                static makeDouble(param0: boolean): java.util.stream.TerminalOp;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForEachOps$ForEachOp$OfDouble{
                get(): any;
                accept(param0: number);
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                get(): java.lang.Void;
                getOpFlags(): number;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class ForEachOps$ForEachOp$OfInt{
                get(): any;
                accept(param0: number);
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                get(): java.lang.Void;
                getOpFlags(): number;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class ForEachOps$ForEachOp$OfLong{
                get(): any;
                accept(param0: number);
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                get(): java.lang.Void;
                getOpFlags(): number;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class ForEachOps$ForEachOp$OfRef{
                get(): any;
                accept(param0: any);
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                get(): java.lang.Void;
                getOpFlags(): number;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                inputShape(): java.util.stream.StreamShape;
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ForEachOps$ForEachOp{
                get(): any;
                get(): java.lang.Void;
                getOpFlags(): number;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): java.lang.Void;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                inputShape(): java.util.stream.StreamShape;
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ForEachOps$ForEachOrderedTask{
                compute();
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForEachOps$ForEachTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ForEachOps{
                static makeInt(param0: java.util.function.IntConsumer, param1: boolean): java.util.stream.TerminalOp;
                static makeLong(param0: java.util.function.LongConsumer, param1: boolean): java.util.stream.TerminalOp;
                static makeRef(param0: java.util.function.Consumer, param1: boolean): java.util.stream.TerminalOp;
                static makeDouble(param0: java.util.function.DoubleConsumer, param1: boolean): java.util.stream.TerminalOp;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$1$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$1{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$10$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$10{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$2$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$2{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$3$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$3{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$4$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$4{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$5$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$5{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$6$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$6{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$7$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$7{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$8{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$9$1{
                accept(param0: number);
                begin(param0: number);
                cancellationRequested(): boolean;
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntPipeline$9{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$Head{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.IntConsumer);
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$StatefulOp{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline$StatelessOp{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntPipeline{
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator$OfInt;
                spliterator(): java.util.Spliterator;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                parallel(): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                sequential(): java.util.stream.IntStream;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class IntStream$1{
                hasNext(): boolean;
                nextInt(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                next(): any;
                next(): number;
                forEachRemaining(param0: java.util.function.IntConsumer);
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.Consumer);
                remove();
            }
            class IntStream$Builder{
                add(param0: number): java.util.stream.IntStream$Builder;
                accept(param0: number);
                build(): java.util.stream.IntStream;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class IntStream{
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                static concat(param0: java.util.stream.IntStream, param1: java.util.stream.IntStream): java.util.stream.IntStream;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                static of(param0: number): java.util.stream.IntStream;
                static of(param0: any[]): java.util.stream.IntStream;
                sum(): number;
                static empty(): java.util.stream.IntStream;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                static range(param0: number, param1: number): java.util.stream.IntStream;
                parallel(): java.util.stream.BaseStream;
                parallel(): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                static builder(): java.util.stream.IntStream$Builder;
                static iterate(param0: number, param1: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                static generate(param0: java.util.function.IntSupplier): java.util.stream.IntStream;
                sequential(): java.util.stream.BaseStream;
                sequential(): java.util.stream.IntStream;
                forEachOrdered(param0: java.util.function.IntConsumer);
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                static rangeClosed(param0: number, param1: number): java.util.stream.IntStream;
                close();
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                unordered(): java.util.stream.BaseStream;
                isParallel(): boolean;
            }
            class LongPipeline$1$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongPipeline$1{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$2$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongPipeline$2{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$3$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongPipeline$3{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$4$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongPipeline$4{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$5$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongPipeline$5{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$6$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongPipeline$6{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$7{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$8$1{
                accept(param0: number);
                begin(param0: number);
                cancellationRequested(): boolean;
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongPipeline$8{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$9$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongPipeline$9{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$Head{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.LongConsumer);
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$StatefulOp{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline$StatelessOp{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongPipeline{
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator$OfLong;
                spliterator(): java.util.Spliterator;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                parallel(): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                sequential(): java.util.stream.LongStream;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class LongStream$1{
                hasNext(): boolean;
                nextLong(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                next(): number;
                next(): any;
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.Consumer);
                forEachRemaining(param0: java.util.function.LongConsumer);
                remove();
            }
            class LongStream$Builder{
                add(param0: number): java.util.stream.LongStream$Builder;
                accept(param0: number);
                build(): java.util.stream.LongStream;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class LongStream{
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                static concat(param0: java.util.stream.LongStream, param1: java.util.stream.LongStream): java.util.stream.LongStream;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                static of(param0: number): java.util.stream.LongStream;
                static of(param0: any[]): java.util.stream.LongStream;
                sum(): number;
                static empty(): java.util.stream.LongStream;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                static range(param0: number, param1: number): java.util.stream.LongStream;
                parallel(): java.util.stream.BaseStream;
                parallel(): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                static builder(): java.util.stream.LongStream$Builder;
                static iterate(param0: number, param1: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                static generate(param0: java.util.function.LongSupplier): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                sequential(): java.util.stream.BaseStream;
                forEachOrdered(param0: java.util.function.LongConsumer);
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                static rangeClosed(param0: number, param1: number): java.util.stream.LongStream;
                close();
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                unordered(): java.util.stream.BaseStream;
                isParallel(): boolean;
            }
            class MatchOps$1MatchSink{
                accept(param0: any);
                cancellationRequested(): boolean;
                getAndClearState(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class MatchOps$2MatchSink{
                accept(param0: number);
                cancellationRequested(): boolean;
                getAndClearState(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class MatchOps$3MatchSink{
                accept(param0: number);
                cancellationRequested(): boolean;
                getAndClearState(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class MatchOps$4MatchSink{
                accept(param0: number);
                cancellationRequested(): boolean;
                getAndClearState(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class MatchOps$BooleanTerminalSink{
                cancellationRequested(): boolean;
                getAndClearState(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                begin(param0: number);
                end();
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class MatchOps$MatchKind{
                static values(): any[];
                static valueOf(param0: string): java.util.stream.MatchOps$MatchKind;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MatchOps$MatchOp{
                inputShape(): java.util.stream.StreamShape;
                getOpFlags(): number;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): boolean;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MatchOps$MatchTask{
                compute();
                getLocalResult(): any;
                getRawResult(): any;
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class MatchOps{
                static makeInt(param0: java.util.function.IntPredicate, param1: java.util.stream.MatchOps$MatchKind): java.util.stream.TerminalOp;
                static makeLong(param0: java.util.function.LongPredicate, param1: java.util.stream.MatchOps$MatchKind): java.util.stream.TerminalOp;
                static makeRef(param0: java.util.function.Predicate, param1: java.util.stream.MatchOps$MatchKind): java.util.stream.TerminalOp;
                static makeDouble(param0: java.util.function.DoublePredicate, param1: java.util.stream.MatchOps$MatchKind): java.util.stream.TerminalOp;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Node$Builder$OfDouble{
                build(): java.util.stream.Node$OfDouble;
                build(): java.util.stream.Node;
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class Node$Builder$OfInt{
                build(): java.util.stream.Node$OfInt;
                build(): java.util.stream.Node;
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class Node$Builder$OfLong{
                build(): java.util.stream.Node$OfLong;
                build(): java.util.stream.Node;
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class Node$Builder{
                build(): java.util.stream.Node;
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Node$OfDouble{
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfDouble;
                getShape(): java.util.stream.StreamShape;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                asPrimitiveArray(): any;
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                count(): number;
                getChildCount(): number;
            }
            class Node$OfInt{
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfInt;
                getShape(): java.util.stream.StreamShape;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                asPrimitiveArray(): any;
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                count(): number;
                getChildCount(): number;
            }
            class Node$OfLong{
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfLong;
                getShape(): java.util.stream.StreamShape;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                asPrimitiveArray(): any;
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                count(): number;
                getChildCount(): number;
            }
            class Node$OfPrimitive{
                newArray(param0: number): any;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                asArray(param0: java.util.function.IntFunction): any[];
                asPrimitiveArray(): any;
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                count(): number;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                getShape(): java.util.stream.StreamShape;
                getChildCount(): number;
            }
            class Node{
                count(): number;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                asArray(param0: java.util.function.IntFunction): any[];
                getShape(): java.util.stream.StreamShape;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
            }
            class Nodes$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$AbstractConcNode{
                count(): number;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                asArray(param0: java.util.function.IntFunction): any[];
                getShape(): java.util.stream.StreamShape;
            }
            class Nodes$ArrayNode{
                count(): number;
                toString(): string;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                getShape(): java.util.stream.StreamShape;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
            }
            class Nodes$CollectionNode{
                count(): number;
                toString(): string;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                getShape(): java.util.stream.StreamShape;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
            }
            class Nodes$CollectorTask$OfDouble{
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                compute();
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$CollectorTask$OfInt{
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                compute();
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$CollectorTask$OfLong{
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                compute();
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$CollectorTask$OfRef{
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                compute();
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$CollectorTask{
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                compute();
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$ConcNode$OfDouble{
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfDouble;
                toString(): string;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                count(): number;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                asArray(param0: java.util.function.IntFunction): any[];
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfDouble;
                getShape(): java.util.stream.StreamShape;
            }
            class Nodes$ConcNode$OfInt{
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfInt;
                toString(): string;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                count(): number;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                asArray(param0: java.util.function.IntFunction): any[];
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfInt;
                getShape(): java.util.stream.StreamShape;
            }
            class Nodes$ConcNode$OfLong{
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfLong;
                toString(): string;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                count(): number;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                asArray(param0: java.util.function.IntFunction): any[];
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfLong;
                getShape(): java.util.stream.StreamShape;
            }
            class Nodes$ConcNode$OfPrimitive{
                toString(): string;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                count(): number;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                getShape(): java.util.stream.StreamShape;
                newArray(param0: number): any;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                asArray(param0: java.util.function.IntFunction): any[];
            }
            class Nodes$ConcNode{
                toString(): string;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                asArray(param0: java.util.function.IntFunction): any[];
                count(): number;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getShape(): java.util.stream.StreamShape;
            }
            class Nodes$DoubleArrayNode{
                count(): number;
                toString(): string;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfDouble;
                forEach(param0: any);
                forEach(param0: java.util.function.DoubleConsumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any[];
                asPrimitiveArray(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfDouble;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
            }
            class Nodes$DoubleFixedNodeBuilder{
                toString(): string;
                accept(param0: number);
                build(): java.util.stream.Node;
                build(): java.util.stream.Node$OfDouble;
                begin(param0: number);
                end();
                count(): number;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfDouble;
                forEach(param0: any);
                forEach(param0: java.util.function.DoubleConsumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any[];
                asPrimitiveArray(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfDouble;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class Nodes$DoubleSpinedNodeBuilder{
                spliterator(): java.util.Spliterator$OfDouble;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                accept(param0: number);
                forEach(param0: any);
                forEach(param0: java.util.function.DoubleConsumer);
                copyInto(param0: any, param1: number);
                copyInto(param0: any[], param1: number);
                build(): java.util.stream.Node$OfDouble;
                build(): java.util.stream.Node;
                begin(param0: number);
                end();
                asPrimitiveArray(): any;
                asPrimitiveArray(): any[];
                get(param0: number): number;
                toString(): string;
                newArray(param0: number): any[];
                newArray(param0: number): any;
                iterator(): java.util.PrimitiveIterator$OfDouble;
                iterator(): java.util.Iterator;
                forEach(param0: java.util.function.Consumer);
                clear();
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfDouble;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
            }
            class Nodes$EmptyNode$OfDouble{
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfDouble;
                asPrimitiveArray(): any;
                asPrimitiveArray(): any[];
                count(): number;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getChildCount(): number;
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfDouble;
                getShape(): java.util.stream.StreamShape;
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
            }
            class Nodes$EmptyNode$OfInt{
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfInt;
                asPrimitiveArray(): any;
                asPrimitiveArray(): any[];
                count(): number;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getChildCount(): number;
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfInt;
                getShape(): java.util.stream.StreamShape;
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
            }
            class Nodes$EmptyNode$OfLong{
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfLong;
                asPrimitiveArray(): any;
                asPrimitiveArray(): any[];
                count(): number;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getChildCount(): number;
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfLong;
                getShape(): java.util.stream.StreamShape;
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
            }
            class Nodes$EmptyNode$OfRef{
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                count(): number;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                getShape(): java.util.stream.StreamShape;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
            }
            class Nodes$EmptyNode{
                count(): number;
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                getShape(): java.util.stream.StreamShape;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
            }
            class Nodes$FixedNodeBuilder{
                toString(): string;
                accept(param0: any);
                build(): java.util.stream.Node;
                begin(param0: number);
                end();
                count(): number;
                spliterator(): java.util.Spliterator;
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                getShape(): java.util.stream.StreamShape;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Nodes$IntArrayNode{
                count(): number;
                toString(): string;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfInt;
                forEach(param0: any);
                forEach(param0: java.util.function.IntConsumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any[];
                asPrimitiveArray(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfInt;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
            }
            class Nodes$IntFixedNodeBuilder{
                toString(): string;
                accept(param0: number);
                build(): java.util.stream.Node;
                build(): java.util.stream.Node$OfInt;
                begin(param0: number);
                end();
                count(): number;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfInt;
                forEach(param0: any);
                forEach(param0: java.util.function.IntConsumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any[];
                asPrimitiveArray(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfInt;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class Nodes$IntSpinedNodeBuilder{
                spliterator(): java.util.Spliterator$OfInt;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                accept(param0: number);
                forEach(param0: any);
                forEach(param0: java.util.function.IntConsumer);
                copyInto(param0: any, param1: number);
                copyInto(param0: any[], param1: number);
                build(): java.util.stream.Node$OfInt;
                build(): java.util.stream.Node;
                begin(param0: number);
                end();
                asPrimitiveArray(): any;
                asPrimitiveArray(): any[];
                get(param0: number): number;
                toString(): string;
                newArray(param0: number): any[];
                newArray(param0: number): any;
                iterator(): java.util.PrimitiveIterator$OfInt;
                iterator(): java.util.Iterator;
                forEach(param0: java.util.function.Consumer);
                clear();
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfInt;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
            }
            class Nodes$InternalNodeSpliterator$OfDouble{
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfDouble;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class Nodes$InternalNodeSpliterator$OfInt{
                forEachRemaining(param0: java.util.function.IntConsumer);
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfInt;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class Nodes$InternalNodeSpliterator$OfLong{
                forEachRemaining(param0: java.util.function.LongConsumer);
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfLong;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class Nodes$InternalNodeSpliterator$OfPrimitive{
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class Nodes$InternalNodeSpliterator$OfRef{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class Nodes$InternalNodeSpliterator{
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class Nodes$LongArrayNode{
                count(): number;
                toString(): string;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfLong;
                forEach(param0: any);
                forEach(param0: java.util.function.LongConsumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any[];
                asPrimitiveArray(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfLong;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
            }
            class Nodes$LongFixedNodeBuilder{
                toString(): string;
                accept(param0: number);
                build(): java.util.stream.Node;
                build(): java.util.stream.Node$OfLong;
                begin(param0: number);
                end();
                count(): number;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                spliterator(): java.util.Spliterator$OfLong;
                forEach(param0: any);
                forEach(param0: java.util.function.LongConsumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any[];
                asPrimitiveArray(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                newArray(param0: number): any;
                newArray(param0: number): any[];
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfLong;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class Nodes$LongSpinedNodeBuilder{
                spliterator(): java.util.Spliterator$OfLong;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfPrimitive;
                accept(param0: number);
                forEach(param0: any);
                forEach(param0: java.util.function.LongConsumer);
                copyInto(param0: any, param1: number);
                copyInto(param0: any[], param1: number);
                build(): java.util.stream.Node$OfLong;
                build(): java.util.stream.Node;
                begin(param0: number);
                end();
                asPrimitiveArray(): any;
                asPrimitiveArray(): any[];
                get(param0: number): number;
                toString(): string;
                newArray(param0: number): any[];
                newArray(param0: number): any;
                iterator(): java.util.PrimitiveIterator$OfLong;
                iterator(): java.util.Iterator;
                forEach(param0: java.util.function.Consumer);
                clear();
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
                copyInto(param0: any[], param1: number);
                copyInto(param0: any[], param1: number);
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfPrimitive;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node$OfLong;
                getShape(): java.util.stream.StreamShape;
                asArray(param0: java.util.function.IntFunction): any[];
                getChild(param0: number): java.util.stream.Node;
                getChild(param0: number): java.util.stream.Node$OfPrimitive;
                getChildCount(): number;
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
            }
            class Nodes$SizedCollectorTask$OfDouble{
                accept(param0: number);
                compute();
                begin(param0: number);
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class Nodes$SizedCollectorTask$OfInt{
                accept(param0: number);
                compute();
                begin(param0: number);
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class Nodes$SizedCollectorTask$OfLong{
                accept(param0: number);
                compute();
                begin(param0: number);
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class Nodes$SizedCollectorTask$OfRef{
                accept(param0: any);
                compute();
                begin(param0: number);
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Nodes$SizedCollectorTask{
                compute();
                begin(param0: number);
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Nodes$SpinedNodeBuilder{
                spliterator(): java.util.Spliterator;
                accept(param0: any);
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                build(): java.util.stream.Node;
                begin(param0: number);
                end();
                get(param0: number): any;
                toString(): string;
                clear();
                iterator(): java.util.Iterator;
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                truncate(param0: number, param1: number, param2: java.util.function.IntFunction): java.util.stream.Node;
                getShape(): java.util.stream.StreamShape;
                getChildCount(): number;
                getChild(param0: number): java.util.stream.Node;
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
            }
            class Nodes$ToArrayTask$OfDouble{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$ToArrayTask$OfInt{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$ToArrayTask$OfLong{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$ToArrayTask$OfPrimitive{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$ToArrayTask$OfRef{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes$ToArrayTask{
                compute();
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                getRawResult(): any;
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Nodes{
                static collect(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator, param2: boolean, param3: java.util.function.IntFunction): java.util.stream.Node;
                static flatten(param0: java.util.stream.Node, param1: java.util.function.IntFunction): java.util.stream.Node;
                static collectDouble(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator, param2: boolean): java.util.stream.Node$OfDouble;
                static flattenDouble(param0: java.util.stream.Node$OfDouble): java.util.stream.Node$OfDouble;
                static collectInt(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator, param2: boolean): java.util.stream.Node$OfInt;
                static flattenInt(param0: java.util.stream.Node$OfInt): java.util.stream.Node$OfInt;
                static collectLong(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator, param2: boolean): java.util.stream.Node$OfLong;
                static flattenLong(param0: java.util.stream.Node$OfLong): java.util.stream.Node$OfLong;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class PipelineHelper{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReduceOps$1{
                makeSink(): java.util.stream.ReduceOps$1ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$10{
                makeSink(): java.util.stream.ReduceOps$10ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$10ReducingSink{
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$10ReducingSink);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                begin(param0: number);
                get(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class ReduceOps$11{
                makeSink(): java.util.stream.ReduceOps$11ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$11ReducingSink{
                get(): any;
                get(): number;
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                combine(param0: java.util.stream.ReduceOps$11ReducingSink);
                begin(param0: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class ReduceOps$12{
                makeSink(): java.util.stream.ReduceOps$12ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$12ReducingSink{
                get(): any;
                get(): java.util.OptionalDouble;
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                combine(param0: java.util.stream.ReduceOps$12ReducingSink);
                begin(param0: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class ReduceOps$13{
                makeSink(): java.util.stream.ReduceOps$13ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$13ReducingSink{
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$13ReducingSink);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                begin(param0: number);
                get(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class ReduceOps$1ReducingSink{
                accept(param0: any);
                combine(param0: java.util.stream.ReduceOps$1ReducingSink);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                begin(param0: number);
                get(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReduceOps$2{
                makeSink(): java.util.stream.ReduceOps$2ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$2ReducingSink{
                get(): any;
                get(): java.util.Optional;
                accept(param0: any);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                combine(param0: java.util.stream.ReduceOps$2ReducingSink);
                begin(param0: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReduceOps$3{
                getOpFlags(): number;
                makeSink(): java.util.stream.ReduceOps$3ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReduceOps$3ReducingSink{
                accept(param0: any);
                combine(param0: java.util.stream.ReduceOps$3ReducingSink);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                begin(param0: number);
                get(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReduceOps$4{
                makeSink(): java.util.stream.ReduceOps$4ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$4ReducingSink{
                accept(param0: any);
                combine(param0: java.util.stream.ReduceOps$4ReducingSink);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                begin(param0: number);
                get(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReduceOps$5{
                makeSink(): java.util.stream.ReduceOps$5ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$5ReducingSink{
                get(): any;
                get(): number;
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                combine(param0: java.util.stream.ReduceOps$5ReducingSink);
                begin(param0: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class ReduceOps$6{
                makeSink(): java.util.stream.ReduceOps$6ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$6ReducingSink{
                get(): any;
                get(): java.util.OptionalInt;
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                combine(param0: java.util.stream.ReduceOps$6ReducingSink);
                begin(param0: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class ReduceOps$7{
                makeSink(): java.util.stream.ReduceOps$7ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$7ReducingSink{
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$7ReducingSink);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                begin(param0: number);
                get(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class ReduceOps$8{
                makeSink(): java.util.stream.ReduceOps$8ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$8ReducingSink{
                get(): any;
                get(): number;
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                combine(param0: java.util.stream.ReduceOps$8ReducingSink);
                begin(param0: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class ReduceOps$9{
                makeSink(): java.util.stream.ReduceOps$9ReducingSink;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$9ReducingSink{
                get(): any;
                get(): java.util.OptionalLong;
                accept(param0: number);
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                combine(param0: java.util.stream.ReduceOps$9ReducingSink);
                begin(param0: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class ReduceOps$AccumulatingSink{
                combine(param0: java.util.stream.ReduceOps$AccumulatingSink);
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                get(): any;
            }
            class ReduceOps$Box{
                get(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReduceOps$ReduceOp{
                inputShape(): java.util.stream.StreamShape;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                makeSink(): java.util.stream.ReduceOps$AccumulatingSink;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getOpFlags(): number;
            }
            class ReduceOps$ReduceTask{
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                compute();
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                getRawResult(): any;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReduceOps{
                static makeInt(param0: number, param1: java.util.function.IntBinaryOperator): java.util.stream.TerminalOp;
                static makeInt(param0: java.util.function.IntBinaryOperator): java.util.stream.TerminalOp;
                static makeInt(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BinaryOperator): java.util.stream.TerminalOp;
                static makeLong(param0: number, param1: java.util.function.LongBinaryOperator): java.util.stream.TerminalOp;
                static makeLong(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BinaryOperator): java.util.stream.TerminalOp;
                static makeLong(param0: java.util.function.LongBinaryOperator): java.util.stream.TerminalOp;
                static makeRef(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): java.util.stream.TerminalOp;
                static makeRef(param0: java.util.stream.Collector): java.util.stream.TerminalOp;
                static makeRef(param0: java.util.function.BinaryOperator): java.util.stream.TerminalOp;
                static makeRef(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): java.util.stream.TerminalOp;
                static makeDouble(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BinaryOperator): java.util.stream.TerminalOp;
                static makeDouble(param0: java.util.function.DoubleBinaryOperator): java.util.stream.TerminalOp;
                static makeDouble(param0: number, param1: java.util.function.DoubleBinaryOperator): java.util.stream.TerminalOp;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$1{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$10$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$10{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$11$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$11{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$2$1{
                accept(param0: any);
                begin(param0: number);
                cancellationRequested(): boolean;
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$2{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$3$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$3{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$4$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$4{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$5$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$5{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$6$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$6{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$7$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$7{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$8$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$8{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$9$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class ReferencePipeline$9{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$Head{
                forEach(param0: java.util.function.Consumer);
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$StatefulOp{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline$StatelessOp{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ReferencePipeline{
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                unordered(): java.util.stream.BaseStream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Sink$ChainedDouble{
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class Sink$ChainedInt{
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class Sink$ChainedLong{
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class Sink$ChainedReference{
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Sink$OfDouble{
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class Sink$OfInt{
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class Sink$OfLong{
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class Sink{
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class SliceOps$1$1{
                accept(param0: any);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class SliceOps$1{
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SliceOps$2$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class SliceOps$2{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SliceOps$3$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class SliceOps$3{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SliceOps$4$1{
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class SliceOps$4{
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SliceOps$5{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SliceOps$SliceTask{
                onCompletion(param0: java.util.concurrent.CountedCompleter);
                compute();
                getLocalResult(): any;
                getRawResult(): any;
                static getLeafTarget(): number;
                static suggestTargetSize(param0: number): number;
                getRoot(): java.util.concurrent.CountedCompleter;
                getPendingCount(): number;
                compareAndSetPendingCount(param0: number, param1: number): boolean;
                getCompleter(): java.util.concurrent.CountedCompleter;
                onExceptionalCompletion(param0: java.lang.Throwable, param1: java.util.concurrent.CountedCompleter): boolean;
                setPendingCount(param0: number);
                addToPendingCount(param0: number);
                decrementPendingCountUnlessZero(): number;
                tryComplete();
                propagateCompletion();
                complete(param0: any);
                firstComplete(): java.util.concurrent.CountedCompleter;
                nextComplete(): java.util.concurrent.CountedCompleter;
                quietlyCompleteRoot();
                helpComplete(param0: number);
                invoke(): any;
                get(): any;
                get(param0: number, param1: java.util.concurrent.TimeUnit): any;
                join(): any;
                getException(): java.lang.Throwable;
                reinitialize();
                static getPool(): java.util.concurrent.ForkJoinPool;
                fork(): java.util.concurrent.ForkJoinTask;
                static invokeAll(param0: any[]);
                static invokeAll(param0: java.util.Collection): java.util.Collection;
                static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask);
                cancel(param0: boolean): boolean;
                isDone(): boolean;
                isCancelled(): boolean;
                isCompletedAbnormally(): boolean;
                isCompletedNormally(): boolean;
                completeExceptionally(param0: java.lang.Throwable);
                quietlyJoin();
                quietlyInvoke();
                static helpQuiesce();
                static inForkJoinPool(): boolean;
                tryUnfork(): boolean;
                static getQueuedTaskCount(): number;
                static getSurplusQueuedTaskCount(): number;
                getForkJoinTaskTag(): number;
                setForkJoinTaskTag(param0: number): number;
                compareAndSetForkJoinTaskTag(param0: number, param1: number): boolean;
                static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.lang.Runnable, param1: any): java.util.concurrent.ForkJoinTask;
                static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;
                quietlyComplete();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SliceOps{
                static makeInt(param0: java.util.stream.AbstractPipeline, param1: number, param2: number): java.util.stream.IntStream;
                static makeLong(param0: java.util.stream.AbstractPipeline, param1: number, param2: number): java.util.stream.LongStream;
                static makeRef(param0: java.util.stream.AbstractPipeline, param1: number, param2: number): java.util.stream.Stream;
                static makeDouble(param0: java.util.stream.AbstractPipeline, param1: number, param2: number): java.util.stream.DoubleStream;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SortedOps$AbstractDoubleSortingSink{
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class SortedOps$AbstractIntSortingSink{
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class SortedOps$AbstractLongSortingSink{
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class SortedOps$AbstractRefSortingSink{
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class SortedOps$DoubleSortingSink{
                accept(param0: number);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class SortedOps$IntSortingSink{
                accept(param0: number);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class SortedOps$LongSortingSink{
                accept(param0: number);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class SortedOps$OfDouble{
                opEvaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator, param2: java.util.function.IntFunction): java.util.stream.Node;
                opWrapSink(param0: number, param1: java.util.stream.Sink): java.util.stream.Sink;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.DoubleStream;
                sequential(): java.util.stream.DoubleStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.DoubleStream;
                count(): number;
                min(): java.util.OptionalDouble;
                max(): java.util.OptionalDouble;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfDouble;
                spliterator(): java.util.Spliterator$OfDouble;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjDoubleConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.DoubleConsumer);
                skip(param0: number): java.util.stream.DoubleStream;
                peek(param0: java.util.function.DoubleConsumer): java.util.stream.DoubleStream;
                sum(): number;
                filter(param0: java.util.function.DoublePredicate): java.util.stream.DoubleStream;
                map(param0: java.util.function.DoubleUnaryOperator): java.util.stream.DoubleStream;
                reduce(param0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                reduce(param0: number, param1: java.util.function.DoubleBinaryOperator): number;
                forEachOrdered(param0: java.util.function.DoubleConsumer);
                unordered(): java.util.stream.DoubleStream;
                mapToInt(param0: java.util.function.DoubleToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.DoubleToLongFunction): java.util.stream.LongStream;
                flatMap(param0: java.util.function.DoubleFunction): java.util.stream.DoubleStream;
                distinct(): java.util.stream.DoubleStream;
                sorted(): java.util.stream.DoubleStream;
                anyMatch(param0: java.util.function.DoublePredicate): boolean;
                allMatch(param0: java.util.function.DoublePredicate): boolean;
                noneMatch(param0: java.util.function.DoublePredicate): boolean;
                findFirst(): java.util.OptionalDouble;
                findAny(): java.util.OptionalDouble;
                mapToObj(param0: java.util.function.DoubleFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.DoubleSummaryStatistics;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SortedOps$OfInt{
                opEvaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator, param2: java.util.function.IntFunction): java.util.stream.Node;
                opWrapSink(param0: number, param1: java.util.stream.Sink): java.util.stream.Sink;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.IntStream;
                sequential(): java.util.stream.IntStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.IntStream;
                count(): number;
                min(): java.util.OptionalInt;
                max(): java.util.OptionalInt;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfInt;
                spliterator(): java.util.Spliterator$OfInt;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjIntConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.IntConsumer);
                skip(param0: number): java.util.stream.IntStream;
                peek(param0: java.util.function.IntConsumer): java.util.stream.IntStream;
                sum(): number;
                filter(param0: java.util.function.IntPredicate): java.util.stream.IntStream;
                map(param0: java.util.function.IntUnaryOperator): java.util.stream.IntStream;
                reduce(param0: number, param1: java.util.function.IntBinaryOperator): number;
                reduce(param0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                forEachOrdered(param0: java.util.function.IntConsumer);
                unordered(): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.IntToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.IntToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.IntFunction): java.util.stream.IntStream;
                distinct(): java.util.stream.IntStream;
                sorted(): java.util.stream.IntStream;
                anyMatch(param0: java.util.function.IntPredicate): boolean;
                allMatch(param0: java.util.function.IntPredicate): boolean;
                noneMatch(param0: java.util.function.IntPredicate): boolean;
                findFirst(): java.util.OptionalInt;
                findAny(): java.util.OptionalInt;
                mapToObj(param0: java.util.function.IntFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.IntSummaryStatistics;
                asLongStream(): java.util.stream.LongStream;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SortedOps$OfLong{
                opEvaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator, param2: java.util.function.IntFunction): java.util.stream.Node;
                opWrapSink(param0: number, param1: java.util.stream.Sink): java.util.stream.Sink;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                parallel(): java.util.stream.LongStream;
                sequential(): java.util.stream.LongStream;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.LongStream;
                count(): number;
                min(): java.util.OptionalLong;
                max(): java.util.OptionalLong;
                toArray(): any[];
                iterator(): java.util.PrimitiveIterator$OfLong;
                spliterator(): java.util.Spliterator$OfLong;
                collect(param0: java.util.function.Supplier, param1: java.util.function.ObjLongConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.LongConsumer);
                skip(param0: number): java.util.stream.LongStream;
                peek(param0: java.util.function.LongConsumer): java.util.stream.LongStream;
                sum(): number;
                filter(param0: java.util.function.LongPredicate): java.util.stream.LongStream;
                map(param0: java.util.function.LongUnaryOperator): java.util.stream.LongStream;
                reduce(param0: number, param1: java.util.function.LongBinaryOperator): number;
                reduce(param0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                forEachOrdered(param0: java.util.function.LongConsumer);
                unordered(): java.util.stream.LongStream;
                mapToInt(param0: java.util.function.LongToIntFunction): java.util.stream.IntStream;
                mapToDouble(param0: java.util.function.LongToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.LongFunction): java.util.stream.LongStream;
                distinct(): java.util.stream.LongStream;
                sorted(): java.util.stream.LongStream;
                anyMatch(param0: java.util.function.LongPredicate): boolean;
                allMatch(param0: java.util.function.LongPredicate): boolean;
                noneMatch(param0: java.util.function.LongPredicate): boolean;
                findFirst(): java.util.OptionalLong;
                findAny(): java.util.OptionalLong;
                mapToObj(param0: java.util.function.LongFunction): java.util.stream.Stream;
                average(): java.util.OptionalDouble;
                summaryStatistics(): java.util.LongSummaryStatistics;
                asDoubleStream(): java.util.stream.DoubleStream;
                boxed(): java.util.stream.Stream;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SortedOps$OfRef{
                opEvaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator, param2: java.util.function.IntFunction): java.util.stream.Node;
                opWrapSink(param0: number, param1: java.util.stream.Sink): java.util.stream.Sink;
                unordered(): java.util.stream.BaseStream;
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                toArray(): any[];
                toArray(param0: java.util.function.IntFunction): any[];
                iterator(): java.util.Iterator;
                collect(param0: java.util.stream.Collector): any;
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                forEachOrdered(param0: java.util.function.Consumer);
                unordered(): java.util.stream.Stream;
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                isParallel(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SortedOps$RefSortingSink{
                accept(param0: any);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class SortedOps$SizedDoubleSortingSink{
                accept(param0: number);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class SortedOps$SizedIntSortingSink{
                accept(param0: number);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class SortedOps$SizedLongSortingSink{
                accept(param0: number);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: any);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class SortedOps$SizedRefSortingSink{
                accept(param0: any);
                begin(param0: number);
                end();
                cancellationRequested(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class SortedOps{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class SpinedBuffer$1Splitr{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class SpinedBuffer$OfDouble$1Splitr{
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfDouble;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfPrimitive;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class SpinedBuffer$OfDouble{
                get(param0: number): number;
                toString(): string;
                newArray(param0: number): any[];
                newArray(param0: number): any;
                iterator(): java.util.PrimitiveIterator$OfDouble;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfDouble;
                accept(param0: number);
                forEach(param0: java.util.function.Consumer);
                clear();
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any;
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class SpinedBuffer$OfInt$1Splitr{
                forEachRemaining(param0: java.util.function.IntConsumer);
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfInt;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfPrimitive;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class SpinedBuffer$OfInt{
                get(param0: number): number;
                toString(): string;
                newArray(param0: number): any[];
                newArray(param0: number): any;
                iterator(): java.util.PrimitiveIterator$OfInt;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfInt;
                accept(param0: number);
                forEach(param0: java.util.function.Consumer);
                clear();
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any;
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class SpinedBuffer$OfLong$1Splitr{
                forEachRemaining(param0: java.util.function.LongConsumer);
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfLong;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfPrimitive;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class SpinedBuffer$OfLong{
                get(param0: number): number;
                toString(): string;
                newArray(param0: number): any[];
                newArray(param0: number): any;
                iterator(): java.util.PrimitiveIterator$OfLong;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                spliterator(): java.util.Spliterator$OfLong;
                accept(param0: number);
                forEach(param0: java.util.function.Consumer);
                clear();
                forEach(param0: any);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any;
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class SpinedBuffer$OfPrimitive$BaseSpliterator{
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfPrimitive;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class SpinedBuffer$OfPrimitive{
                newArray(param0: number): any;
                clear();
                iterator(): java.util.Iterator;
                forEach(param0: any);
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any, param1: number);
                asPrimitiveArray(): any;
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                spliterator(): java.util.Spliterator;
            }
            class SpinedBuffer{
                get(param0: number): any;
                toString(): string;
                clear();
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                accept(param0: any);
                forEach(param0: java.util.function.Consumer);
                copyInto(param0: any[], param1: number);
                asArray(param0: java.util.function.IntFunction): any[];
                count(): number;
                isEmpty(): boolean;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Stream$1{
                hasNext(): boolean;
                next(): any;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                remove();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class Stream$Builder{
                add(param0: any): java.util.stream.Stream$Builder;
                accept(param0: any);
                build(): java.util.stream.Stream;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Stream{
                limit(param0: number): java.util.stream.Stream;
                count(): number;
                min(param0: java.util.Comparator): java.util.Optional;
                max(param0: java.util.Comparator): java.util.Optional;
                static concat(param0: java.util.stream.Stream, param1: java.util.stream.Stream): java.util.stream.Stream;
                toArray(param0: java.util.function.IntFunction): any[];
                toArray(): any[];
                collect(param0: java.util.function.Supplier, param1: java.util.function.BiConsumer, param2: java.util.function.BiConsumer): any;
                collect(param0: java.util.stream.Collector): any;
                forEach(param0: java.util.function.Consumer);
                skip(param0: number): java.util.stream.Stream;
                peek(param0: java.util.function.Consumer): java.util.stream.Stream;
                static of(param0: any[]): java.util.stream.Stream;
                static of(param0: any): java.util.stream.Stream;
                static empty(): java.util.stream.Stream;
                filter(param0: java.util.function.Predicate): java.util.stream.Stream;
                map(param0: java.util.function.Function): java.util.stream.Stream;
                reduce(param0: java.util.function.BinaryOperator): java.util.Optional;
                reduce(param0: any, param1: java.util.function.BiFunction, param2: java.util.function.BinaryOperator): any;
                reduce(param0: any, param1: java.util.function.BinaryOperator): any;
                static builder(): java.util.stream.Stream$Builder;
                static iterate(param0: any, param1: java.util.function.UnaryOperator): java.util.stream.Stream;
                static generate(param0: java.util.function.Supplier): java.util.stream.Stream;
                forEachOrdered(param0: java.util.function.Consumer);
                mapToInt(param0: java.util.function.ToIntFunction): java.util.stream.IntStream;
                mapToLong(param0: java.util.function.ToLongFunction): java.util.stream.LongStream;
                mapToDouble(param0: java.util.function.ToDoubleFunction): java.util.stream.DoubleStream;
                flatMap(param0: java.util.function.Function): java.util.stream.Stream;
                flatMapToInt(param0: java.util.function.Function): java.util.stream.IntStream;
                flatMapToDouble(param0: java.util.function.Function): java.util.stream.DoubleStream;
                flatMapToLong(param0: java.util.function.Function): java.util.stream.LongStream;
                distinct(): java.util.stream.Stream;
                sorted(): java.util.stream.Stream;
                sorted(param0: java.util.Comparator): java.util.stream.Stream;
                anyMatch(param0: java.util.function.Predicate): boolean;
                allMatch(param0: java.util.function.Predicate): boolean;
                noneMatch(param0: java.util.function.Predicate): boolean;
                findFirst(): java.util.Optional;
                findAny(): java.util.Optional;
                iterator(): java.util.Iterator;
                spliterator(): java.util.Spliterator;
                close();
                parallel(): java.util.stream.BaseStream;
                onClose(param0: java.lang.Runnable): java.util.stream.BaseStream;
                sequential(): java.util.stream.BaseStream;
                unordered(): java.util.stream.BaseStream;
                isParallel(): boolean;
            }
            class StreamOpFlag$MaskBuilder{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamOpFlag$Type{
                static values(): any[];
                static valueOf(param0: string): java.util.stream.StreamOpFlag$Type;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamOpFlag{
                static values(): any[];
                static valueOf(param0: string): java.util.stream.StreamOpFlag;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamShape{
                static values(): any[];
                static valueOf(param0: string): java.util.stream.StreamShape;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamSpliterators$1{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamSpliterators$AbstractWrappingSpliterator{
                toString(): string;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                hasCharacteristics(param0: number): boolean;
            }
            class StreamSpliterators$ArrayBuffer$OfDouble{
                accept(param0: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class StreamSpliterators$ArrayBuffer$OfInt{
                accept(param0: number);
                forEach(param0: any, param1: number);
                forEach(param0: java.util.function.IntConsumer, param1: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class StreamSpliterators$ArrayBuffer$OfLong{
                accept(param0: number);
                forEach(param0: any, param1: number);
                forEach(param0: java.util.function.LongConsumer, param1: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class StreamSpliterators$ArrayBuffer$OfPrimitive{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamSpliterators$ArrayBuffer$OfRef{
                accept(param0: any);
                forEach(param0: java.util.function.Consumer, param1: number);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class StreamSpliterators$ArrayBuffer{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamSpliterators$DelegatingSpliterator$OfDouble{
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfDouble;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                toString(): string;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
            }
            class StreamSpliterators$DelegatingSpliterator$OfInt{
                forEachRemaining(param0: java.util.function.IntConsumer);
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfInt;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                toString(): string;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
            }
            class StreamSpliterators$DelegatingSpliterator$OfLong{
                forEachRemaining(param0: java.util.function.LongConsumer);
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfLong;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                toString(): string;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
            }
            class StreamSpliterators$DelegatingSpliterator$OfPrimitive{
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                toString(): string;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
            }
            class StreamSpliterators$DelegatingSpliterator{
                toString(): string;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
            }
            class StreamSpliterators$DistinctSpliterator{
                accept(param0: any);
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class StreamSpliterators$DoubleWrappingSpliterator{
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator$OfDouble;
                trySplit(): java.util.Spliterator;
                toString(): string;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$InfiniteSupplyingSpliterator$OfDouble{
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfDouble;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$InfiniteSupplyingSpliterator$OfInt{
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfInt;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.IntConsumer);
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$InfiniteSupplyingSpliterator$OfLong{
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                trySplit(): java.util.Spliterator$OfLong;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.LongConsumer);
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$InfiniteSupplyingSpliterator$OfRef{
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class StreamSpliterators$InfiniteSupplyingSpliterator{
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class StreamSpliterators$IntWrappingSpliterator{
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.IntConsumer);
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator$OfInt;
                trySplit(): java.util.Spliterator;
                toString(): string;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$LongWrappingSpliterator{
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.LongConsumer);
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator$OfLong;
                trySplit(): java.util.Spliterator;
                toString(): string;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$SliceSpliterator$OfDouble{
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfDouble;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$SliceSpliterator$OfInt{
                forEachRemaining(param0: java.util.function.IntConsumer);
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfInt;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$SliceSpliterator$OfLong{
                forEachRemaining(param0: java.util.function.LongConsumer);
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfLong;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class StreamSpliterators$SliceSpliterator$OfPrimitive{
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class StreamSpliterators$SliceSpliterator$OfRef{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class StreamSpliterators$SliceSpliterator{
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamSpliterators$UnorderedSliceSpliterator$OfDouble{
                accept(param0: number);
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfDouble;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
            }
            class StreamSpliterators$UnorderedSliceSpliterator$OfInt{
                accept(param0: number);
                forEachRemaining(param0: java.util.function.IntConsumer);
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfInt;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
            }
            class StreamSpliterators$UnorderedSliceSpliterator$OfLong{
                accept(param0: number);
                forEachRemaining(param0: java.util.function.LongConsumer);
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfLong;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
            }
            class StreamSpliterators$UnorderedSliceSpliterator$OfPrimitive{
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class StreamSpliterators$UnorderedSliceSpliterator$OfRef{
                accept(param0: any);
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class StreamSpliterators$UnorderedSliceSpliterator$PermitStatus{
                static values(): any[];
                static valueOf(param0: string): java.util.stream.StreamSpliterators$UnorderedSliceSpliterator$PermitStatus;
                name(): string;
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                compareTo(param0: any): number;
                compareTo(param0: java.lang.Enum): number;
                static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                getDeclaringClass(): java.lang.Class;
                ordinal(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamSpliterators$UnorderedSliceSpliterator{
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamSpliterators$WrappingSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                toString(): string;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                hasCharacteristics(param0: number): boolean;
            }
            class StreamSpliterators{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class StreamSupport{
                static intStream(param0: java.util.function.Supplier, param1: number, param2: boolean): java.util.stream.IntStream;
                static intStream(param0: java.util.Spliterator$OfInt, param1: boolean): java.util.stream.IntStream;
                static stream(param0: java.util.function.Supplier, param1: number, param2: boolean): java.util.stream.Stream;
                static stream(param0: java.util.Spliterator, param1: boolean): java.util.stream.Stream;
                static longStream(param0: java.util.function.Supplier, param1: number, param2: boolean): java.util.stream.LongStream;
                static longStream(param0: java.util.Spliterator$OfLong, param1: boolean): java.util.stream.LongStream;
                static doubleStream(param0: java.util.Spliterator$OfDouble, param1: boolean): java.util.stream.DoubleStream;
                static doubleStream(param0: java.util.function.Supplier, param1: number, param2: boolean): java.util.stream.DoubleStream;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Streams$1{
                run();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Streams$2{
                run();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Streams$AbstractStreamBuilderImpl{
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
            }
            class Streams$ConcatSpliterator$OfDouble{
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfDouble;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class Streams$ConcatSpliterator$OfInt{
                forEachRemaining(param0: java.util.function.IntConsumer);
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfInt;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class Streams$ConcatSpliterator$OfLong{
                forEachRemaining(param0: java.util.function.LongConsumer);
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfLong;
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class Streams$ConcatSpliterator$OfPrimitive{
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class Streams$ConcatSpliterator$OfRef{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class Streams$ConcatSpliterator{
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class Streams$DoubleStreamBuilderImpl{
                accept(param0: number);
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.DoubleConsumer);
                build(): java.util.stream.DoubleStream;
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.DoubleConsumer): boolean;
                trySplit(): java.util.Spliterator$OfDouble;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                add(param0: number): java.util.stream.DoubleStream$Builder;
                andThen(param0: java.util.function.DoubleConsumer): java.util.function.DoubleConsumer;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class Streams$IntStreamBuilderImpl{
                accept(param0: number);
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.IntConsumer);
                build(): java.util.stream.IntStream;
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfInt;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                add(param0: number): java.util.stream.IntStream$Builder;
                andThen(param0: java.util.function.IntConsumer): java.util.function.IntConsumer;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class Streams$LongStreamBuilderImpl{
                accept(param0: number);
                forEachRemaining(param0: any);
                forEachRemaining(param0: java.util.function.LongConsumer);
                build(): java.util.stream.LongStream;
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfLong;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                add(param0: number): java.util.stream.LongStream$Builder;
                andThen(param0: java.util.function.LongConsumer): java.util.function.LongConsumer;
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
            }
            class Streams$RangeIntSpliterator{
                forEachRemaining(param0: java.util.function.IntConsumer);
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.IntConsumer): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator$OfInt;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class Streams$RangeLongSpliterator{
                forEachRemaining(param0: java.util.function.LongConsumer);
                forEachRemaining(param0: any);
                tryAdvance(param0: any): boolean;
                tryAdvance(param0: java.util.function.LongConsumer): boolean;
                trySplit(): java.util.Spliterator$OfPrimitive;
                trySplit(): java.util.Spliterator$OfLong;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                getComparator(): java.util.Comparator;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                forEachRemaining(param0: java.util.function.Consumer);
                tryAdvance(param0: java.util.function.Consumer): boolean;
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
            }
            class Streams$StreamBuilderImpl{
                add(param0: any): java.util.stream.Stream$Builder;
                accept(param0: any);
                forEachRemaining(param0: java.util.function.Consumer);
                build(): java.util.stream.Stream;
                tryAdvance(param0: java.util.function.Consumer): boolean;
                trySplit(): java.util.Spliterator;
                estimateSize(): number;
                characteristics(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                getExactSizeIfKnown(): number;
                hasCharacteristics(param0: number): boolean;
                getComparator(): java.util.Comparator;
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
            }
            class Streams{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class TerminalOp{
                inputShape(): java.util.stream.StreamShape;
                getOpFlags(): number;
                evaluateParallel(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
                evaluateSequential(param0: java.util.stream.PipelineHelper, param1: java.util.Spliterator): any;
            }
            class TerminalSink{
                accept(param0: number);
                accept(param0: number);
                accept(param0: number);
                cancellationRequested(): boolean;
                begin(param0: number);
                end();
                accept(param0: any);
                andThen(param0: java.util.function.Consumer): java.util.function.Consumer;
                get(): any;
            }
            class Tripwire{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        namespace zip{
            class Adler32{
                update(param0: number);
                update(param0: java.nio.ByteBuffer);
                update(param0: any[], param1: number, param2: number);
                update(param0: any[]);
                getValue(): number;
                reset();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CheckedInputStream{
                read(param0: any[], param1: number, param2: number): number;
                read(): number;
                skip(param0: number): number;
                getChecksum(): java.util.zip.Checksum;
                read(param0: any[]): number;
                close();
                mark(param0: number);
                available(): number;
                markSupported(): boolean;
                reset();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class CheckedOutputStream{
                write(param0: any[], param1: number, param2: number);
                write(param0: number);
                getChecksum(): java.util.zip.Checksum;
                write(param0: any[]);
                flush();
                close();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DataFormatException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Deflater{
                reset();
                setStrategy(param0: number);
                end();
                finished(): boolean;
                setInput(param0: any[], param1: number, param2: number);
                setInput(param0: any[]);
                setDictionary(param0: any[]);
                setDictionary(param0: any[], param1: number, param2: number);
                needsInput(): boolean;
                getAdler(): number;
                getTotalIn(): number;
                getBytesRead(): number;
                getTotalOut(): number;
                getBytesWritten(): number;
                setLevel(param0: number);
                finish();
                deflate(param0: any[]): number;
                deflate(param0: any[], param1: number, param2: number, param3: number): number;
                deflate(param0: any[], param1: number, param2: number): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DeflaterInputStream{
                read(): number;
                read(param0: any[], param1: number, param2: number): number;
                close();
                mark(param0: number);
                skip(param0: number): number;
                available(): number;
                markSupported(): boolean;
                reset();
                read(param0: any[]): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class DeflaterOutputStream{
                write(param0: any[], param1: number, param2: number);
                write(param0: number);
                flush();
                close();
                finish();
                write(param0: any[]);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class GZIPInputStream$1{
                close();
                read(param0: any[], param1: number, param2: number): number;
                read(param0: any[]): number;
                read(): number;
                mark(param0: number);
                skip(param0: number): number;
                available(): number;
                markSupported(): boolean;
                reset();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class GZIPInputStream{
                read(param0: any[], param1: number, param2: number): number;
                close();
                read(): number;
                mark(param0: number);
                skip(param0: number): number;
                available(): number;
                markSupported(): boolean;
                reset();
                read(param0: any[]): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class GZIPOutputStream{
                write(param0: any[], param1: number, param2: number);
                finish();
                write(param0: number);
                flush();
                close();
                write(param0: any[]);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InflaterOutputStream{
                write(param0: number);
                write(param0: any[], param1: number, param2: number);
                flush();
                close();
                finish();
                write(param0: any[]);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipConstants64{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipError{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipInputStream{
                read(param0: any[], param1: number, param2: number): number;
                close();
                skip(param0: number): number;
                available(): number;
                getNextEntry(): java.util.zip.ZipEntry;
                closeEntry();
                read(): number;
                mark(param0: number);
                markSupported(): boolean;
                reset();
                read(param0: any[]): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipOutputStream$XEntry{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipOutputStream{
                write(param0: any[], param1: number, param2: number);
                close();
                setMethod(param0: number);
                setComment(param0: string);
                closeEntry();
                putNextEntry(param0: java.util.zip.ZipEntry);
                setLevel(param0: number);
                finish();
                write(param0: number);
                flush();
                write(param0: any[]);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipUtils{
                static fileTimeToWinTime(param0: java.nio.file.attribute.FileTime): number;
                static javaToExtendedDosTime(param0: number): number;
                static extendedDosToJavaTime(param0: number): number;
                static get16(param0: any[], param1: number): number;
                static get64(param0: any[], param1: number): number;
                static winTimeToFileTime(param0: number): java.nio.file.attribute.FileTime;
                static get32(param0: any[], param1: number): number;
                static unixTimeToFileTime(param0: number): java.nio.file.attribute.FileTime;
                static fileTimeToUnixTime(param0: java.nio.file.attribute.FileTime): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipFile$ZipFileInputStream{
                size(): number;
                read(): number;
                read(param0: any[], param1: number, param2: number): number;
                close();
                skip(param0: number): number;
                available(): number;
                read(param0: any[]): number;
                mark(param0: number);
                markSupported(): boolean;
                reset();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipFile$ZipFileInflaterInputStream{
                close();
                available(): number;
                read(): number;
                read(param0: any[], param1: number, param2: number): number;
                mark(param0: number);
                skip(param0: number): number;
                markSupported(): boolean;
                reset();
                read(param0: any[]): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipFile$ZipEntryIterator{
                hasNext(): boolean;
                next(): java.util.zip.ZipEntry;
                next(): any;
                hasMoreElements(): boolean;
                nextElement(): any;
                nextElement(): java.util.zip.ZipEntry;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
                remove();
                forEachRemaining(param0: java.util.function.Consumer);
            }
            class ZipFile$1{
                startsWithLocHeader(param0: java.util.zip.ZipFile): boolean;
                getManifestNum(param0: java.util.jar.JarFile): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipFile{
                getName(): string;
                size(): number;
                stream(): java.util.stream.Stream;
                close();
                getInputStream(param0: java.util.zip.ZipEntry): java.io.InputStream;
                entries(): java.util.Enumeration;
                getEntry(param0: string): java.util.zip.ZipEntry;
                getComment(): string;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipException{
                printStackTrace(param0: java.io.PrintStream);
                printStackTrace();
                printStackTrace(param0: java.io.PrintWriter);
                fillInStackTrace(): java.lang.Throwable;
                getCause(): java.lang.Throwable;
                initCause(param0: java.lang.Throwable): java.lang.Throwable;
                toString(): string;
                getMessage(): string;
                getLocalizedMessage(): string;
                getStackTrace(): any[];
                setStackTrace(param0: any[]);
                addSuppressed(param0: java.lang.Throwable);
                getSuppressed(): any[];
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipEntry{
                toString(): string;
                hashCode(): number;
                clone(): any;
                getName(): string;
                getMethod(): number;
                getSize(): number;
                isDirectory(): boolean;
                getLastModifiedTime(): java.nio.file.attribute.FileTime;
                setLastModifiedTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                setSize(param0: number);
                getComment(): string;
                setTime(param0: number);
                getTime(): number;
                setLastAccessTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                getLastAccessTime(): java.nio.file.attribute.FileTime;
                setCreationTime(param0: java.nio.file.attribute.FileTime): java.util.zip.ZipEntry;
                getCreationTime(): java.nio.file.attribute.FileTime;
                getCompressedSize(): number;
                setCompressedSize(param0: number);
                setCrc(param0: number);
                getCrc(): number;
                setMethod(param0: number);
                setExtra(param0: any[]);
                getExtra(): any[];
                setComment(param0: string);
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZipConstants{
            }
            class ZipCoder{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class ZStreamRef{
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class InflaterInputStream{
                read(): number;
                read(param0: any[], param1: number, param2: number): number;
                close();
                mark(param0: number);
                skip(param0: number): number;
                available(): number;
                markSupported(): boolean;
                reset();
                read(param0: any[]): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Inflater{
                reset();
                end();
                finished(): boolean;
                setInput(param0: any[], param1: number, param2: number);
                setInput(param0: any[]);
                setDictionary(param0: any[], param1: number, param2: number);
                setDictionary(param0: any[]);
                getRemaining(): number;
                needsInput(): boolean;
                needsDictionary(): boolean;
                inflate(param0: any[], param1: number, param2: number): number;
                inflate(param0: any[]): number;
                getAdler(): number;
                getTotalIn(): number;
                getBytesRead(): number;
                getTotalOut(): number;
                getBytesWritten(): number;
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
            class Checksum{
                update(param0: number);
                update(param0: any[], param1: number, param2: number);
                getValue(): number;
                reset();
            }
            class CRC32{
                update(param0: number);
                update(param0: java.nio.ByteBuffer);
                update(param0: any[], param1: number, param2: number);
                update(param0: any[]);
                getValue(): number;
                reset();
                wait(param0: number, param1: number);
                wait(param0: number);
                wait();
                equals(param0: any): boolean;
                toString(): string;
                hashCode(): number;
                getClass(): java.lang.Class;
                notify();
                notifyAll();
            }
        }
        class WeakHashMap$KeySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class WeakHashMap$KeyIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class WeakHashMap$HashIterator{
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class WeakHashMap$Entry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            get(): any;
            clear();
            isEnqueued(): boolean;
            enqueue(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class WeakHashMap{
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            values(): java.util.Collection;
            clear();
            isEmpty(): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            putIfAbsent(param0: any, param1: any): any;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class Vector$ListItr{
            add(param0: any);
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Vector$Itr{
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Vector$1{
            hasMoreElements(): boolean;
            nextElement(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Vector{
            add(param0: any): boolean;
            add(param0: number, param1: any);
            remove(param0: any): boolean;
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clone(): any;
            indexOf(param0: any, param1: number): number;
            indexOf(param0: any): number;
            clear();
            isEmpty(): boolean;
            lastIndexOf(param0: any, param1: number): number;
            lastIndexOf(param0: any): number;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            subList(param0: number, param1: number): java.util.List;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            addAll(param0: number, param1: java.util.Collection): boolean;
            addElement(param0: any);
            elementAt(param0: number): any;
            elements(): java.util.Enumeration;
            forEach(param0: java.util.function.Consumer);
            set(param0: number, param1: any): any;
            capacity(): number;
            ensureCapacity(param0: number);
            trimToSize();
            copyInto(param0: any[]);
            setSize(param0: number);
            firstElement(): any;
            lastElement(): any;
            setElementAt(param0: any, param1: number);
            removeElementAt(param0: number);
            insertElementAt(param0: any, param1: number);
            removeElement(param0: any): boolean;
            removeAllElements();
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            listIterator(): java.util.ListIterator;
            listIterator(param0: number): java.util.ListIterator;
            removeIf(param0: java.util.function.Predicate): boolean;
            sort(param0: java.util.Comparator);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            parallelStream(): java.util.stream.Stream;
        }
        class TreeSet{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            clone(): any;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            first(): any;
            floor(param0: any): any;
            pollFirst(): any;
            pollLast(): any;
            descendingIterator(): java.util.Iterator;
            last(): any;
            lower(param0: any): any;
            ceiling(param0: any): any;
            higher(param0: any): any;
            descendingSet(): java.util.NavigableSet;
            subSet(param0: any, param1: any): java.util.SortedSet;
            subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
            headSet(param0: any, param1: boolean): java.util.NavigableSet;
            headSet(param0: any): java.util.SortedSet;
            tailSet(param0: any, param1: boolean): java.util.NavigableSet;
            tailSet(param0: any): java.util.SortedSet;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class TreeMap$PrivateEntryIterator{
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class TreeMap$KeySet{
            remove(param0: any): boolean;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            first(): any;
            floor(param0: any): any;
            pollFirst(): any;
            pollLast(): any;
            descendingIterator(): java.util.Iterator;
            last(): any;
            lower(param0: any): any;
            ceiling(param0: any): any;
            higher(param0: any): any;
            descendingSet(): java.util.NavigableSet;
            subSet(param0: any, param1: any): java.util.SortedSet;
            subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
            headSet(param0: any): java.util.SortedSet;
            headSet(param0: any, param1: boolean): java.util.NavigableSet;
            tailSet(param0: any): java.util.SortedSet;
            tailSet(param0: any, param1: boolean): java.util.NavigableSet;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class TreeMap$KeyIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class TreeMap$Entry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TreeMap{
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            values(): java.util.Collection;
            clone(): any;
            clear();
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            firstKey(): any;
            lastKey(): any;
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            descendingMap(): java.util.NavigableMap;
            navigableKeySet(): java.util.NavigableSet;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            isEmpty(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            putIfAbsent(param0: any, param1: any): any;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class TimeZone$1{
            run(): java.lang.Void;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TimeZone{
            clone(): any;
            static getDefault(): java.util.TimeZone;
            getOffset(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number): number;
            getOffset(param0: number): number;
            static setDefault(param0: java.util.TimeZone);
            getDisplayName(param0: boolean, param1: number): string;
            getDisplayName(param0: boolean, param1: number, param2: java.util.Locale): string;
            getDisplayName(): string;
            getDisplayName(param0: java.util.Locale): string;
            getID(): string;
            static getTimeZone(param0: string): java.util.TimeZone;
            static getTimeZone(param0: java.time.ZoneId): java.util.TimeZone;
            setRawOffset(param0: number);
            getRawOffset(): number;
            useDaylightTime(): boolean;
            observesDaylightTime(): boolean;
            inDaylightTime(param0: java.util.Date): boolean;
            getDSTSavings(): number;
            static getAvailableIDs(param0: number): any[];
            static getAvailableIDs(): any[];
            hasSameRules(param0: java.util.TimeZone): boolean;
            setID(param0: string);
            toZoneId(): java.time.ZoneId;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class TimSort{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class StringTokenizer{
            countTokens(): number;
            hasMoreElements(): boolean;
            nextToken(param0: string): string;
            nextToken(): string;
            nextElement(): any;
            hasMoreTokens(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Stack{
            push(param0: any): any;
            pop(): any;
            peek(): any;
            empty(): boolean;
            search(param0: any): number;
            add(param0: any): boolean;
            add(param0: number, param1: any);
            remove(param0: any): boolean;
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clone(): any;
            indexOf(param0: any, param1: number): number;
            indexOf(param0: any): number;
            clear();
            isEmpty(): boolean;
            lastIndexOf(param0: any, param1: number): number;
            lastIndexOf(param0: any): number;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            subList(param0: number, param1: number): java.util.List;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            addAll(param0: number, param1: java.util.Collection): boolean;
            addElement(param0: any);
            elementAt(param0: number): any;
            elements(): java.util.Enumeration;
            forEach(param0: java.util.function.Consumer);
            set(param0: number, param1: any): any;
            capacity(): number;
            ensureCapacity(param0: number);
            trimToSize();
            copyInto(param0: any[]);
            setSize(param0: number);
            firstElement(): any;
            lastElement(): any;
            setElementAt(param0: any, param1: number);
            removeElementAt(param0: number);
            insertElementAt(param0: any, param1: number);
            removeElement(param0: any): boolean;
            removeAllElements();
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            listIterator(): java.util.ListIterator;
            listIterator(param0: number): java.util.ListIterator;
            removeIf(param0: java.util.function.Predicate): boolean;
            sort(param0: java.util.Comparator);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            parallelStream(): java.util.stream.Stream;
        }
        class SortedSet{
            spliterator(): java.util.Spliterator;
            first(): any;
            last(): any;
            subSet(param0: any, param1: any): java.util.SortedSet;
            headSet(param0: any): java.util.SortedSet;
            tailSet(param0: any): java.util.SortedSet;
            comparator(): java.util.Comparator;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class SortedMap{
            values(): java.util.Collection;
            entrySet(): java.util.Set;
            keySet(): java.util.Set;
            firstKey(): any;
            lastKey(): any;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            tailMap(param0: any): java.util.SortedMap;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class Set{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class ServiceLoader$LazyIterator{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class ServiceLoader$1{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class ServiceLoader{
            toString(): string;
            iterator(): java.util.Iterator;
            static load(param0: java.lang.Class): java.util.ServiceLoader;
            static load(param0: java.lang.Class, param1: java.lang.ClassLoader): java.util.ServiceLoader;
            static loadInstalled(param0: java.lang.Class): java.util.ServiceLoader;
            reload();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
        }
        class ResourceBundle$SingleFormatControl{
            getFormats(param0: string): java.util.List;
            static getNoFallbackControl(param0: java.util.List): java.util.ResourceBundle$Control;
            getCandidateLocales(param0: string, param1: java.util.Locale): java.util.List;
            getFallbackLocale(param0: string, param1: java.util.Locale): java.util.Locale;
            static getControl(param0: java.util.List): java.util.ResourceBundle$Control;
            newBundle(param0: string, param1: java.util.Locale, param2: string, param3: java.lang.ClassLoader, param4: boolean): java.util.ResourceBundle;
            getTimeToLive(param0: string, param1: java.util.Locale): number;
            needsReload(param0: string, param1: java.util.Locale, param2: string, param3: java.lang.ClassLoader, param4: java.util.ResourceBundle, param5: number): boolean;
            toBundleName(param0: string, param1: java.util.Locale): string;
            toResourceName(param0: string, param1: string): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$RBClassLoader$1{
            run(): java.util.ResourceBundle$RBClassLoader;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$RBClassLoader{
            loadClass(param0: string): java.lang.Class;
            getResourceAsStream(param0: string): java.io.InputStream;
            getResource(param0: string): java.net.URL;
            static getSystemClassLoader(): java.lang.ClassLoader;
            static getSystemResourceAsStream(param0: string): java.io.InputStream;
            static getSystemResource(param0: string): java.net.URL;
            getResources(param0: string): java.util.Enumeration;
            static getSystemResources(param0: string): java.util.Enumeration;
            getParent(): java.lang.ClassLoader;
            setDefaultAssertionStatus(param0: boolean);
            setPackageAssertionStatus(param0: string, param1: boolean);
            setClassAssertionStatus(param0: string, param1: boolean);
            clearAssertionStatus();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$LoaderReference{
            getCacheKey(): java.util.ResourceBundle$CacheKey;
            get(): any;
            clear();
            isEnqueued(): boolean;
            enqueue(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$Control$CandidateListCache{
            get(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$Control$1{
            run(): java.io.InputStream;
            run(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$Control{
            static getNoFallbackControl(param0: java.util.List): java.util.ResourceBundle$Control;
            getCandidateLocales(param0: string, param1: java.util.Locale): java.util.List;
            getFallbackLocale(param0: string, param1: java.util.Locale): java.util.Locale;
            getFormats(param0: string): java.util.List;
            static getControl(param0: java.util.List): java.util.ResourceBundle$Control;
            newBundle(param0: string, param1: java.util.Locale, param2: string, param3: java.lang.ClassLoader, param4: boolean): java.util.ResourceBundle;
            getTimeToLive(param0: string, param1: java.util.Locale): number;
            needsReload(param0: string, param1: java.util.Locale, param2: string, param3: java.lang.ClassLoader, param4: java.util.ResourceBundle, param5: number): boolean;
            toBundleName(param0: string, param1: java.util.Locale): string;
            toResourceName(param0: string, param1: string): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$CacheKeyReference{
            getCacheKey(): java.util.ResourceBundle$CacheKey;
        }
        class ResourceBundle$CacheKey{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clone(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$BundleReference{
            getCacheKey(): java.util.ResourceBundle$CacheKey;
            get(): any;
            clear();
            isEnqueued(): boolean;
            enqueue(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle$1{
            toString(): string;
            getKeys(): java.util.Enumeration;
            getObject(param0: string): any;
            keySet(): java.util.Set;
            containsKey(param0: string): boolean;
            getString(param0: string): string;
            getBaseBundleName(): string;
            getStringArray(param0: string): any[];
            getLocale(): java.util.Locale;
            static getBundle(param0: string, param1: java.util.Locale): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static getBundle(param0: string): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader, param3: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static clearCache(param0: java.lang.ClassLoader);
            static clearCache();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ResourceBundle{
            getObject(param0: string): any;
            keySet(): java.util.Set;
            containsKey(param0: string): boolean;
            getKeys(): java.util.Enumeration;
            getString(param0: string): string;
            getBaseBundleName(): string;
            getStringArray(param0: string): any[];
            getLocale(): java.util.Locale;
            static getBundle(param0: string, param1: java.util.Locale): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static getBundle(param0: string): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader, param3: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static clearCache(param0: java.lang.ClassLoader);
            static clearCache();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class RandomAccess{
        }
        class Random{
            nextInt(): number;
            nextInt(param0: number): number;
            nextDouble(): number;
            nextBoolean(): boolean;
            nextFloat(): number;
            nextBytes(param0: any[]);
            ints(param0: number, param1: number): java.util.stream.IntStream;
            ints(param0: number, param1: number, param2: number): java.util.stream.IntStream;
            ints(param0: number): java.util.stream.IntStream;
            ints(): java.util.stream.IntStream;
            longs(param0: number, param1: number): java.util.stream.LongStream;
            longs(param0: number): java.util.stream.LongStream;
            longs(): java.util.stream.LongStream;
            longs(param0: number, param1: number, param2: number): java.util.stream.LongStream;
            doubles(): java.util.stream.DoubleStream;
            doubles(param0: number, param1: number, param2: number): java.util.stream.DoubleStream;
            doubles(param0: number): java.util.stream.DoubleStream;
            doubles(param0: number, param1: number): java.util.stream.DoubleStream;
            setSeed(param0: number);
            nextGaussian(): number;
            nextLong(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Queue{
            add(param0: any): boolean;
            remove(): any;
            poll(): any;
            peek(): any;
            offer(param0: any): boolean;
            element(): any;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class PropertyResourceBundle{
            getKeys(): java.util.Enumeration;
            handleGetObject(param0: string): any;
            getObject(param0: string): any;
            keySet(): java.util.Set;
            containsKey(param0: string): boolean;
            getString(param0: string): string;
            getBaseBundleName(): string;
            getStringArray(param0: string): any[];
            getLocale(): java.util.Locale;
            static getBundle(param0: string, param1: java.util.Locale): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static getBundle(param0: string): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader, param3: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static clearCache(param0: java.lang.ClassLoader);
            static clearCache();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Properties$LineReader{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Properties{
            setProperty(param0: string, param1: string): any;
            getProperty(param0: string, param1: string): string;
            getProperty(param0: string): string;
            load(param0: java.io.Reader);
            load(param0: java.io.InputStream);
            list(param0: java.io.PrintWriter);
            list(param0: java.io.PrintStream);
            save(param0: java.io.OutputStream, param1: string);
            store(param0: java.io.OutputStream, param1: string);
            store(param0: java.io.Writer, param1: string);
            loadFromXML(param0: java.io.InputStream);
            storeToXML(param0: java.io.OutputStream, param1: string);
            storeToXML(param0: java.io.OutputStream, param1: string, param2: string);
            propertyNames(): java.util.Enumeration;
            stringPropertyNames(): java.util.Set;
            remove(param0: any, param1: any): boolean;
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clone(): any;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            elements(): java.util.Enumeration;
            forEach(param0: java.util.function.BiConsumer);
            keys(): java.util.Enumeration;
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class PriorityQueue{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            poll(): any;
            peek(): any;
            offer(param0: any): boolean;
            comparator(): java.util.Comparator;
            remove(): any;
            addAll(param0: java.util.Collection): boolean;
            element(): any;
            toString(): string;
            isEmpty(): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class Objects{
            static hash(param0: any[]): number;
            static equals(param0: any, param1: any): boolean;
            static toString(param0: any): string;
            static toString(param0: any, param1: string): string;
            static hashCode(param0: any): number;
            static requireNonNull(param0: any): any;
            static requireNonNull(param0: any, param1: string): any;
            static requireNonNull(param0: any, param1: java.util.function.Supplier): any;
            static compare(param0: any, param1: any, param2: java.util.Comparator): number;
            static deepEquals(param0: any, param1: any): boolean;
            static isNull(param0: any): boolean;
            static nonNull(param0: any): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class NavigableSet{
            iterator(): java.util.Iterator;
            floor(param0: any): any;
            pollFirst(): any;
            pollLast(): any;
            descendingIterator(): java.util.Iterator;
            lower(param0: any): any;
            ceiling(param0: any): any;
            higher(param0: any): any;
            descendingSet(): java.util.NavigableSet;
            subSet(param0: any, param1: any): java.util.SortedSet;
            subSet(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableSet;
            headSet(param0: any): java.util.SortedSet;
            headSet(param0: any, param1: boolean): java.util.NavigableSet;
            tailSet(param0: any): java.util.SortedSet;
            tailSet(param0: any, param1: boolean): java.util.NavigableSet;
            spliterator(): java.util.Spliterator;
            first(): any;
            last(): any;
            comparator(): java.util.Comparator;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class NavigableMap{
            lowerEntry(param0: any): java.util.Map$Entry;
            lowerKey(param0: any): any;
            floorEntry(param0: any): java.util.Map$Entry;
            floorKey(param0: any): any;
            ceilingEntry(param0: any): java.util.Map$Entry;
            ceilingKey(param0: any): any;
            higherEntry(param0: any): java.util.Map$Entry;
            higherKey(param0: any): any;
            firstEntry(): java.util.Map$Entry;
            lastEntry(): java.util.Map$Entry;
            pollFirstEntry(): java.util.Map$Entry;
            pollLastEntry(): java.util.Map$Entry;
            descendingMap(): java.util.NavigableMap;
            navigableKeySet(): java.util.NavigableSet;
            descendingKeySet(): java.util.NavigableSet;
            subMap(param0: any, param1: boolean, param2: any, param3: boolean): java.util.NavigableMap;
            subMap(param0: any, param1: any): java.util.SortedMap;
            headMap(param0: any): java.util.SortedMap;
            headMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any, param1: boolean): java.util.NavigableMap;
            tailMap(param0: any): java.util.SortedMap;
            values(): java.util.Collection;
            entrySet(): java.util.Set;
            keySet(): java.util.Set;
            firstKey(): any;
            lastKey(): any;
            comparator(): java.util.Comparator;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class MissingResourceException{
            getKey(): string;
            getClassName(): string;
            printStackTrace(param0: java.io.PrintStream);
            printStackTrace();
            printStackTrace(param0: java.io.PrintWriter);
            fillInStackTrace(): java.lang.Throwable;
            getCause(): java.lang.Throwable;
            initCause(param0: java.lang.Throwable): java.lang.Throwable;
            toString(): string;
            getMessage(): string;
            getLocalizedMessage(): string;
            getStackTrace(): any[];
            setStackTrace(param0: any[]);
            addSuppressed(param0: java.lang.Throwable);
            getSuppressed(): any[];
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Map$Entry{
            equals(param0: any): boolean;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            static comparingByKey(param0: java.util.Comparator): java.util.Comparator;
            static comparingByKey(): java.util.Comparator;
            static comparingByValue(): java.util.Comparator;
            static comparingByValue(param0: java.util.Comparator): java.util.Comparator;
        }
        class Map{
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class Locale$LocaleKey{
            equals(param0: any): boolean;
            hashCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            toString(): string;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Locale$Category{
            static values(): any[];
            static valueOf(param0: string): java.util.Locale$Category;
            name(): string;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            compareTo(param0: any): number;
            compareTo(param0: java.lang.Enum): number;
            static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            getDeclaringClass(): java.lang.Class;
            ordinal(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Locale$Cache{
            get(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Locale$1{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Locale{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clone(): any;
            getLanguage(): string;
            static getDefault(param0: java.util.Locale$Category): java.util.Locale;
            static getDefault(): java.util.Locale;
            static lookup(param0: java.util.List, param1: java.util.Collection): java.util.Locale;
            static filter(param0: java.util.List, param1: java.util.Collection, param2: java.util.Locale$FilteringMode): java.util.List;
            static filter(param0: java.util.List, param1: java.util.Collection): java.util.List;
            static setDefault(param0: java.util.Locale$Category, param1: java.util.Locale);
            static setDefault(param0: java.util.Locale);
            static getAvailableLocales(): any[];
            static getISOCountries(): any[];
            static getISOLanguages(): any[];
            getScript(): string;
            getCountry(): string;
            getVariant(): string;
            hasExtensions(): boolean;
            stripExtensions(): java.util.Locale;
            getExtension(param0: string): string;
            getExtensionKeys(): java.util.Set;
            getUnicodeLocaleAttributes(): java.util.Set;
            getUnicodeLocaleType(param0: string): string;
            getUnicodeLocaleKeys(): java.util.Set;
            toLanguageTag(): string;
            static forLanguageTag(param0: string): java.util.Locale;
            getISO3Language(): string;
            getISO3Country(): string;
            getDisplayLanguage(): string;
            getDisplayLanguage(param0: java.util.Locale): string;
            getDisplayScript(param0: java.util.Locale): string;
            getDisplayScript(): string;
            getDisplayCountry(param0: java.util.Locale): string;
            getDisplayCountry(): string;
            getDisplayVariant(param0: java.util.Locale): string;
            getDisplayVariant(): string;
            getDisplayName(param0: java.util.Locale): string;
            getDisplayName(): string;
            static filterTags(param0: java.util.List, param1: java.util.Collection, param2: java.util.Locale$FilteringMode): java.util.List;
            static filterTags(param0: java.util.List, param1: java.util.Collection): java.util.List;
            static lookupTag(param0: java.util.List, param1: java.util.Collection): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ListResourceBundle{
            getKeys(): java.util.Enumeration;
            handleGetObject(param0: string): any;
            getObject(param0: string): any;
            keySet(): java.util.Set;
            containsKey(param0: string): boolean;
            getString(param0: string): string;
            getBaseBundleName(): string;
            getStringArray(param0: string): any[];
            getLocale(): java.util.Locale;
            static getBundle(param0: string, param1: java.util.Locale): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static getBundle(param0: string): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader): java.util.ResourceBundle;
            static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader, param3: java.util.ResourceBundle$Control): java.util.ResourceBundle;
            static clearCache(param0: java.lang.ClassLoader);
            static clearCache();
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ListIterator{
            add(param0: any);
            remove();
            hasNext(): boolean;
            next(): any;
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class List{
            add(param0: any): boolean;
            add(param0: number, param1: any);
            remove(param0: any): boolean;
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            clear();
            isEmpty(): boolean;
            lastIndexOf(param0: any): number;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            subList(param0: number, param1: number): java.util.List;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            sort(param0: java.util.Comparator);
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class LinkedList$Node{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class LinkedList$ListItr{
            add(param0: any);
            remove();
            hasNext(): boolean;
            next(): any;
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class LinkedList{
            add(param0: any): boolean;
            add(param0: number, param1: any);
            remove(param0: any): boolean;
            remove(): any;
            remove(param0: number): any;
            get(param0: number): any;
            clone(): any;
            indexOf(param0: any): number;
            clear();
            lastIndexOf(param0: any): number;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            spliterator(): java.util.Spliterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            addAll(param0: java.util.Collection): boolean;
            getFirst(): any;
            push(param0: any);
            pop(): any;
            poll(): any;
            set(param0: number, param1: any): any;
            peek(): any;
            listIterator(param0: number): java.util.ListIterator;
            addFirst(param0: any);
            addLast(param0: any);
            offerFirst(param0: any): boolean;
            offerLast(param0: any): boolean;
            removeFirst(): any;
            pollFirst(): any;
            pollLast(): any;
            getLast(): any;
            peekFirst(): any;
            removeFirstOccurrence(param0: any): boolean;
            removeLastOccurrence(param0: any): boolean;
            offer(param0: any): boolean;
            element(): any;
            descendingIterator(): java.util.Iterator;
            peekLast(): any;
            removeLast(): any;
            iterator(): java.util.Iterator;
            equals(param0: any): boolean;
            hashCode(): number;
            subList(param0: number, param1: number): java.util.List;
            listIterator(): java.util.ListIterator;
            toString(): string;
            isEmpty(): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            replaceAll(param0: java.util.function.UnaryOperator);
            sort(param0: java.util.Comparator);
        }
        class LinkedHashSet{
            spliterator(): java.util.Spliterator;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            clone(): any;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class LinkedHashMap$LinkedKeySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
        }
        class LinkedHashMap$LinkedKeyIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class LinkedHashMap$LinkedHashIterator{
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class LinkedHashMap$LinkedEntrySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
        }
        class LinkedHashMap$LinkedEntryIterator{
            next(): java.util.Map$Entry;
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class LinkedHashMap$Entry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class LinkedHashMap{
            get(param0: any): any;
            values(): java.util.Collection;
            clear();
            replaceAll(param0: java.util.function.BiFunction);
            entrySet(): java.util.Set;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            put(param0: any, param1: any): any;
            clone(): any;
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            size(): number;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            containsKey(param0: any): boolean;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Iterator{
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class IdentityHashMap$KeySet{
            remove(param0: any): boolean;
            hashCode(): number;
            clear();
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            removeAll(param0: java.util.Collection): boolean;
            equals(param0: any): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class IdentityHashMap$KeyIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class IdentityHashMap$IdentityHashMapIterator{
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class IdentityHashMap{
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            values(): java.util.Collection;
            hashCode(): number;
            clone(): any;
            clear();
            isEmpty(): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            toString(): string;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            putIfAbsent(param0: any, param1: any): any;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class Hashtable$ValueCollection{
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class Hashtable$Enumerator{
            remove();
            hasNext(): boolean;
            next(): any;
            hasMoreElements(): boolean;
            nextElement(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class Hashtable$EntrySet{
            add(param0: any): boolean;
            add(param0: java.util.Map$Entry): boolean;
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            spliterator(): java.util.Spliterator;
        }
        class Hashtable$Entry{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Hashtable{
            remove(param0: any, param1: any): boolean;
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clone(): any;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            elements(): java.util.Enumeration;
            forEach(param0: java.util.function.BiConsumer);
            keys(): java.util.Enumeration;
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class HashSet{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            clone(): any;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            toString(): string;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class HashMap$Values{
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
        }
        class HashMap$ValueIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class HashMap$TreeNode{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class HashMap$Node{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getValue(): any;
            getKey(): any;
            setValue(param0: any): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class HashMap$KeySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
        }
        class HashMap$KeyIterator{
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class HashMap$HashIterator{
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class HashMap$EntrySet{
            remove(param0: any): boolean;
            clear();
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
        }
        class HashMap$EntryIterator{
            next(): java.util.Map$Entry;
            next(): any;
            remove();
            hasNext(): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class HashMap{
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            values(): java.util.Collection;
            clone(): any;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class EventObject{
            toString(): string;
            getSource(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class EventListenerProxy{
            getListener(): java.util.EventListener;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class EventListener{
        }
        class Enumeration{
            hasMoreElements(): boolean;
            nextElement(): any;
        }
        class Dictionary{
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            isEmpty(): boolean;
            size(): number;
            elements(): java.util.Enumeration;
            keys(): java.util.Enumeration;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Deque{
            add(param0: any): boolean;
            remove(): any;
            remove(param0: any): boolean;
            contains(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
            getFirst(): any;
            push(param0: any);
            pop(): any;
            poll(): any;
            peek(): any;
            addFirst(param0: any);
            addLast(param0: any);
            offerFirst(param0: any): boolean;
            offerLast(param0: any): boolean;
            removeFirst(): any;
            pollFirst(): any;
            pollLast(): any;
            getLast(): any;
            peekFirst(): any;
            removeFirstOccurrence(param0: any): boolean;
            removeLastOccurrence(param0: any): boolean;
            offer(param0: any): boolean;
            element(): any;
            descendingIterator(): java.util.Iterator;
            peekLast(): any;
            removeLast(): any;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class Date{
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clone(): any;
            compareTo(param0: java.util.Date): number;
            compareTo(param0: any): number;
            static parse(param0: string): number;
            before(param0: java.util.Date): boolean;
            after(param0: java.util.Date): boolean;
            setTime(param0: number);
            getTime(): number;
            static from(param0: java.time.Instant): java.util.Date;
            getDate(): number;
            setDate(param0: number);
            static UTC(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number): number;
            toInstant(): java.time.Instant;
            getYear(): number;
            setYear(param0: number);
            getMonth(): number;
            setMonth(param0: number);
            getDay(): number;
            getHours(): number;
            setHours(param0: number);
            getMinutes(): number;
            setMinutes(param0: number);
            getSeconds(): number;
            setSeconds(param0: number);
            toLocaleString(): string;
            toGMTString(): string;
            getTimezoneOffset(): number;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Comparator{
            equals(param0: any): boolean;
            compare(param0: any, param1: any): number;
            reversed(): java.util.Comparator;
            thenComparing(param0: java.util.function.Function): java.util.Comparator;
            thenComparing(param0: java.util.function.Function, param1: java.util.Comparator): java.util.Comparator;
            thenComparing(param0: java.util.Comparator): java.util.Comparator;
            thenComparingInt(param0: java.util.function.ToIntFunction): java.util.Comparator;
            thenComparingLong(param0: java.util.function.ToLongFunction): java.util.Comparator;
            thenComparingDouble(param0: java.util.function.ToDoubleFunction): java.util.Comparator;
            static reverseOrder(): java.util.Comparator;
            static naturalOrder(): java.util.Comparator;
            static nullsFirst(param0: java.util.Comparator): java.util.Comparator;
            static nullsLast(param0: java.util.Comparator): java.util.Comparator;
            static comparing(param0: java.util.function.Function, param1: java.util.Comparator): java.util.Comparator;
            static comparing(param0: java.util.function.Function): java.util.Comparator;
            static comparingInt(param0: java.util.function.ToIntFunction): java.util.Comparator;
            static comparingLong(param0: java.util.function.ToLongFunction): java.util.Comparator;
            static comparingDouble(param0: java.util.function.ToDoubleFunction): java.util.Comparator;
        }
        class ComparableTimSort{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableSortedSet{
            first(): any;
            last(): any;
            subSet(param0: any, param1: any): java.util.SortedSet;
            headSet(param0: any): java.util.SortedSet;
            tailSet(param0: any): java.util.SortedSet;
            comparator(): java.util.Comparator;
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableSet{
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableRandomAccessList{
            subList(param0: number, param1: number): java.util.List;
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            lastIndexOf(param0: any): number;
            replaceAll(param0: java.util.function.UnaryOperator);
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            sort(param0: java.util.Comparator);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableMap{
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableList{
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            lastIndexOf(param0: any): number;
            replaceAll(param0: java.util.function.UnaryOperator);
            subList(param0: number, param1: number): java.util.List;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            sort(param0: java.util.Comparator);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableCollection$1{
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$UnmodifiableCollection{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SynchronizedSet{
            equals(param0: any): boolean;
            hashCode(): number;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SynchronizedMap{
            remove(param0: any): any;
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SynchronizedCollection{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$SetFromMap{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            addAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$EmptySet{
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            addAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            parallelStream(): java.util.stream.Stream;
        }
        class Collections$EmptyMap{
            remove(param0: any, param1: any): boolean;
            get(param0: any): any;
            equals(param0: any): boolean;
            values(): java.util.Collection;
            hashCode(): number;
            isEmpty(): boolean;
            replace(param0: any, param1: any, param2: any): boolean;
            replace(param0: any, param1: any): any;
            replaceAll(param0: java.util.function.BiFunction);
            size(): number;
            entrySet(): java.util.Set;
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
            remove(param0: any): any;
            put(param0: any, param1: any): any;
            toString(): string;
            clear();
            putAll(param0: java.util.Map);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections$EmptyList{
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            containsAll(param0: java.util.Collection): boolean;
            listIterator(): java.util.ListIterator;
            removeIf(param0: java.util.function.Predicate): boolean;
            sort(param0: java.util.Comparator);
            add(param0: number, param1: any);
            add(param0: any): boolean;
            remove(param0: number): any;
            indexOf(param0: any): number;
            clear();
            lastIndexOf(param0: any): number;
            subList(param0: number, param1: number): java.util.List;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            addAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            parallelStream(): java.util.stream.Stream;
        }
        class Collections$EmptyEnumeration{
            hasMoreElements(): boolean;
            nextElement(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collections{
            static min(param0: java.util.Collection, param1: java.util.Comparator): any;
            static min(param0: java.util.Collection): any;
            static max(param0: java.util.Collection, param1: java.util.Comparator): any;
            static max(param0: java.util.Collection): any;
            static replaceAll(param0: java.util.List, param1: any, param2: any): boolean;
            static addAll(param0: java.util.Collection, param1: any[]): boolean;
            static emptyEnumeration(): java.util.Enumeration;
            static newSetFromMap(param0: java.util.Map): java.util.Set;
            static unmodifiableList(param0: java.util.List): java.util.List;
            static list(param0: java.util.Enumeration): java.util.ArrayList;
            static emptyIterator(): java.util.Iterator;
            static synchronizedSet(param0: java.util.Set): java.util.Set;
            static synchronizedCollection(param0: java.util.Collection): java.util.Collection;
            static copy(param0: java.util.List, param1: java.util.List);
            static fill(param0: java.util.List, param1: any);
            static nCopies(param0: number, param1: any): java.util.List;
            static reverse(param0: java.util.List);
            static reverseOrder(): java.util.Comparator;
            static reverseOrder(param0: java.util.Comparator): java.util.Comparator;
            static sort(param0: java.util.List, param1: java.util.Comparator);
            static sort(param0: java.util.List);
            static synchronizedList(param0: java.util.List): java.util.List;
            static binarySearch(param0: java.util.List, param1: any, param2: java.util.Comparator): number;
            static binarySearch(param0: java.util.List, param1: any): number;
            static shuffle(param0: java.util.List);
            static shuffle(param0: java.util.List, param1: java.util.Random);
            static swap(param0: java.util.List, param1: number, param2: number);
            static rotate(param0: java.util.List, param1: number);
            static indexOfSubList(param0: java.util.List, param1: java.util.List): number;
            static lastIndexOfSubList(param0: java.util.List, param1: java.util.List): number;
            static unmodifiableCollection(param0: java.util.Collection): java.util.Collection;
            static unmodifiableSet(param0: java.util.Set): java.util.Set;
            static unmodifiableSortedSet(param0: java.util.SortedSet): java.util.SortedSet;
            static unmodifiableNavigableSet(param0: java.util.NavigableSet): java.util.NavigableSet;
            static unmodifiableMap(param0: java.util.Map): java.util.Map;
            static unmodifiableSortedMap(param0: java.util.SortedMap): java.util.SortedMap;
            static unmodifiableNavigableMap(param0: java.util.NavigableMap): java.util.NavigableMap;
            static synchronizedSortedSet(param0: java.util.SortedSet): java.util.SortedSet;
            static synchronizedNavigableSet(param0: java.util.NavigableSet): java.util.NavigableSet;
            static synchronizedMap(param0: java.util.Map): java.util.Map;
            static synchronizedSortedMap(param0: java.util.SortedMap): java.util.SortedMap;
            static synchronizedNavigableMap(param0: java.util.NavigableMap): java.util.NavigableMap;
            static checkedCollection(param0: java.util.Collection, param1: java.lang.Class): java.util.Collection;
            static checkedQueue(param0: java.util.Queue, param1: java.lang.Class): java.util.Queue;
            static checkedSet(param0: java.util.Set, param1: java.lang.Class): java.util.Set;
            static checkedSortedSet(param0: java.util.SortedSet, param1: java.lang.Class): java.util.SortedSet;
            static checkedNavigableSet(param0: java.util.NavigableSet, param1: java.lang.Class): java.util.NavigableSet;
            static checkedList(param0: java.util.List, param1: java.lang.Class): java.util.List;
            static checkedMap(param0: java.util.Map, param1: java.lang.Class, param2: java.lang.Class): java.util.Map;
            static checkedSortedMap(param0: java.util.SortedMap, param1: java.lang.Class, param2: java.lang.Class): java.util.SortedMap;
            static checkedNavigableMap(param0: java.util.NavigableMap, param1: java.lang.Class, param2: java.lang.Class): java.util.NavigableMap;
            static emptyListIterator(): java.util.ListIterator;
            static emptySet(): java.util.Set;
            static emptySortedSet(): java.util.SortedSet;
            static emptyNavigableSet(): java.util.NavigableSet;
            static emptyList(): java.util.List;
            static emptyMap(): java.util.Map;
            static emptySortedMap(): java.util.SortedMap;
            static emptyNavigableMap(): java.util.NavigableMap;
            static singleton(param0: any): java.util.Set;
            static singletonList(param0: any): java.util.List;
            static singletonMap(param0: any, param1: any): java.util.Map;
            static enumeration(param0: java.util.Collection): java.util.Enumeration;
            static frequency(param0: java.util.Collection, param1: any): number;
            static disjoint(param0: java.util.Collection, param1: java.util.Collection): boolean;
            static asLifoQueue(param0: java.util.Deque): java.util.Queue;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Collection{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: java.util.Collection): boolean;
            stream(): java.util.stream.Stream;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class BitSet{
            get(param0: number, param1: number): java.util.BitSet;
            get(param0: number): boolean;
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            clone(): any;
            static valueOf(param0: java.nio.LongBuffer): java.util.BitSet;
            static valueOf(param0: any[]): java.util.BitSet;
            static valueOf(param0: java.nio.ByteBuffer): java.util.BitSet;
            static valueOf(param0: any[]): java.util.BitSet;
            clear();
            clear(param0: number);
            clear(param0: number, param1: number);
            length(): number;
            isEmpty(): boolean;
            size(): number;
            stream(): java.util.stream.IntStream;
            set(param0: number);
            set(param0: number, param1: boolean);
            set(param0: number, param1: number);
            set(param0: number, param1: number, param2: boolean);
            flip(param0: number);
            flip(param0: number, param1: number);
            nextClearBit(param0: number): number;
            toByteArray(): any[];
            toLongArray(): any[];
            nextSetBit(param0: number): number;
            previousSetBit(param0: number): number;
            previousClearBit(param0: number): number;
            intersects(param0: java.util.BitSet): boolean;
            cardinality(): number;
            and(param0: java.util.BitSet);
            or(param0: java.util.BitSet);
            xor(param0: java.util.BitSet);
            andNot(param0: java.util.BitSet);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Arrays$LegacyMergeSort{
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class Arrays$ArrayList{
            get(param0: number): any;
            indexOf(param0: any): number;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            spliterator(): java.util.Spliterator;
            forEach(param0: java.util.function.Consumer);
            set(param0: number, param1: any): any;
            sort(param0: java.util.Comparator);
            add(param0: number, param1: any);
            add(param0: any): boolean;
            remove(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            clear();
            lastIndexOf(param0: any): number;
            subList(param0: number, param1: number): java.util.List;
            iterator(): java.util.Iterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
        }
        class Arrays{
            static equals(param0: any[], param1: any[]): boolean;
            static equals(param0: any[], param1: any[]): boolean;
            static equals(param0: any[], param1: any[]): boolean;
            static equals(param0: any[], param1: any[]): boolean;
            static equals(param0: any[], param1: any[]): boolean;
            static equals(param0: any[], param1: any[]): boolean;
            static equals(param0: any[], param1: any[]): boolean;
            static equals(param0: any[], param1: any[]): boolean;
            static equals(param0: any[], param1: any[]): boolean;
            static toString(param0: any[]): string;
            static toString(param0: any[]): string;
            static toString(param0: any[]): string;
            static toString(param0: any[]): string;
            static toString(param0: any[]): string;
            static toString(param0: any[]): string;
            static toString(param0: any[]): string;
            static toString(param0: any[]): string;
            static toString(param0: any[]): string;
            static hashCode(param0: any[]): number;
            static hashCode(param0: any[]): number;
            static hashCode(param0: any[]): number;
            static hashCode(param0: any[]): number;
            static hashCode(param0: any[]): number;
            static hashCode(param0: any[]): number;
            static hashCode(param0: any[]): number;
            static hashCode(param0: any[]): number;
            static hashCode(param0: any[]): number;
            static copyOf(param0: any[], param1: number): any[];
            static copyOf(param0: any[], param1: number): any[];
            static copyOf(param0: any[], param1: number): any[];
            static copyOf(param0: any[], param1: number): any[];
            static copyOf(param0: any[], param1: number): any[];
            static copyOf(param0: any[], param1: number): any[];
            static copyOf(param0: any[], param1: number, param2: java.lang.Class): any[];
            static copyOf(param0: any[], param1: number): any[];
            static copyOf(param0: any[], param1: number): any[];
            static copyOf(param0: any[], param1: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number, param3: java.lang.Class): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static copyOfRange(param0: any[], param1: number, param2: number): any[];
            static spliterator(param0: any[], param1: number, param2: number): java.util.Spliterator$OfLong;
            static spliterator(param0: any[]): java.util.Spliterator$OfLong;
            static spliterator(param0: any[], param1: number, param2: number): java.util.Spliterator$OfInt;
            static spliterator(param0: any[]): java.util.Spliterator$OfDouble;
            static spliterator(param0: any[], param1: number, param2: number): java.util.Spliterator$OfDouble;
            static spliterator(param0: any[]): java.util.Spliterator;
            static spliterator(param0: any[], param1: number, param2: number): java.util.Spliterator;
            static spliterator(param0: any[]): java.util.Spliterator$OfInt;
            static stream(param0: any[]): java.util.stream.IntStream;
            static stream(param0: any[], param1: number, param2: number): java.util.stream.Stream;
            static stream(param0: any[]): java.util.stream.Stream;
            static stream(param0: any[]): java.util.stream.DoubleStream;
            static stream(param0: any[], param1: number, param2: number): java.util.stream.IntStream;
            static stream(param0: any[]): java.util.stream.LongStream;
            static stream(param0: any[], param1: number, param2: number): java.util.stream.LongStream;
            static stream(param0: any[], param1: number, param2: number): java.util.stream.DoubleStream;
            static asList(param0: any[]): java.util.List;
            static fill(param0: any[], param1: number, param2: number, param3: number);
            static fill(param0: any[], param1: number);
            static fill(param0: any[], param1: number);
            static fill(param0: any[], param1: number);
            static fill(param0: any[], param1: number, param2: number, param3: boolean);
            static fill(param0: any[], param1: number, param2: number, param3: any);
            static fill(param0: any[], param1: any);
            static fill(param0: any[], param1: number, param2: number, param3: number);
            static fill(param0: any[], param1: string);
            static fill(param0: any[], param1: number, param2: number, param3: string);
            static fill(param0: any[], param1: number);
            static fill(param0: any[], param1: number, param2: number, param3: number);
            static fill(param0: any[], param1: boolean);
            static fill(param0: any[], param1: number, param2: number, param3: number);
            static fill(param0: any[], param1: number, param2: number, param3: number);
            static fill(param0: any[], param1: number);
            static fill(param0: any[], param1: number, param2: number, param3: number);
            static fill(param0: any[], param1: number);
            static sort(param0: any[]);
            static sort(param0: any[], param1: number, param2: number);
            static sort(param0: any[], param1: number, param2: number);
            static sort(param0: any[]);
            static sort(param0: any[], param1: number, param2: number);
            static sort(param0: any[]);
            static sort(param0: any[], param1: number, param2: number);
            static sort(param0: any[], param1: number, param2: number);
            static sort(param0: any[]);
            static sort(param0: any[]);
            static sort(param0: any[], param1: number, param2: number, param3: java.util.Comparator);
            static sort(param0: any[], param1: java.util.Comparator);
            static sort(param0: any[]);
            static sort(param0: any[], param1: number, param2: number);
            static sort(param0: any[]);
            static sort(param0: any[]);
            static sort(param0: any[], param1: number, param2: number);
            static sort(param0: any[], param1: number, param2: number);
            static binarySearch(param0: any[], param1: number, param2: number, param3: number): number;
            static binarySearch(param0: any[], param1: number): number;
            static binarySearch(param0: any[], param1: number, param2: number, param3: number): number;
            static binarySearch(param0: any[], param1: number): number;
            static binarySearch(param0: any[], param1: any): number;
            static binarySearch(param0: any[], param1: number, param2: number, param3: number): number;
            static binarySearch(param0: any[], param1: number): number;
            static binarySearch(param0: any[], param1: number, param2: number, param3: number): number;
            static binarySearch(param0: any[], param1: number, param2: number, param3: any): number;
            static binarySearch(param0: any[], param1: any, param2: java.util.Comparator): number;
            static binarySearch(param0: any[], param1: number, param2: number, param3: any, param4: java.util.Comparator): number;
            static binarySearch(param0: any[], param1: number): number;
            static binarySearch(param0: any[], param1: number, param2: number, param3: number): number;
            static binarySearch(param0: any[], param1: string): number;
            static binarySearch(param0: any[], param1: number, param2: number, param3: string): number;
            static binarySearch(param0: any[], param1: number): number;
            static binarySearch(param0: any[], param1: number, param2: number, param3: number): number;
            static binarySearch(param0: any[], param1: number): number;
            static parallelSort(param0: any[], param1: number, param2: number);
            static parallelSort(param0: any[]);
            static parallelSort(param0: any[]);
            static parallelSort(param0: any[], param1: number, param2: number);
            static parallelSort(param0: any[]);
            static parallelSort(param0: any[], param1: number, param2: number);
            static parallelSort(param0: any[]);
            static parallelSort(param0: any[]);
            static parallelSort(param0: any[], param1: number, param2: number);
            static parallelSort(param0: any[]);
            static parallelSort(param0: any[], param1: number, param2: number);
            static parallelSort(param0: any[]);
            static parallelSort(param0: any[], param1: number, param2: number);
            static parallelSort(param0: any[], param1: number, param2: number, param3: java.util.Comparator);
            static parallelSort(param0: any[], param1: java.util.Comparator);
            static parallelSort(param0: any[], param1: number, param2: number);
            static parallelSort(param0: any[], param1: number, param2: number);
            static parallelSort(param0: any[]);
            static parallelPrefix(param0: any[], param1: java.util.function.DoubleBinaryOperator);
            static parallelPrefix(param0: any[], param1: number, param2: number, param3: java.util.function.DoubleBinaryOperator);
            static parallelPrefix(param0: any[], param1: java.util.function.IntBinaryOperator);
            static parallelPrefix(param0: any[], param1: java.util.function.LongBinaryOperator);
            static parallelPrefix(param0: any[], param1: number, param2: number, param3: java.util.function.LongBinaryOperator);
            static parallelPrefix(param0: any[], param1: java.util.function.BinaryOperator);
            static parallelPrefix(param0: any[], param1: number, param2: number, param3: java.util.function.BinaryOperator);
            static parallelPrefix(param0: any[], param1: number, param2: number, param3: java.util.function.IntBinaryOperator);
            static deepHashCode(param0: any[]): number;
            static deepEquals(param0: any[], param1: any[]): boolean;
            static deepToString(param0: any[]): string;
            static setAll(param0: any[], param1: java.util.function.IntToDoubleFunction);
            static setAll(param0: any[], param1: java.util.function.IntFunction);
            static setAll(param0: any[], param1: java.util.function.IntToLongFunction);
            static setAll(param0: any[], param1: java.util.function.IntUnaryOperator);
            static parallelSetAll(param0: any[], param1: java.util.function.IntToDoubleFunction);
            static parallelSetAll(param0: any[], param1: java.util.function.IntToLongFunction);
            static parallelSetAll(param0: any[], param1: java.util.function.IntUnaryOperator);
            static parallelSetAll(param0: any[], param1: java.util.function.IntFunction);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayList$SubList$1{
            add(param0: any);
            remove();
            hasNext(): boolean;
            next(): any;
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayList$SubList{
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            size(): number;
            subList(param0: number, param1: number): java.util.List;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            addAll(param0: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            add(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            clear();
            lastIndexOf(param0: any): number;
            listIterator(): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            toArray(param0: any[]): any[];
            toArray(): any[];
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            replaceAll(param0: java.util.function.UnaryOperator);
            sort(param0: java.util.Comparator);
        }
        class ArrayList$ListItr{
            add(param0: any);
            set(param0: any);
            previousIndex(): number;
            hasPrevious(): boolean;
            previous(): any;
            nextIndex(): number;
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayList$Itr{
            remove();
            hasNext(): boolean;
            next(): any;
            forEachRemaining(param0: java.util.function.Consumer);
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
        }
        class ArrayList{
            add(param0: number, param1: any);
            add(param0: any): boolean;
            remove(param0: any): boolean;
            remove(param0: number): any;
            get(param0: number): any;
            clone(): any;
            indexOf(param0: any): number;
            clear();
            isEmpty(): boolean;
            lastIndexOf(param0: any): number;
            contains(param0: any): boolean;
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            subList(param0: number, param1: number): java.util.List;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            addAll(param0: java.util.Collection): boolean;
            forEach(param0: java.util.function.Consumer);
            set(param0: number, param1: any): any;
            ensureCapacity(param0: number);
            trimToSize();
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            listIterator(): java.util.ListIterator;
            listIterator(param0: number): java.util.ListIterator;
            removeIf(param0: java.util.function.Predicate): boolean;
            sort(param0: java.util.Comparator);
            equals(param0: any): boolean;
            hashCode(): number;
            toString(): string;
            containsAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            parallelStream(): java.util.stream.Stream;
        }
        class ArrayDeque{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            remove(): any;
            clone(): java.util.ArrayDeque;
            clone(): any;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(): any[];
            toArray(param0: any[]): any[];
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
            getFirst(): any;
            push(param0: any);
            pop(): any;
            poll(): any;
            peek(): any;
            addFirst(param0: any);
            addLast(param0: any);
            offerFirst(param0: any): boolean;
            offerLast(param0: any): boolean;
            removeFirst(): any;
            pollFirst(): any;
            pollLast(): any;
            getLast(): any;
            peekFirst(): any;
            removeFirstOccurrence(param0: any): boolean;
            removeLastOccurrence(param0: any): boolean;
            offer(param0: any): boolean;
            element(): any;
            descendingIterator(): java.util.Iterator;
            peekLast(): any;
            removeLast(): any;
            toString(): string;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
        class AbstractSet{
            equals(param0: any): boolean;
            hashCode(): number;
            removeAll(param0: java.util.Collection): boolean;
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            size(): number;
            iterator(): java.util.Iterator;
            spliterator(): java.util.Spliterator;
        }
        class AbstractSequentialList{
            add(param0: number, param1: any);
            remove(param0: number): any;
            get(param0: number): any;
            iterator(): java.util.Iterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            add(param0: any): boolean;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            clear();
            lastIndexOf(param0: any): number;
            subList(param0: number, param1: number): java.util.List;
            listIterator(): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            spliterator(): java.util.Spliterator;
            sort(param0: java.util.Comparator);
        }
        class AbstractQueue{
            add(param0: any): boolean;
            remove(): any;
            clear();
            addAll(param0: java.util.Collection): boolean;
            element(): any;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            poll(): any;
            peek(): any;
            offer(param0: any): boolean;
            size(): number;
            iterator(): java.util.Iterator;
        }
        class AbstractMap{
            remove(param0: any): any;
            get(param0: any): any;
            put(param0: any, param1: any): any;
            equals(param0: any): boolean;
            toString(): string;
            values(): java.util.Collection;
            hashCode(): number;
            clear();
            isEmpty(): boolean;
            size(): number;
            entrySet(): java.util.Set;
            putAll(param0: java.util.Map);
            keySet(): java.util.Set;
            containsValue(param0: any): boolean;
            containsKey(param0: any): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            remove(param0: any, param1: any): boolean;
            replace(param0: any, param1: any): any;
            replace(param0: any, param1: any, param2: any): boolean;
            replaceAll(param0: java.util.function.BiFunction);
            putIfAbsent(param0: any, param1: any): any;
            forEach(param0: java.util.function.BiConsumer);
            getOrDefault(param0: any, param1: any): any;
            computeIfAbsent(param0: any, param1: java.util.function.Function): any;
            computeIfPresent(param0: any, param1: java.util.function.BiFunction): any;
            compute(param0: any, param1: java.util.function.BiFunction): any;
            merge(param0: any, param1: any, param2: java.util.function.BiFunction): any;
        }
        class AbstractList$Itr{
            remove();
            hasNext(): boolean;
            next(): any;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            toString(): string;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            forEachRemaining(param0: java.util.function.Consumer);
        }
        class AbstractList{
            add(param0: number, param1: any);
            add(param0: any): boolean;
            remove(param0: number): any;
            get(param0: number): any;
            equals(param0: any): boolean;
            hashCode(): number;
            indexOf(param0: any): number;
            clear();
            lastIndexOf(param0: any): number;
            subList(param0: number, param1: number): java.util.List;
            iterator(): java.util.Iterator;
            addAll(param0: number, param1: java.util.Collection): boolean;
            set(param0: number, param1: any): any;
            listIterator(param0: number): java.util.ListIterator;
            listIterator(): java.util.ListIterator;
            remove(param0: any): boolean;
            toString(): string;
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
            replaceAll(param0: java.util.function.UnaryOperator);
            size(): number;
            spliterator(): java.util.Spliterator;
            sort(param0: java.util.Comparator);
        }
        class AbstractCollection{
            add(param0: any): boolean;
            remove(param0: any): boolean;
            toString(): string;
            clear();
            isEmpty(): boolean;
            contains(param0: any): boolean;
            size(): number;
            toArray(param0: any[]): any[];
            toArray(): any[];
            iterator(): java.util.Iterator;
            addAll(param0: java.util.Collection): boolean;
            containsAll(param0: java.util.Collection): boolean;
            removeAll(param0: java.util.Collection): boolean;
            retainAll(param0: java.util.Collection): boolean;
            wait(param0: number, param1: number);
            wait(param0: number);
            wait();
            equals(param0: any): boolean;
            hashCode(): number;
            getClass(): java.lang.Class;
            notify();
            notifyAll();
            spliterator(): java.util.Spliterator;
            stream(): java.util.stream.Stream;
            removeIf(param0: java.util.function.Predicate): boolean;
            parallelStream(): java.util.stream.Stream;
            forEach(param0: java.util.function.Consumer);
        }
    }
}

